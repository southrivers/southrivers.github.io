<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>akka实现rpc服务</title>
      <link href="/2022/08/21/akka%E5%AE%9E%E7%8E%B0rpc%E6%9C%8D%E5%8A%A1/"/>
      <url>/2022/08/21/akka%E5%AE%9E%E7%8E%B0rpc%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flink 解析</title>
      <link href="/2022/08/20/flink-%E8%A7%A3%E6%9E%90/"/>
      <url>/2022/08/20/flink-%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>流式计算框架常见的有storm、spark streaming、flink，其中storm和spark streaming出现的时间比较久了，storm应用在对实时性要求比较高的场景，不过其吞吐却比较低，有幸在15年左右的时候使用过storm做开发，其在数据一致性上也比较堪忧，新生的spark streaming可以看作是storm的替代品，不过其采用的却不是流式模型，而是采用的微批次，相较于storm来说其吞吐有了很大的提升，不过我们在做监控业务的时候依然遇到很多问题，其中一个比较重要的问题就是对延迟数据的处理，通常这种流式处理框架都会对接kafka，不过发送到kafka的数据由于分区、延迟等情况可能会导致数据乱序、迟到，在做聚合操作的时候就会产生数据丢失的情况，对于上述情景，有人提出lambda的架构，也就是将实时和批处理同时进行，不过现在又了更好的解决方案flink，flink相较于spark streaming来说其属于实时的处理模型，并不再是微批次，另外其可以针对迟到的数据进行相应的处理，同时能够保障exactly-once的语义，当前工作的环境在大力的推广flink，原本由spark streaming处理的工作现在更多的交给了flink。因此抽时间好好整理一下flink及其相关特性。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="作业提交流程分析"><a href="#作业提交流程分析" class="headerlink" title="作业提交流程分析"></a>作业提交流程分析</h2><p>在深入了解flink特性之前，我们先通过简单的实例来分析一下flink中作业的提交的流程，首先我们引入如下依赖，pom依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">flink.version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">flink.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scala.binary.version</span>&gt;</span>2.11<span class="tag">&lt;/<span class="name">scala.binary.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>$&#123;java.version&#125;<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span>&gt;</span>apache.snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache Development Snapshot Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span>https://repository.apache.org/content/repositories/snapshots/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Apache Flink dependencies --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- These dependencies are provided, because they should not be packaged into the JAR file. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_$&#123;scala.binary.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;flink.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.myorg.quickstart;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.JobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.ReduceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.core.execution.JobListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Skeleton for a Flink Streaming Job.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;For a tutorial how to write a Flink streaming application, check the</span></span><br><span class="line"><span class="comment"> * tutorials and examples on the &lt;a href="https://flink.apache.org/docs/stable/"&gt;Flink Website&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;To package your application into a JAR file for execution, run</span></span><br><span class="line"><span class="comment"> * 'mvn clean package' on the command line.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If you change the name of the main class (with the public static void main(String[] args))</span></span><br><span class="line"><span class="comment"> * method, change the respective entry in the POM.xml file (simply search for 'mainClass').</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingJob</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// set up the streaming execution environment</span></span><br><span class="line"><span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">env.registerJobListener(<span class="keyword">new</span> JobListener() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onJobSubmitted</span><span class="params">(@Nullable JobClient jobClient, @Nullable Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onJobExecuted</span><span class="params">(@Nullable JobExecutionResult jobExecutionResult, @Nullable Throwable throwable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">DataStream&lt;String&gt; ds= env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line">DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; text = ds.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (String word : s.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">collector.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(word, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">5</span>), Time.seconds(<span class="number">5</span>)).reduce(<span class="keyword">new</span> ReduceFunction&lt;Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">reduce</span><span class="params">(Tuple2&lt;String, Integer&gt; stringIntegerTuple2, Tuple2&lt;String, Integer&gt; t1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(t1.f0, t1.f1+ stringIntegerTuple2.f1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">text.print().setParallelism(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// execute program</span></span><br><span class="line">env.execute(<span class="string">"Flink Streaming Java API Skeleton"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上述代码，我们来简单的分析一下作业的执行流程：</p><ul><li><p>创建执行环境<code>StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</code>，这一步可以看作是创建一个容器，也即是该env，后续作业的相关信息、配置相关的信息都会存放在该env中。</p></li><li><p>接下来向该env添加source、transform、sink，值得注意的是这里的<code>text.print()</code>其实就是添加了一个sink，其具体代码如下：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataStreamSink&lt;T&gt; <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrintSinkFunction&lt;T&gt; printFunction = <span class="keyword">new</span> PrintSinkFunction&lt;&gt;();</span><br><span class="line">    <span class="keyword">return</span> addSink(printFunction).name(<span class="string">"Print to Std. Out"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>触发作业的执行，这一步信息量有点大，不过大概的流程如下：<img src="//southrivers.github.io/2022/08/20/flink-解析/jobsubmit.png" alt>我们接下来分析一下这些对象创建的时机及作业提交、运行的时机</p><ul><li><p>根据前面的source、transform、sink信息，生成streamgraph，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StreamGraph <span class="title">getStreamGraph</span><span class="params">(String jobName, <span class="keyword">boolean</span> clearTransformations)</span> </span>&#123;</span><br><span class="line">StreamGraph streamGraph = getStreamGraphGenerator().setJobName(jobName).generate();</span><br><span class="line"><span class="keyword">if</span> (clearTransformations) &#123;</span><br><span class="line"><span class="keyword">this</span>.transformations.clear();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> streamGraph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>env根据给定的streamgraph初始化一些必须的对象，并执行作业，这里会调用env的<code>execute(streamgraph)</code>方法，不过这个时候作业运行的所有必须的对象都还没有初始化，该过程接下来就会创建这些必须的对象并真正的执行作业。核心代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> JobClient jobClient = executeAsync(streamGraph);</span><br></pre></td></tr></table></figure></li></ul><p>上面代码看起来是创建jobclient，不过该过程是最复杂的过程。接下来跟进一下代码来看一该步骤对应的操作有哪些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> JobClient <span class="title">executeAsync</span><span class="params">(StreamGraph streamGraph)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">CompletableFuture&lt;JobClient&gt; jobClientFuture = executorFactory</span><br><span class="line">.getExecutor(configuration)</span><br><span class="line">.execute(streamGraph, configuration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">JobClient jobClient = jobClientFuture.get();</span><br><span class="line">jobListeners.forEach(jobListener -&gt; jobListener.onJobSubmitted(jobClient, <span class="keyword">null</span>));</span><br><span class="line"><span class="keyword">return</span> jobClient;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的核心是<code>jobClientFuture</code>的创建，这一步创建一个<code>executor</code>对象，该对象封装了一些执行作业的方法，因此可以看到接下来就会调用<code>execute</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobClient&gt; <span class="title">execute</span><span class="params">(Pipeline pipeline, Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">checkNotNull(pipeline);</span><br><span class="line">checkNotNull(configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we only support attached execution with the local executor.</span></span><br><span class="line">checkState(configuration.getBoolean(DeploymentOptions.ATTACHED));</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> JobGraph jobGraph = getJobGraph(pipeline, configuration);</span><br><span class="line"><span class="keyword">final</span> MiniCluster miniCluster = startMiniCluster(jobGraph, configuration);</span><br><span class="line"><span class="keyword">final</span> MiniClusterClient clusterClient = <span class="keyword">new</span> MiniClusterClient(configuration, miniCluster);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;JobID&gt; jobIdFuture = clusterClient.submitJob(jobGraph);</span><br><span class="line"></span><br><span class="line">jobIdFuture</span><br><span class="line">.thenCompose(clusterClient::requestJobResult)</span><br><span class="line">.thenAccept((jobResult) -&gt; clusterClient.shutDownCluster());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> jobIdFuture.thenApply(jobID -&gt;</span><br><span class="line"><span class="keyword">new</span> ClusterClientJobClientAdapter&lt;&gt;(() -&gt; clusterClient, jobID));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先会生成jobgraph，这一步是基于stream而生成的，还可以看到<strong>jobgraph的生成是在cluster、client的创建之前完成的</strong>，加下来创建cluster、clusterclient并借助client提交作业到集群，可以看到该client提交的作业为jobgraph，并不是streamgraph。接下来还涉及到的资源就是jobmanager、taskmanager了，其中taskmanager的创建是在<code>startMiniCluster</code>的过程中创建的，：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> MiniCluster <span class="title">startMiniCluster</span><span class="params">(<span class="keyword">final</span> JobGraph jobGraph, <span class="keyword">final</span> Configuration configuration)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!configuration.contains(RestOptions.BIND_PORT)) &#123;</span><br><span class="line">configuration.setString(RestOptions.BIND_PORT, <span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> numTaskManagers = configuration.getInteger(</span><br><span class="line">ConfigConstants.LOCAL_NUMBER_TASK_MANAGER,</span><br><span class="line">ConfigConstants.DEFAULT_LOCAL_NUMBER_TASK_MANAGER);</span><br><span class="line"></span><br><span class="line"><span class="comment">// we have to use the maximum parallelism as a default here, otherwise streaming</span></span><br><span class="line"><span class="comment">// pipelines would not run</span></span><br><span class="line"><span class="keyword">int</span> numSlotsPerTaskManager = configuration.getInteger(</span><br><span class="line">TaskManagerOptions.NUM_TASK_SLOTS,</span><br><span class="line">jobGraph.getMaximumParallelism());</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MiniClusterConfiguration miniClusterConfiguration =</span><br><span class="line"><span class="keyword">new</span> MiniClusterConfiguration.Builder()</span><br><span class="line">.setConfiguration(configuration)</span><br><span class="line">.setNumTaskManagers(numTaskManagers)</span><br><span class="line">.setRpcServiceSharing(RpcServiceSharing.SHARED)</span><br><span class="line">.setNumSlotsPerTaskManager(numSlotsPerTaskManager)</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> MiniCluster miniCluster = <span class="keyword">new</span> MiniCluster(miniClusterConfiguration);</span><br><span class="line">miniCluster.start();</span><br><span class="line"></span><br><span class="line">configuration.setInteger(RestOptions.PORT, miniCluster.getRestAddress().get().getPort());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> miniCluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来可以看到启动集群的过程中就会创建taskmanager</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">checkState(!running, <span class="string">"MiniCluster is already running"</span>);</span><br><span class="line"></span><br><span class="line">LOG.info(<span class="string">"Starting Flink Mini Cluster"</span>);</span><br><span class="line">LOG.debug(<span class="string">"Using configuration &#123;&#125;"</span>, miniClusterConfiguration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Configuration configuration = miniClusterConfiguration.getConfiguration();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> useSingleRpcService = miniClusterConfiguration.getRpcServiceSharing() == RpcServiceSharing.SHARED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">initializeIOFormatClasses(configuration);</span><br><span class="line"></span><br><span class="line">LOG.info(<span class="string">"Starting Metrics Registry"</span>);</span><br><span class="line">metricRegistry = createMetricRegistry(configuration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bring up all the RPC services</span></span><br><span class="line">LOG.info(<span class="string">"Starting RPC Service(s)"</span>);</span><br><span class="line"></span><br><span class="line">AkkaRpcServiceConfiguration akkaRpcServiceConfig = AkkaRpcServiceConfiguration.fromConfiguration(configuration);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> RpcServiceFactory dispatcherResourceManagreComponentRpcServiceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (useSingleRpcService) &#123;</span><br><span class="line"><span class="comment">// we always need the 'commonRpcService' for auxiliary calls</span></span><br><span class="line">commonRpcService = createRpcService(akkaRpcServiceConfig, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="keyword">final</span> CommonRpcServiceFactory commonRpcServiceFactory = <span class="keyword">new</span> CommonRpcServiceFactory(commonRpcService);</span><br><span class="line">taskManagerRpcServiceFactory = commonRpcServiceFactory;</span><br><span class="line">dispatcherResourceManagreComponentRpcServiceFactory = commonRpcServiceFactory;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// we always need the 'commonRpcService' for auxiliary calls</span></span><br><span class="line">commonRpcService = createRpcService(akkaRpcServiceConfig, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// start a new service per component, possibly with custom bind addresses</span></span><br><span class="line"><span class="keyword">final</span> String jobManagerBindAddress = miniClusterConfiguration.getJobManagerBindAddress();</span><br><span class="line"><span class="keyword">final</span> String taskManagerBindAddress = miniClusterConfiguration.getTaskManagerBindAddress();</span><br><span class="line"></span><br><span class="line">dispatcherResourceManagreComponentRpcServiceFactory = <span class="keyword">new</span> DedicatedRpcServiceFactory(akkaRpcServiceConfig, jobManagerBindAddress);</span><br><span class="line">taskManagerRpcServiceFactory = <span class="keyword">new</span> DedicatedRpcServiceFactory(akkaRpcServiceConfig, taskManagerBindAddress);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RpcService metricQueryServiceRpcService = MetricUtils.startMetricsRpcService(</span><br><span class="line">configuration,</span><br><span class="line">commonRpcService.getAddress());</span><br><span class="line">metricRegistry.startQueryService(metricQueryServiceRpcService, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">processMetricGroup = MetricUtils.instantiateProcessMetricGroup(</span><br><span class="line">metricRegistry,</span><br><span class="line">RpcUtils.getHostname(commonRpcService),</span><br><span class="line">ConfigurationUtils.getSystemResourceMetricsProbingInterval(configuration));</span><br><span class="line"></span><br><span class="line">ioExecutor = Executors.newFixedThreadPool(</span><br><span class="line">Hardware.getNumberCPUCores(),</span><br><span class="line"><span class="keyword">new</span> ExecutorThreadFactory(<span class="string">"mini-cluster-io"</span>));</span><br><span class="line">haServices = createHighAvailabilityServices(configuration, ioExecutor);</span><br><span class="line"></span><br><span class="line">blobServer = <span class="keyword">new</span> BlobServer(configuration, haServices.createBlobStore());</span><br><span class="line">blobServer.start();</span><br><span class="line"></span><br><span class="line">heartbeatServices = HeartbeatServices.fromConfiguration(configuration);</span><br><span class="line"></span><br><span class="line">blobCacheService = <span class="keyword">new</span> BlobCacheService(</span><br><span class="line">configuration, haServices.createBlobStore(), <span class="keyword">new</span> InetSocketAddress(InetAddress.getLocalHost(), blobServer.getPort())</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 这一步创建并启动taskmanager</span></span><br><span class="line">startTaskManagers();</span><br><span class="line"></span><br><span class="line">MetricQueryServiceRetriever metricQueryServiceRetriever = <span class="keyword">new</span> RpcMetricQueryServiceRetriever(metricRegistry.getMetricQueryServiceRpcService());</span><br><span class="line"></span><br><span class="line">setupDispatcherResourceManagerComponents(configuration, dispatcherResourceManagreComponentRpcServiceFactory, metricQueryServiceRetriever);</span><br><span class="line"></span><br><span class="line">resourceManagerLeaderRetriever = haServices.getResourceManagerLeaderRetriever();</span><br><span class="line">dispatcherLeaderRetriever = haServices.getDispatcherLeaderRetriever();</span><br><span class="line">clusterRestEndpointLeaderRetrievalService = haServices.getClusterRestEndpointLeaderRetriever();</span><br><span class="line"></span><br><span class="line">dispatcherGatewayRetriever = <span class="keyword">new</span> RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">commonRpcService,</span><br><span class="line">DispatcherGateway<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">DispatcherId::fromUuid,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line">Time.milliseconds(<span class="number">20L</span>));</span><br><span class="line">resourceManagerGatewayRetriever = <span class="keyword">new</span> RpcGatewayRetriever&lt;&gt;(</span><br><span class="line">commonRpcService,</span><br><span class="line">ResourceManagerGateway<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">ResourceManagerId::fromUuid,</span><br><span class="line"><span class="number">20</span>,</span><br><span class="line">Time.milliseconds(<span class="number">20L</span>));</span><br><span class="line">webMonitorLeaderRetriever = <span class="keyword">new</span> LeaderRetriever();</span><br><span class="line"></span><br><span class="line">resourceManagerLeaderRetriever.start(resourceManagerGatewayRetriever);</span><br><span class="line">dispatcherLeaderRetriever.start(dispatcherGatewayRetriever);</span><br><span class="line">clusterRestEndpointLeaderRetrievalService.start(webMonitorLeaderRetriever);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="comment">// cleanup everything</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ee) &#123;</span><br><span class="line">e.addSuppressed(ee);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new termination future</span></span><br><span class="line">terminationFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// now officially mark this as running</span></span><br><span class="line">running = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">LOG.info(<span class="string">"Flink Mini Cluster started successfully"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成taskmanager的创建并启动之后，接下来会进行作业的提交<code>submitJob</code>，该过程会创建对应的jobmanager，如下minicluster中提交作业的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> CompletableFuture&lt;JobSubmissionResult&gt; <span class="title">submitJob</span><span class="params">(JobGraph jobGraph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;DispatcherGateway&gt; dispatcherGatewayFuture = getDispatcherGatewayFuture();</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;InetSocketAddress&gt; blobServerAddressFuture = createBlobServerAddress(dispatcherGatewayFuture);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Void&gt; jarUploadFuture = uploadAndSetJobFiles(blobServerAddressFuture, jobGraph);</span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; acknowledgeCompletableFuture = jarUploadFuture</span><br><span class="line">.thenCombine(</span><br><span class="line"><span class="comment">// 提交作业</span></span><br><span class="line">dispatcherGatewayFuture,</span><br><span class="line">(Void ack, DispatcherGateway dispatcherGateway) -&gt; dispatcherGateway.submitJob(jobGraph, rpcTimeout))</span><br><span class="line">.thenCompose(Function.identity());</span><br><span class="line"><span class="keyword">return</span> acknowledgeCompletableFuture.thenApply(</span><br><span class="line">(Acknowledge ignored) -&gt; <span class="keyword">new</span> JobSubmissionResult(jobGraph.getJobID()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述在minicluster中提交的作业会经由dispatcher#submitJob进行提交,最终进入该方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> CompletableFuture&lt;Acknowledge&gt; <span class="title">internalSubmitJob</span><span class="params">(JobGraph jobGraph)</span> </span>&#123;</span><br><span class="line">log.info(<span class="string">"Submitting job &#123;&#125; (&#123;&#125;)."</span>, jobGraph.getJobID(), jobGraph.getName());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持久化作业并运行</span></span><br><span class="line"><span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; persistAndRunFuture = waitForTerminatingJobManager(jobGraph.getJobID(), jobGraph, <span class="keyword">this</span>::persistAndRunJob)</span><br><span class="line">.thenApply(ignored -&gt; Acknowledge.get());</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> persistAndRunFuture.handleAsync((acknowledge, throwable) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">cleanUpJobData(jobGraph.getJobID(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Throwable strippedThrowable = ExceptionUtils.stripCompletionException(throwable);</span><br><span class="line">log.error(<span class="string">"Failed to submit job &#123;&#125;."</span>, jobGraph.getJobID(), strippedThrowable);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(</span><br><span class="line"><span class="keyword">new</span> JobSubmissionException(jobGraph.getJobID(), <span class="string">"Failed to submit job."</span>, strippedThrowable));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> acknowledge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, getRpcService().getExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述过程中通过<code>persistAndRunJob</code>会将作业持久化并运行，持久化的方式可以是写到zk的节点中，需要看具体实现，上述方法最终会进入dispatcher#runJob的方法里面，接下来会进入dispatcher#createJobManagerRunner的方法里面，上述方法最终会进入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> CompletableFuture&lt;JobManagerRunner&gt; <span class="title">createJobManagerRunner</span><span class="params">(JobGraph jobGraph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> RpcService rpcService = getRpcService();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CompletableFuture.supplyAsync(</span><br><span class="line">CheckedSupplier.unchecked(() -&gt;</span><br><span class="line">jobManagerRunnerFactory.createJobManagerRunner(</span><br><span class="line">jobGraph,</span><br><span class="line">configuration,</span><br><span class="line">rpcService,</span><br><span class="line">highAvailabilityServices,</span><br><span class="line">heartbeatServices,</span><br><span class="line">jobManagerSharedServices,</span><br><span class="line"><span class="keyword">new</span> DefaultJobManagerJobMetricGroupFactory(jobManagerMetricGroup),</span><br><span class="line">fatalErrorHandler)),</span><br><span class="line">rpcService.getExecutor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也即会调用<code>jobManagerRunnerFactory#createJobManagerRunner</code>的方法，上面会创建<code>JobManagerRunnerImpl</code>对象，该对象的创建最终会进入如下方法调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.jobMasterService = jobMasterFactory.createJobMasterService(jobGraph, <span class="keyword">this</span>, userCodeLoader);</span><br></pre></td></tr></table></figure><p>最终会完成jobmaster的创建，这里的jobmaster就是jobmanager（该类的命名不知道为啥不是jobmanager而是jobmaster），接下来在jobmanger创建完成后，在<code>dispatcher#runjob</code>中会通过<code>startJobManagerRunner</code>启动jobmanager执行作业 <code>startJobManagerRunner</code>，至此作业的提交就完成了。不过不确定这种作业提交流程在yarn session或者per-job的模式下就会有所不同了，这种不同体现在dispatcher提交过去的作业并不会直接创建jobmaster或者taskmanager，而是会首先创建jobmaster，经由jobmaster向resourcemanager申请所需要的资源，之后resourcemanager会创建taskmanager并同jobmaster取得心跳联系，接下来作业就可以正常的提交并执行了。yarn session和per-job的模式区别点在于yarn session对于提交过来的作业资源不做隔离，而且有执行失败的风险，per-job则解除了这种限制，不同的作业其资源并不贡献，因此作业之间不存在资源竞争。</p></li></ul><p>可以看到上述作业提交的过程中几个重要角色：client、dispatcher、jobmanager、taskmanager。</p><h2 id="部署模式"><a href="#部署模式" class="headerlink" title="部署模式"></a>部署模式</h2><p>flink的部署模式存在local、standlone、yarn这几种模式，其中flink on yarn的模式又可以per-job和yarn session模式，我们来分析一下这几种模式的区别：</p><ul><li>local： 我们直接解压flink的压缩包，并通过start-cluster脚本就可以直接启动这种模式，不过这种模式的flink集群在提交作业之后jobmanager和taskmanager在同一个节点上，<strong>不确定这种模式是否会有jobmanager直接启动，如果没有，我们的作业提交是提交到什么进程呢？</strong></li><li>standlone：对于这种模式，是采用比较经典的主从模式，即存在master、slave节点，通常是一主多从的模式，这种模式也有很大的局限性，无法做到高可用，在生产环境中多半也不会使用</li><li>yarn：这种模式依赖于hadoop集群，并且通常我们还需要用到zookeeper集群，hadoop集群提供yarn的环境，zookeeper则用于保障flink集群的HA，基于yarn的模式也分了两种情况<ul><li>flink on yarn：这种方式在client提交了作业之后会生成对应的jobmanager，jobmanager会从yarn的resourcemanager申请对应的资源，该过程会创建taskmanager，这种情况下不同的作业彼此之间的资源是隔离的</li><li>yarn session：这种方式要求先创建一个yarn的session，在创建session的时候我们会指定该session的资源，接下来我们在提交作业的时候会指定作业使用的yarn session，如果我们提交的作业该session无法满足，那么该作业的运行将会进入阻塞的状态，直到有足够的资源释放出来，该模式存在的问题就是作业之间的资源是不隔离的，如果yarn session因为某种原因异常退出，那么该session托管的所有作业都将会被kill掉。</li></ul></li></ul><p>上述过程中依然存在理解障碍的地方在于集群运行的常驻进程究竟是什么？？？？？？</p><h2 id="编程模型"><a href="#编程模型" class="headerlink" title="编程模型"></a>编程模型</h2><p>通过上面作业提交流程的分析，我们对flink有了一个感性的认识后，我们接下来介绍一下flink的编程模型：<img src="//southrivers.github.io/2022/08/20/flink-解析/programmodal.png" alt>我们一般使用的是DataSet、DataStream级别的接口进行数据的处理，对于简单的应用场景来说我们也可以使用table或者sql API来进行编程，这种编程模式是采用了apache calcite来进行sql的解析，不过对于程序的优化就显得无能为力了。</p><p>算子是一个一个的运算，可以将其看作一个类，任务是算子在运行时候的体现，因此当我们设定了算子的并行度的时候，其会在任务执行的时候体现，比如我们设定某个算子的并行度为8，那么该算子对应的任务在执行的时候就会有8个。</p><h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p>keyedStream、nonkeyedStream</p><h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><h2 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h2><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><h3 id="exactly-once"><a href="#exactly-once" class="headerlink" title="exactly-once"></a>exactly-once</h3><h2 id="反压"><a href="#反压" class="headerlink" title="反压"></a>反压</h2><p>窗口、时间</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>arm 汇编语言程序设计</title>
      <link href="/2022/08/01/arm-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/08/01/arm-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="汇编语言概览"><a href="#汇编语言概览" class="headerlink" title="汇编语言概览"></a>汇编语言概览</h1><p>汇编语言是最接近机器语言的编程语言，如下图所示，汇编语言介于机器语言和高层语言之间：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/armartucture.png" alt></p><h2 id="内存模型：arm架构的cpu内存结构如下图所示："><a href="#内存模型：arm架构的cpu内存结构如下图所示：" class="headerlink" title="内存模型：arm架构的cpu内存结构如下图所示："></a>内存模型：arm架构的cpu内存结构如下图所示：</h2><p><img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/cpu.png" alt></p><ul><li>寄存器：针对不同类型的cpu最重要的大概就是寄存器了，寄存器是最靠近cpu的存储，其在速度上也最接近cpu，如上图我们可以看到针对该种类型的cpu一共有17个寄存器：<ul><li>r0 ~ r6, r8 ~ r12 用于存放cpu需要操作的数据，这些数据可以是输入数据、输出数据、函数调用的时候栈中的数据</li><li>r7是一个特殊的寄存器，用于存放中断信号，中断信号的类型有两种：内中断、外中断，内中断是用户程序在运行过程中因为异常（调用一些需要超级权限才可以执行的指令、错误程序）或者用户程序主动的通过系统调用陷入内核态，外中断是基于时钟定时出发的，在一个时钟周期内cpu专心的处理程序，一个周期过了之后检查一下r7确认一下是否有中断产生，如果没有中断就会继续执行用户程序，如果有中断，则cpu会根据中断信号查找中断向量表，从而切换程序的执行。</li><li>sp叫做stack pointer，是指向堆栈的指针，堆栈在函数调用或者比较复杂的数据结构如list的时候会用到，具体见图:<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/mem.png" alt></li><li>lr叫做link register，这个通常和函数是结合在一起的，lr存放的是函数的地址，当函数执行结束之后，需要继续在lr标记的位置继续往下执行</li><li>pc叫做program counter，也就是程序计数器，用来指向下一条将要执行的代码</li><li>cpsr用来存放运算溢出的信息，比如两个数相减，有可能大于0、也有可能小于0，对于小于0 的数，其在寄存器中表征的数也有可能是一个很大的数，因此需要表征其符号，另外对于两个求和运算的整数，其可能会产生进位，这里的进位也需要一个单独的寄存器来存储，这里就是cpsr</li><li>spsr 用来保存cpsr的状态信息，当有异常的时候可以用来恢复cpsr，不过在实际应用的过程中用的并不多</li></ul></li></ul><h1 id="汇编语言语法"><a href="#汇编语言语法" class="headerlink" title="汇编语言语法"></a>汇编语言语法</h1><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>接下来通过一个示例来快速的演示一下汇编程序的hello world：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #30</span><br><span class="line"></span><br><span class="line">mov r7, #1</span><br><span class="line">swi 0</span><br></pre></td></tr></table></figure><p>上述代码中.global相当于是将当前文件的代码给export出去了，同时也指示了当前代码开始的位置即 _start，也就是传统编程里面的main函数，对于一般的编程来说，这里的label更多的像是一个函数名称，并且对于一个函数来说比较重要的是要return（void的除外，不过也可以return），这里的return在汇编语言层面上要通过中断产生，也就是这里的swi 0（soft ware interrupt 软中断或者内中断），前面我们知道系统调用的时候会检测r7寄存器的值，由于我们在r7中设置了1，通过查找中断向量表我们知道这是要推出程序的执行，并且是正常退出。 <strong>中断向量表是一个枚举的类型，对于不同架构的cpu来说其枚举值必定不同</strong></p><h2 id="数据寻址（address-data）"><a href="#数据寻址（address-data）" class="headerlink" title="数据寻址（address data）"></a>数据寻址（address data）</h2><ul><li>立即寻址：立即寻址这种方式是向寄存器中移入一个常量值如：mov r0, #222</li><li>直接寻址：直接寻址常见的有寄存器之间的数据传递，或者从stack中移入数据到寄存器，如：mov r0, r1、ldr r0,=list，这里的=list是获取list的地址</li><li>间接寻址：在直接寻址中我们在r0中获取到了list的地址，接下来如果我们要获取list地址对应的值就需要ldr r1, [r0]这种方式来讲list的头元素加载到r1中。<ul><li>前加：当我们需要移动list指针的位置的时候，可以在获取下一个数据之前移动指针，这样获取到的值就是指针指向的下一个元素：ldr r2, [r0, #4]</li><li>后加：后加的意思是我们会先获得数据，然后再进行指针的移位操作，这样会导致获取不到最后一个元素:ldr r2, [r0, #4]!、ldr r2, [r0]，#4</li></ul></li></ul><p>下面通过一段代码来进行演示一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">ldr r0, =list</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">list:</span><br><span class="line">.word 1,2,3,4,5</span><br></pre></td></tr></table></figure><p>上面我们定义了.data段，这代表的是汇编语言程序的数据段，主要用来存放大量的数据，.data在汇编中是关键词，就像.global一样，可以很明显的看到其和label最大的区别就是后面没有“：”，接下来在data段中我们定一个变量list，变量的名称叫做list，然后我们定义了list的类型<code>.word</code>，值得注意的是汇编语言中的数据类型，.word表征的可以是整数也可以是浮点数，同样的数据类型也还有halfword、doubleworld、byte、bit等。上面的代码如下，我们可以明显的看到global和data的分界线：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/acode.png" alt>在程序的执行过程中我们可以看到寄存器的状态如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/adebug.png" alt>我们可以看到寄存器中的值，并根据寄存器中的值查看stack对应的内存区域的数据，如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/amem.png" alt>上面我们就见识到了寄存器、栈内存的状态，此时如果我们想要获得对应的值就需要使用间接寻址获得</p><h2 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h2><p>数学运算中包含+ - * /，除法稍微有点复杂，暂不研究，对于 + - *，都需要一个目标寄存器，两个源寄存器，在运算的过程中可能会产生溢出、负值等状态，这种状态就需要一个额外的寄存器CPSR进行存储，不过CPSR状态的操作需要特殊的指令，之所以使用特殊的指令是因为接近于机器的编程对性能的影响很大，能少操作一个寄存器就少操作一个，避免额外的开销。另外CPSR的状态有NZCV，分别代表了N（negtive：负数）、Z（zero 0标记位）、C（carry 进位标记位），V（overflow 溢出）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #5</span><br><span class="line">mov r1, #7</span><br><span class="line">mov r2, #0xffffffff</span><br><span class="line">// 不会设置cpsr寄存器</span><br><span class="line">sub r3, r0, r1</span><br><span class="line">// 设置cpsr寄存器，s可以理解为set即设置</span><br><span class="line">subs r3, r0, r1</span><br><span class="line">// 不会设置cpsr寄存器</span><br><span class="line">add r4, r0, r2</span><br><span class="line">// ，s可以理解为set即设置</span><br><span class="line">adds r4, r0,r2</span><br></pre></td></tr></table></figure><p>上述寄存器状态图如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/memstus.png" alt></p><p>上面我们看到了数学运算的基本操作，如果我们要对cpsr寄存器进行操作的话，是需要使用特殊的指令的，比如我们想要对进位操作进行计算：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #5</span><br><span class="line">mov r1, #7</span><br><span class="line">mov r2, #0xffffffff</span><br><span class="line">adds r3, r0,r2</span><br><span class="line">adc r4, r0,r1</span><br></pre></td></tr></table></figure><p>上面最终计算结果如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/adcs.png" alt>可以很直观的看到7+5的结果应该是12，对应的16进制就是c，但最终结果r4中显示的是d即13，说明adc讲cpsr中的结果计入了最终运算的结果。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>常用的逻辑运算包含了AND、OR、异或等，比较简单，就不再详细说明了</p><h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><p>计算机是二进制的，常见的移位操作相较于十进制来说会比较好理解，对于十进制来说左移操作会在原数的基础上乘以10，右移会在原有数据的基础上除以10。同理对于二进制来说右移是除以2，左移是乘以2。对于其他进制来说亦是如此：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #15</span><br><span class="line">// 在原来寄存器的基础上进行移位操作，改变的是原有寄存器的值</span><br><span class="line">lsl r0, #1</span><br><span class="line">lsr r0, #1</span><br><span class="line">mov r1, #15</span><br><span class="line">// 首先将r1移动到r2中，然后在r2的基础上进行移位操作</span><br><span class="line">mov r2, r1, lsl #1</span><br><span class="line">ror r1, #1</span><br></pre></td></tr></table></figure><p>对应的寄存器状态如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/logic.png" alt>对于上面的ror的操作是循环右移，其最低位在经过右移之后会出现在最高位上，通常这种操作用在对数据取hash的操作上，而且，并没有rol的操作，因为对于32位的系统来说，ror n次相当于rol 32-n次</p><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><p>常见的条件判断指令是cmp，其具体的操作是接受两个参数，然后相减，并将操作的状态信息保存在cpsr中，通过获取cpsr的状态就可以知道最终的结果信息，并且在cmp操作之后通常跟着分支操作，常见的分支有bgt、blt、beq、bne等，其中的b代表的是branch，还有一个特殊的指令bal，代表了无论结果如何都会执行的指令，其中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #1</span><br><span class="line">mov r1, #2</span><br><span class="line">cmp r0, r1</span><br><span class="line">bgt greater</span><br><span class="line">// bal always</span><br><span class="line">mov r3, #1</span><br><span class="line"></span><br><span class="line">greater:</span><br><span class="line">mov r2, #3</span><br><span class="line">always:</span><br><span class="line">mov r2, #4</span><br></pre></td></tr></table></figure><p>需要牢记的是，cmp操作之后，会将对应结果存放到cpsr中，因此，接下来的各种跳转操作都会给予最近一次的cpsr中的结果进行判断，如果满足bxx则最终就会陷入分支中去执行，并且最后并不会跳出分支，如上述代码，如果r0大于r1就会跳转到greater分支，并且后续的mov r3的操作也不会再执行了（没有一个返回操作，调用greater的label的操作不是函数调用，不会在函数执行完成之后返回到函数的调用处）。如果最终比较的结果没有任何一个分支满足的话，就会顺序的往下执行，并且如果在后续的执行过程中没有遇到终止的条件的话，会一直执行下面所有的分支，此时并不再是label的调用，就上述代码而言，因为cmp的操作并不满足bgt的结果，因此其首先会跳过bgt的代码，然后顺序执行mov r3、greater、always的操作。注意bal分支只要存在永远是放到代码执行完之后执行。</p><p>除了上述BLT等之外，我们还可以使用MOVLT、ADDLT等指令，这些指令是在LT发生的时候执行特定的操作，类似的还有GT等和原有指令进行组合。这是一种简化代码的方式。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>在高等计算机编程语言中，我们通常使用的循环类型有for、do -while、while-do类型。下面以do-while类型的循环为例进行相应的求和操作，这里我们预先初始化了list的终止条件，也就是endlist，不过在真正的高等语言中，通常是使用特殊的符号作为终止的标记（毕竟我们无法预知内存中的终止数据究竟是什么），对于下面的循环相较于高等语言来说也是类似的，初始化，进入循环，判断是否终止。这里需要注意的是对于汇编语言中的常量通常是使用类似于宏的定义预先定义好，在家在常量到寄存器的时候要使用ldr的指令，不可以使用mov指令，并且访问数据的时候要用到<code>=</code> ，不可以直接将如数据移入寄存器，具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 循环求list的和</span><br><span class="line">.global _start</span><br><span class="line">// 初始化list的结束条件</span><br><span class="line">.equ endlist, 0xaaaaaaaa</span><br><span class="line">_start:</span><br><span class="line">// 初始化变量，类似于高级编程</span><br><span class="line">ldr r0, =list</span><br><span class="line">// arm处理器加载常量必须要使用这种方式，这种方式并不是加载其地址，就是把他的值加载到制定的寄存器</span><br><span class="line">ldr r3, =endlist</span><br><span class="line">ldr r1, [r0]</span><br><span class="line">add r2, r2, r1</span><br><span class="line">// 这种方式是do - while的循环方式，因为在这之前并没有cmp的操作</span><br><span class="line">loop:</span><br><span class="line">ldr r1, [r0,#4]!</span><br><span class="line">// 这里是比较寄存器中的值是否相等，并不是地址比较</span><br><span class="line">cmp r1, r3</span><br><span class="line">beq exit</span><br><span class="line">add r2, r2, r1</span><br><span class="line">bal loop</span><br><span class="line">exit:</span><br><span class="line">mov r3, r2</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">list:</span><br><span class="line">.word 1,2,3,4,5,6,7,8,9,10</span><br></pre></td></tr></table></figure><p>上述代码最终的执行结果如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/loopreg.png" alt>其在内存中的状态图如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/loopmem.png" alt></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数区别于label，label执行完之后不会返回到调用label的地方继续向下执行，函数则会。具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line"></span><br><span class="line">mov r0, #1</span><br><span class="line">mov r1, #2</span><br><span class="line">// 使用这种方式会让程序跳转到label处，这种方式并不是函数，也就是在调用了label的代码后如果后续还有代码的话并不会再执行</span><br><span class="line">//bal addr2</span><br><span class="line">// branch link 这个指令将会存储label调用的下一个地址到lr寄存器中</span><br><span class="line">bl addr2</span><br><span class="line">mov r3, #3</span><br><span class="line"></span><br><span class="line">addr2:</span><br><span class="line">add r2, #1</span><br><span class="line">// branch exit 也就是程序退出的时候将pc指针指向lr寄存器的地址，继续执行函数调用完后的代码</span><br><span class="line">bx lr</span><br></pre></td></tr></table></figure><p>上述代码在执行的过程中最重要的变化就是lr寄存器的变化：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/blr.png" alt>在label调用执行到bx lr之后，程序会将lr的地址传递给pc进行函数调用之后的执行。</p><p>上述函数调用是比较简单的，我们在真正的使用过程中可能还涉及到函数调用前一些状态信息的保存，这里状态主要是指寄存器，因为cpu的寄存器数量有限，我们在函数调用的过程中重复使用外层函数的寄存器，但是这样带来的结果就是寄存器被覆写了，因此我们需要在调用前将寄存器中的数据保留，然后调用函数，在执行完毕之后再恢复状态，这里用到了栈，涉及到对应的寄存器就是sp，也即是stack pointer，演示代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #1</span><br><span class="line">mov r1, #2</span><br><span class="line">push &#123;r0, r1&#125;</span><br><span class="line">bl get_value</span><br><span class="line">pop &#123;r0, r1&#125;</span><br><span class="line">b exit</span><br><span class="line"></span><br><span class="line">get_value:</span><br><span class="line">mov r0, #2</span><br><span class="line">mov r1, #3</span><br><span class="line">add r2, r0, r1</span><br><span class="line">bx lr</span><br><span class="line"></span><br><span class="line">exit:</span><br></pre></td></tr></table></figure><p>上述代码对应的寄存器及stack状态示意图如下：<img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/push.png" alt>并且如果我们希望得到函数返回值的话，可以进一步的操作是将最终的计算结果push到stack中，并在函数返回的时候pop即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">mov r0, #1</span><br><span class="line">mov r1, #2</span><br><span class="line">push &#123;r0, r1&#125;</span><br><span class="line">bl get_value</span><br><span class="line">pop &#123;r2,r0, r1&#125;</span><br><span class="line">b exit</span><br><span class="line"></span><br><span class="line">get_value:</span><br><span class="line">mov r0, #2</span><br><span class="line">mov r1, #3</span><br><span class="line">add r2, r0, r1</span><br><span class="line">push &#123;r2&#125;</span><br><span class="line">bx lr</span><br><span class="line"></span><br><span class="line">exit:</span><br></pre></td></tr></table></figure><h2 id="硬件交互"><a href="#硬件交互" class="headerlink" title="硬件交互"></a>硬件交互</h2><p>在线调试环境的右边我们可以看到和arm交互的硬件，对于交互的硬件只有两种类型，输入、输出，接下来我们将选择switch作为输入，led作为输出（可以看到在线仿真的平台有很多可以交互的外设，不过最简单的就是开关和led了，因此我们也以此为例，其他类型的设备需要依赖于具体设备的参考文档了）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.equ swth, 0xff200040</span><br><span class="line">.equ led, 0xff200000</span><br><span class="line"></span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">// 加载开关位置信息</span><br><span class="line">ldr r0, =swth</span><br><span class="line">// 将开关对应内存信息加载到r1</span><br><span class="line">ldr r1, [r0]</span><br><span class="line">// 加载led的位置信息到r0中</span><br><span class="line">ldr r0, =led</span><br><span class="line">// 将r1中的数据写入到r0所指向的地址内存</span><br><span class="line">str r1, [r0]</span><br></pre></td></tr></table></figure><p><img src="//southrivers.github.io/2022/08/01/arm-汇编语言程序设计/led.png" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>cpu 的核心就是一堆寄存器 加上MCU（计算控制单元，说的直白点就是逻辑门电路，可以针对寄存器进行计算），计算机的核心就是cpu、内存、输入、输出，其中内存用来缓存cpu要用到的数据。</p><p>参考网站：</p><p><a href="https://www.youtube.com/watch?v=gfmRrPjnEw4" target="_blank" rel="noopener">youtube</a></p><p><a href="https://cpulator.01xz.net/" target="_blank" rel="noopener">在线code网址</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redux模型理解</title>
      <link href="/2022/06/11/redux%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/"/>
      <url>/2022/06/11/redux%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在看react的前端框架，react默认的state管理器需要明确的理解组件的层级关系，组件之间就像一颗多叉树一样，不同的子组件在状态有因果关系的时候，需要找到其最近的父节点进行状态的传递，对于小型的应用来说使用react原生的state管理是没有任何问题的，也不会增加状态管理的复杂度，但是对于大型应用来说，这种状态之间的交互会显得异常繁琐，因此衍生出了redux，一款专门用于状态管理的工具，redux采用的是发布订阅的模型，感觉非常像是前端的消息队列，有消息的生产者和消息的消费者，二者通过对store中特定对象（可以认为是topic）的操作完成生产和消费的解偶</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>kafka 源码走读</title>
      <link href="/2021/12/12/kafka/"/>
      <url>/2021/12/12/kafka/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>kafka是当前用的比较广泛的消息中间件，基于其高性能、高吞吐的特性，在通常的服务总线等均有响应的应用场景，由于kafka服务端的源代码是基于scala开发的，因此前期准备足够多的scala知识后，逐步深入的去理解这一块的实现，并记录一下一边后续复习。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a>请求处理流程</h2><p><img src="/Users/shuaizi/workspace/github/southrivers.github.io/source/_posts/kafka/image-20211212165434878.png" alt="image-20211212165434878"></p><p>上述图片中完整的描述了kafka请求处理的全流程，具体来说可以分为以下几个步骤：</p><ol><li>客户端或者broker发送请求另外一个broker端，此时对象需要序列化成bytebuffer</li><li>broker端开启监听端口，并装配一个acceptor用于监听客户端请求的到来<ol><li>需要注意针对同一个端口，可以配置control plane、data plane级别的acceptor</li><li>同一个broker可以开启多个端口来分别针对client、broker端的请求进行监听，并且不同的端口所采用的协议是并不相同的</li></ol></li><li>acceptor监听的是OP_ACCEPT事件，该事件代表了有新的客户端重新建立了一个链接</li><li>acceptor在接受到该链接的时候会传递给processor，由processor创建一个和客户端链接的connection，同时该processor会创建一个responseQueue对象以及监听connection上的OP_READ事件，在接受到该事件后，读取数据并反序列化生成一个request</li><li>acceptor将接受到的request请求发送到requestChannel中</li><li>KafkaRequestHandPool对象创建KafkaRequestHandler线程用于处理requestChannel中的request对象，不过需要注意的是这里的request其实是由KafkaApis中的handle方法处理的</li><li>KafkaApis在处理完request请求之后，将response写入processor中的responseQueue队列中，最后由processor将response返回给客户端，并执行对应的回调函数</li></ol><p><strong>整个流程至此结束，除上述流程之外，还需要注意的是，purgetory请求延迟处理模块在上述的流程中哪一步执行的？？</strong></p><h2 id="controller处理流程"><a href="#controller处理流程" class="headerlink" title="controller处理流程"></a>controller处理流程</h2><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scala import重命名</title>
      <link href="/2021/12/09/scala-import%E9%87%8D%E5%91%BD%E5%90%8D/"/>
      <url>/2021/12/09/scala-import%E9%87%8D%E5%91%BD%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p><a href="https://alvinalexander.com/scala/how-to-rename-members-import-scala-classes-methods-functions/" target="_blank" rel="noopener">https://alvinalexander.com/scala/how-to-rename-members-import-scala-classes-methods-functions/</a></p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><ul><li>第一</li><li>第二</li></ul><ol><li>dfsdfs</li><li>sdfdsfs</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scala 下划线的作用</title>
      <link href="/2021/12/09/scala-%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2021/12/09/scala-%E4%B8%8B%E5%88%92%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scala ClassTag剖析</title>
      <link href="/2021/12/06/scala-ClassTag%E5%89%96%E6%9E%90/"/>
      <url>/2021/12/06/scala-ClassTag%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在学习kafka的源代码，按照建议从KafkaApi进行入手，对于业务流程的话基本是清楚的，不过在阅读源码的时候发现有些语法实在是晦涩难懂，因此在网上多方查证并记录，以便后续可以快速的拾起来。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>废话不多说直接看代码：</p><p><code>val produceRequest = request.body[ProduceRequest]</code>该过程会调用如下方法：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">body</span></span>[<span class="type">T</span> &lt;: <span class="type">AbstractRequest</span>](<span class="keyword">implicit</span> classTag: <span class="type">ClassTag</span>[<span class="type">T</span>], nn: <span class="type">NotNothing</span>[<span class="type">T</span>]): <span class="type">T</span> = &#123;</span><br><span class="line">  bodyAndSize.request <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> r: <span class="type">T</span> =&gt; r</span><br><span class="line">    <span class="keyword">case</span> r =&gt;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">ClassCastException</span>(<span class="string">s"Expected request with type <span class="subst">$&#123;classTag.runtimeClass&#125;</span>, but found <span class="subst">$&#123;r.getClass&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们从方法入手，上述方法的定义包含了两个参数，不过在调用的时候并没有将这两个参数传入，这是因为参数列表是隐式参数的一种写法，这种写法会将implicit后面的参数都作为隐式变量，既然作为隐式变量，相应的就需要有定义并导入这些隐式参数的地方，对于classTag是由编译器传入的隐式变量，而nn则是通过NotNothing的伴生对象传入的。</p><p>解释完这个方法的调用，我们继续看一下这个方法本身，可以看到这是一个泛型方法，并且泛型参数指定了类型的上界，不过在jvm的运行态中这种泛型方法会被擦除，因此如果需要保存运行时的类型信息就需要特定的容器进行保存，这里的ClassTag[T]的作用就在于保存参数类型，对于这种写法还有一种上下文界定的写法即：<strong>[T : ClassTag]</strong>，其表示使用ClassTag接收T类型的参数，这样我们就可以在运行的时候获取到对应的类型，不过你可能会想怎么获取类型呢？这就需要implicitly[ClassTag]来查看对应的隐式变量了（需要注意这里并不是implicit，两者是不一样的，implicit是关键字，implicitly是函数，其接收一个类型参数，并返回当前域内的该类型的隐式的值，可以发散一下，如果域内有两个类型相同的隐式的值则必定会产生错误，具体是什么错误可以自己试一下），我们举个例子如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.reflect.<span class="type">ClassTag</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ct</span></span>[<span class="type">T</span>](t: <span class="type">T</span>)(<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">T</span>]) = &#123;</span><br><span class="line">  print(ct)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ct(<span class="type">List</span>(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ct1</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](t: <span class="type">T</span>) = &#123;</span><br><span class="line">  <span class="comment">// 获取隐式变量</span></span><br><span class="line">  <span class="keyword">val</span> ct = implicitly[<span class="type">ClassTag</span>[<span class="type">T</span>]]</span><br><span class="line">  print(ct)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ct1(<span class="type">List</span>(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>对应结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import scala.reflect.ClassTag</span><br><span class="line"></span><br><span class="line">ct: [T](t: T)(implicit ct: scala.reflect.ClassTag[T])Unit</span><br><span class="line"></span><br><span class="line">scala.collection.immutable.List</span><br><span class="line"></span><br><span class="line">ct1: [T](t: T)(implicit evidence$1: scala.reflect.ClassTag[T])Unit</span><br><span class="line"></span><br><span class="line">scala.collection.immutable.List</span><br></pre></td></tr></table></figure><p>另外我们可以看一下上下文界定这种写法直接在编译器上显示的结果：</p><p>![](/Users/shuaizi/workspace/github/southrivers.github.io/source/_posts/scala-ClassTag剖析/屏幕快照 2021-12-07 01.04.14.png)</p><p>可以看到编译器会自动的将上述函数自动的转化成带有隐式变量参数的函数。另外有需要强调的是，参数是有上界的，这里对应的上界是AbstractRequest，这样我们是否还可以使用上下文界定呢？答案是可以的，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sealed trait TT</span><br><span class="line"></span><br><span class="line">case class XTT() extends TT</span><br><span class="line"></span><br><span class="line">case class YTT() extends TT</span><br><span class="line"></span><br><span class="line">def ct2[T&lt;: TT : ClassTag](t: T) = &#123;</span><br><span class="line">  // 获取隐式变量</span><br><span class="line">  val ct = implicitly[ClassTag[T]]</span><br><span class="line">  print(ct)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ct2(XTT())</span><br></pre></td></tr></table></figure><p>最终结果输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">defined trait TT</span><br><span class="line"></span><br><span class="line">defined class XTT</span><br><span class="line"></span><br><span class="line">defined class YTT</span><br><span class="line"></span><br><span class="line">ct2: [T &lt;: TT](t: T)(implicit evidence$1: scala.reflect.ClassTag[T])Unit</span><br><span class="line"></span><br><span class="line">$line7.$read$$iw$$iw$XTT</span><br></pre></td></tr></table></figure><p>更一般的，上下文界定的右边的类型不止可以是ClassTag，还可以是任意的泛型类，其代表的含义是传入一个隐式的该类型的参数，具体可以参考<strong>scala那些事</strong>中的Ordering。</p><p>等等，好像还有一点遗漏了，函数的参数有两个，一个是ClassTag，一个是NotNoting，第二个参数起到什么作用？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import scala.annotation.implicitNotFound</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">  * This is a trick to prevent the compiler from inferring the `Nothing` type in cases where it would be a bug to do</span><br><span class="line">  * so. An example is the following method:</span><br><span class="line">  *</span><br><span class="line">  *</span><br></pre></td></tr></table></figure><ul><li>def body[T &lt;: AbstractRequest](implicit classTag: ClassTag[T], nn: NotNothing[T]): T</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  *</span><br><span class="line">  * If we remove the `nn` parameter and we invoke it without any type parameters (e.g. `request.body`), `Nothing` would</span><br><span class="line">  * be inferred, which is not desirable. As defined above, we get a helpful compiler error asking the user to provide</span><br><span class="line">  * the type parameter explicitly.</span><br><span class="line">  */</span><br><span class="line">@implicitNotFound(&quot;Unable to infer type parameter, please provide it explicitly.&quot;)</span><br><span class="line">trait NotNothing[T]</span><br><span class="line"></span><br><span class="line">object NotNothing &#123;</span><br><span class="line">  private val evidence: NotNothing[Any] = new Object with NotNothing[Any]</span><br><span class="line"></span><br><span class="line">  implicit def notNothingEvidence[T](implicit n: T =:= T): NotNothing[T] = evidence.asInstanceOf[NotNothing[T]]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>基本可以预测其用途也是用于上下文界定的，只是在调用方法的时候如果不传递类型参数的话，我们需要显示的表示出来，说实话，我暂时还没有理解这句话的意思，后续再慢慢搞吧</p><p>TODO</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; def ct2[T&lt;: TT : ClassTag : Ordering](t: T) = &#123;</span><br><span class="line">     |   // 获取隐式变量</span><br><span class="line">     |   val ct = implicitly[ClassTag[T]]</span><br><span class="line">     |   print(ct)</span><br><span class="line">     | &#125;</span><br><span class="line">ct2: [T &lt;: TT](t: T)(implicit evidence$1: scala.reflect.ClassTag[T], implicit evidence$2: Ordering[T])Unit</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>scala类型那些事</title>
      <link href="/2021/10/28/scala%E7%B1%BB%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2021/10/28/scala%E7%B1%BB%E5%9E%8B%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在effective java这本书中有对java的类型系统进行比较详细的介绍，总结起来的话就是一句话PECS规则。不过在scala中类型发挥着更强大的作用。</p><h1 id="scala类型系统"><a href="#scala类型系统" class="headerlink" title="scala类型系统"></a>scala类型系统</h1><h2 id="ClassTag、TypeTag与类型擦除"><a href="#ClassTag、TypeTag与类型擦除" class="headerlink" title="ClassTag、TypeTag与类型擦除"></a>ClassTag、TypeTag与类型擦除</h2><p>type erasure的中文意思是类型擦除，具体的意思是说，Java在编译Java代码时，会将类型参数的类型信息擦除掉。也就是说，编译后得到的class字节码中并没有类型参数信息，字节码中没有类型参数信息，那么运行时肯定也就没有了。对于JVM来说，JVM根本不知道泛型类的这个语言现象的存在，泛型只有在编译时有效，可以对类型进行检查，比如：往List[String]中添加Int会导致编译错，但是在运行时，通过反射可以往List[String]中添加Int类型的元素，因为对JVM来说，List[String]、List[Int]是没有分别的，都会当做List(或者说是List[Object])来看待。</p><p>如下代码将全部输出true：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>[<span class="type">T</span>](<span class="params">data: <span class="type">T</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">b</span> </span>= <span class="keyword">new</span> <span class="type">Box</span>(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">println(b.isInstanceOf[<span class="type">Box</span>[<span class="type">Int</span>]])</span><br><span class="line"></span><br><span class="line">println(b.isInstanceOf[<span class="type">Box</span>[<span class="type">String</span>]])</span><br><span class="line"></span><br><span class="line">println(b.isInstanceOf[<span class="type">Box</span>[_]])</span><br></pre></td></tr></table></figure><p>Scala同Java一样，Scala代码编译后，也会丢失类型参数信息，上面的Box[T]说明了这一点。不过，Scala提供了ClassTag和TypeTag两个基本设施来应对类型擦除问题。</p><p>ClassTag和TypeTag的最重要的区别是，ClassTag只保留类型参数本身的类型，如果类型参数本身也是泛型类(这称为高阶类型，Hihger Kinded Type)，那么这个类型参数所持有的类型参数将丢失，而TypeTag却可以对任意的类型参数保留其参数信息。比如List[T]如果T不是泛型类型，比如List[Int]、List[Cat]等，那么ClassTag在运行时可以获取出类型参数的类型是Int、Cat，如果T本身又是以个泛型类型，比如List[Seq[Int]], List[Box[Int]]，那么ClassTag只能推断出第一层类型参数的新型信息，Seq和Box类型，而它们携带的类型参数将丢失</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box1</span>[<span class="type">T</span>: <span class="type">TypeTag</span>](<span class="params">val data:<span class="type">T</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printTypeOfparameter</span></span>() = &#123;</span><br><span class="line">    typeOf[<span class="type">T</span>] <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">Int</span>] =&gt; println(<span class="string">"int"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">String</span>] =&gt; println(<span class="string">"string"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">Seq</span>[<span class="type">Int</span>]] =&gt; println(<span class="string">"seq[int]"</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> boxes = <span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Box1</span>(<span class="string">"33"</span>), <span class="keyword">new</span> <span class="type">Box1</span>(<span class="number">12</span>), <span class="keyword">new</span> <span class="type">Box1</span>(<span class="type">Seq</span>(<span class="number">20</span>)))</span><br><span class="line"></span><br><span class="line">boxes.foreach(_.printTypeOfparameter())</span><br></pre></td></tr></table></figure><p>作为对比，对于ClassTag：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * classTag</span></span><br><span class="line"><span class="comment">  * @param data</span></span><br><span class="line"><span class="comment">  * @param `classTag$T`</span></span><br><span class="line"><span class="comment">  * @tparam T</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box2</span>[<span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params">val data:<span class="type">T</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printTypeOfparameter</span></span>() = &#123;</span><br><span class="line">    <span class="comment">// TODO 获取参数的运行时类型</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * A `ClassTag[T]` stores the erased class of a given type `T`, accessible via the `runtimeClass`</span></span><br><span class="line"><span class="comment">      * field. This is particularly useful for instantiating `Array`s whose element types are unknown</span></span><br><span class="line"><span class="comment">      * at compile time.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * `ClassTag`s are a weaker special case of [[scala.reflect.api.TypeTags.TypeTag]]s, in that they</span></span><br><span class="line"><span class="comment">      * wrap only the runtime class of a given type, whereas a `TypeTag` contains all static type</span></span><br><span class="line"><span class="comment">      * information. That is, `ClassTag`s are constructed from knowing only the top-level class of a</span></span><br><span class="line"><span class="comment">      * type, without necessarily knowing all of its argument types. This runtime information is enough</span></span><br><span class="line"><span class="comment">      * for runtime `Array` creation.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * For example:</span></span><br><span class="line"><span class="comment">      * &#123;&#123;&#123;</span></span><br><span class="line"><span class="comment">      *   scala&gt; def mkArray[T : ClassTag](elems: T*) = Array[T](elems: _*)</span></span><br><span class="line"><span class="comment">      *   mkArray: [T](elems: T*)(implicit evidence\$1: scala.reflect.ClassTag[T])Array[T]</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *   scala&gt; mkArray(42, 13)</span></span><br><span class="line"><span class="comment">      *   res0: Array[Int] = Array(42, 13)</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      *   scala&gt; mkArray("Japan","Brazil","Germany")</span></span><br><span class="line"><span class="comment">      *   res1: Array[String] = Array(Japan, Brazil, Germany)</span></span><br><span class="line"><span class="comment">      * &#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      * See [[scala.reflect.api.TypeTags]] for more examples, or the</span></span><br><span class="line"><span class="comment">      * [[http://docs.scala-lang.org/overviews/reflection/typetags-manifests.html Reflection Guide: TypeTags]]</span></span><br><span class="line"><span class="comment">      * for more details.</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">val</span> tag = implicitly[<span class="type">ClassTag</span>[<span class="type">T</span>]].runtimeClass</span><br><span class="line">    tag <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t == classOf[<span class="type">Int</span>] =&gt; println(<span class="string">"int"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t == classOf[<span class="type">String</span>] =&gt; println(<span class="string">"string"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t == classOf[<span class="type">Seq</span>[<span class="type">Int</span>]] =&gt; println(<span class="string">"seq[int]"</span>)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> boxes2 = <span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Box2</span>(<span class="string">"33"</span>), <span class="keyword">new</span> <span class="type">Box2</span>(<span class="number">12</span>), <span class="keyword">new</span> <span class="type">Box2</span>(<span class="type">Seq</span>(<span class="string">"hello"</span>)))</span><br><span class="line"></span><br><span class="line">boxes2.foreach(_.printTypeOfparameter())</span><br></pre></td></tr></table></figure><p>可见，对于高阶类型，ClassTag无法区分出一阶类型参数的类型参数的类型。上面如果[T:TypeTag]和[T:ClassTag]去掉，理论上来说我们的类型参数就会被擦除调，不过实际情况是不分API编译就不通过。</p><h2 id="型变"><a href="#型变" class="headerlink" title="型变"></a>型变</h2><p>scala中的泛型，比如M[T]中M称为类型构造器，T称为类型参数。型变描述的是类型参数继承关系下的泛型类的继承关系。如Cat是Animal的子类，而M是类型构造器，那么：</p><ul><li>如果M[Cat]是M[Animal]的子类，那么M[T]是协变的</li><li>如果M[Animal]是M[Cat]的子类，那么M[T]是逆变的</li><li>如果M[Animal]和M[Cat]没有继承关系，那么M[T]是不变的</li></ul><p>在scala中，型变是在类型定义的时候进行定义的，如果M是协变的，那么在参数的前面加一个+号，如果M是逆变的，那么在类型参数前面加一个-号，如果既不是协变的也不是逆变的，则什么也不加，比如协变M[+A]、逆变M[-A]、不变M[A]，其中的+和-称为<em>型变注解</em>variance annotation。</p><p>不变和协变在日常的工作过程中很常见：</p><ul><li>不可变的集合如Option、List、Set、Map等都是协变的</li><li>可变的集合，比如Array、ArrayBuffer、ListBuffer都是不可变的，如果他们是协变或者逆变的，很容易出现类型不安全的情况，这也是Scala吐槽Java类型安全的一个点（Java的集合是可变集合，并且是协变的）</li></ul><p>对于逆变的理解似乎有违常理，如M[T]是逆变的，也就是说M[Animal]是M[Cat]的子类。对于逆变的理解需要结合以下三点来理解：</p><ul><li>里氏替换原则</li><li>数据流向</li><li>回调（don’t call me，I will call you）</li></ul><p>数据流向和回调决定了逆变存在的合理性，而里氏替换原则则用于证明逆变的反继承关系，即证明M[Animal]是M[Cat]的子类。</p><p>1、WritableChannel</p><p>在java nio中有一个java.nio.channels.WritableByteChannel类，用于向Channel中写入字节数组（其实是ByteBuffer），这里将其泛型化，即可以写入任意类型，WritableChannel[T]表示这个Channel可以写入类型为T的数据，从数据流向和回调两个角度来说，WritableChannel是典型的逆变类型，也就是说Int是Any的子类，那么WritableChannel[Any]是WritableChannel[Int]的子类，下面通过代码来说明问题：</p><ul><li>定义一个WritableChannel的泛型类</li><li>定义一个Helper类，并定义如何使用WritableChannel类</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WritableChannel</span>[-<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(data: <span class="type">T</span>) = &#123;</span><br><span class="line">    println(<span class="string">"$data is written into channel"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">IntChannelHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span></span>(channel: <span class="type">WritableChannel</span>[<span class="type">Int</span>]) = &#123;</span><br><span class="line">      channel.write(<span class="number">100</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> intChannel = <span class="keyword">new</span> <span class="type">WritableChannel</span>[<span class="type">Int</span>]</span><br><span class="line">  <span class="keyword">val</span> anyChannel = <span class="keyword">new</span> <span class="type">WritableChannel</span>[any]</span><br><span class="line">  </span><br><span class="line">  <span class="type">IntChannelHelper</span>.write(intChannel)</span><br><span class="line">  <span class="type">IntChannelHelper</span>.write(anyChannel)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中IntChannelHelper类的write方法的含义是说，调用者需要传给我一个可以写入Int的数据通道，我可以回调该通道的write方法写入Int数据。因为IntChannelHelper类的方法要求我们给其提供一个Int类型的通道，我们给他提供的是可以写入任何类型的WritableChannel[Any]也就没有任何问题，可以想象一下我们向写入Any类型的通道写入Int也是可以的。根据里氏替换原则，A出现的位置，B一定可以出现的话，那么B一定是A的子类，也因此WritableChannel[Any]是WritableChannel[Int]的子类。</p><p>2、函数的入参类型是逆变的：给定两个类Fruit和Apple，Apple是Fruit的子类，证明函数Fruit=&gt;String是Apple=&gt;String的子类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">name</span> </span>= <span class="string">"apple"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(apple: <span class="type">Apple</span>)(func: <span class="type">Apple</span> =&gt; <span class="type">String</span>) = &#123;</span><br><span class="line">  <span class="keyword">val</span> name = func(apple)</span><br><span class="line">  println(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> apple = <span class="keyword">new</span> <span class="type">Apple</span></span><br><span class="line"></span><br><span class="line">process(apple)((x:<span class="type">Apple</span>) =&gt; x.name)</span><br><span class="line">process(apple)((x:<span class="type">Fruit</span>) =&gt; x.name)</span><br></pre></td></tr></table></figure><p>process方法的含义是在说，调用者给我一个Apple和一个处理Apple的函数（数据流向），我通过回调你的函数来对Apple进行处理（回调）。对于process(apple)((x:Apple) =&gt; x.name)来说类型完全匹配，不会产生问题；对于process(apple)((x:Fruit) =&gt; x.name)表示process拿着传入的Apple作为(x:Fruit) =&gt; x.name的参数调用，这也是没有问题的，因为Apple是Fruit的子类，因此，给函数(x:Fruit)=&gt;x.name传入Apple没有任何问题（里氏替换原则）</p><p>3、协变和逆变的生产者/消费者模式</p><p>这里的生产者/消费者模式，并不是阻塞队列中的生产者、消费者模式，而是指的数据的消费和产出。给定类型为M的对象，如果调用者需要为它提供类型为S的数据，即M对象消费类型为S的数据，那么M[S]可能是逆变的，如果M对象产出类型为T的数据，那么M[T]可能是协变的。如上面活到的函数Function[-T, +R]、Function[-T1，-T2, +R]，对于入参类型是逆变的，因为函数对象消费入参，而返回时协变的，因为返回值类型时函数的产出</p><p>4、对于函数和方法而言，函数参数所在位置是逆变位置，函数返回值所在的位置是协变位置，比如定义M[T]是协变的，但是T出现在了逆变的位置上就会出现相应的编译错误。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(t: <span class="type">T</span>) = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码在编译的时候就会报错</p><h2 id="视界"><a href="#视界" class="headerlink" title="视界"></a>视界</h2><h3 id="上界"><a href="#上界" class="headerlink" title="上界"></a>上界</h3><p>上界，upper bound，是面向对象语言里常用到的类型约束技术，他是通过类型的继承关系来对<strong>类型参数</strong>进行约束的技术（这里需要强调一下是类型参数，也就是说视界只可以出现在[]中）。上界的语法是[A&lt;:B]，表示类型参数A要么是B类型的子类，要么是B类型的本身，由于A和B的继承关系以及面向对象设计的里氏替换原则：如果A是B的子类，那么不管A的具体类型是什么，不管A隔着B有几代，A对象都可以把自己当作类型B的对象，类型B对象能做的事情，类型A也可以做，B对象有的能力，A对象都要有。遍历一个积类型的元素的内容，因为case class和元组都是Product的子类，举例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def print[T &lt;: Product](data: T): Unit = &#123;</span><br><span class="line">  println(data.productIterator.mkString(&quot; &quot;))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case class Person(name: String, age: Int)</span><br><span class="line"></span><br><span class="line">print(Person(&quot;wes&quot;, 10))</span><br><span class="line"></span><br><span class="line">print((1,2))</span><br></pre></td></tr></table></figure><p>在上下文界定和视图界定的那两篇文章中，通过上下文界定和视图界定约束参数类型是可以排序的，可以通过上界加Ordered也可以实现类型T约束，这里可以看到要实现排序只能通过继承Ordered，而不想上下文界定和视图界定里面的类型组合方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person1</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">Person1</span>]</span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Person1</span>) = age - that.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">T</span> &lt;: <span class="type">Ordered</span>[<span class="type">T</span>]](t1: <span class="type">T</span>, t2: <span class="type">T</span>) = &#123;</span><br><span class="line">  <span class="keyword">if</span> (t1 &gt; t2) t1 <span class="keyword">else</span> t2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(<span class="type">Person1</span>(<span class="string">"wes"</span>, <span class="number">12</span>), <span class="type">Person1</span>(<span class="string">"kk"</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p><strong>需要看一下Ordering与Ordered的区别</strong>。</p><h3 id="下界"><a href="#下界" class="headerlink" title="下界"></a>下界</h3><p>scala和Java一样，下界的应用并不常见，不过在看scala的源代码的时候，会经常看到下界的使用。因为在scala里面，比如集合框架，不变集合都是协变的，下界可以解决协变语言设计问题，比如scala中的Option类的getOrElse方法（说的通俗点就是下界解决了幺元的问题）</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Option</span>[+<span class="type">A</span>] <span class="keyword">extends</span> <span class="title">IterableOnce</span>[<span class="type">A</span>] <span class="keyword">with</span> <span class="title">Product</span> <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line"><span class="comment">/** Returns the option's value if the option is nonempty, otherwise</span></span><br><span class="line"><span class="comment">   * return the result of evaluating `default`.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This is equivalent to:</span></span><br><span class="line"><span class="comment">   * &#123;&#123;&#123;</span></span><br><span class="line"><span class="comment">   * option match &#123;</span></span><br><span class="line"><span class="comment">   *   case Some(x) =&gt; x</span></span><br><span class="line"><span class="comment">   *   case None    =&gt; default</span></span><br><span class="line"><span class="comment">   * &#125;</span></span><br><span class="line"><span class="comment">   * &#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   *  @param default  the default expression.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@inline</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrElse</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">default</span>: =&gt; <span class="type">B</span>): <span class="type">B</span> =</span><br><span class="line">    <span class="keyword">if</span> (isEmpty) <span class="keyword">default</span> <span class="keyword">else</span> <span class="keyword">this</span>.get</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的[B&gt;:A]就是下界的语法和用法，这是表示提供给getOrElse的默认值的类型以及它的返回值的类型都是B，<strong>需要考虑一下这里为什么使用下界，后面讲到协变的时候再说</strong></p><p><strong>需要弄清楚不变集合和可变集合的关系</strong></p><h2 id="下界与协变、上界与逆变"><a href="#下界与协变、上界与逆变" class="headerlink" title="下界与协变、上界与逆变"></a>下界与协变、上界与逆变</h2><p>在之前的章节有提到过，scala和java一样，下界并不是特别常用，但是Scala语言本身使用下界解决协变的一个语言设计问题（相对应的使用上界解决逆变的问题）</p><p>在不变、协变、逆变的章节中有提到，协变的类型不能出现在逆变的位置上（参数的位置是一个逆变的位置），因此如下代码会产生错误：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span>[+<span class="type">T</span>] </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">m</span></span>(x: <span class="type">T</span>): <span class="type">String</span> = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面报错，协变的类型不能出现不能出现在函数参数位置上，这个限制有点太大了，有些情况下，<strong>协变类型的元素不得不出现在方法参数位置上，比如Scala的两个不可变的集合List与Option，他们都是协变的集合。</strong></p><ol><li>scala.collection.immutable.List</li></ol><p>List 集合有一个方法 ::，用于在list表头添加一个元素，构造一个新的集合。它还有一个contains方法，用于检查集合中是否包含某一个元素，其定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>[+<span class="type">A</span>]</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">AbstractSeq</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">LinearSeq</span>[<span class="type">A</span>]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">LinearSeqOps</span>[<span class="type">A</span>, <span class="type">List</span>, <span class="type">List</span>[<span class="type">A</span>]]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">StrictOptimizedLinearSeqOps</span>[<span class="type">A</span>, <span class="type">List</span>, <span class="type">List</span>[<span class="type">A</span>]]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">StrictOptimizedSeqOps</span>[<span class="type">A</span>, <span class="type">List</span>, <span class="type">List</span>[<span class="type">A</span>]]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">IterableFactoryDefaults</span>[<span class="type">A</span>, <span class="type">List</span>]</span></span><br><span class="line"><span class="class">    <span class="keyword">with</span> <span class="title">DefaultSerializable</span> </span>&#123;</span><br><span class="line">      <span class="comment">/** Adds an element at the beginning of this list.</span></span><br><span class="line"><span class="comment">        *  @param elem the element to prepend.</span></span><br><span class="line"><span class="comment">        *  @return  a list which contains `x` as first element and</span></span><br><span class="line"><span class="comment">        *           which continues with this list.</span></span><br><span class="line"><span class="comment">        *  Example:</span></span><br><span class="line"><span class="comment">        *  &#123;&#123;&#123;1 :: List(2, 3) = List(2, 3).::(1) = List(1, 2, 3)&#125;&#125;&#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> </span>:: [<span class="type">B</span> &gt;: <span class="type">A</span>](elem: <span class="type">B</span>): <span class="type">List</span>[<span class="type">B</span>] =  <span class="keyword">new</span> ::(elem, <span class="keyword">this</span>)</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">contains</span></span>[<span class="type">A1</span> &gt;: <span class="type">A</span>](elem: <span class="type">A1</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        <span class="keyword">var</span> these: <span class="type">List</span>[<span class="type">A</span>] = <span class="keyword">this</span></span><br><span class="line">        <span class="keyword">while</span> (!these.isEmpty) &#123;</span><br><span class="line">          <span class="keyword">if</span> (these.head == elem) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">          these = these.tail</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述例子中A作为协变的类型又必须出现在函数参数的位置上，因此这里就出现了矛盾点，这里的解决方案是针对该协变类型指定一个上界，并将上界的类型放到该函数参数位置上。</p><p>Option的getOrElse方法也是类似的，这里就不再赘述了。</p><p>Scala通过下界来解决协变的类型不能出现在逆变位置上的问题。除了下界约束，还有上界约束，这里是否可以使用上界约束呢？不可以！如果使用上界约束会报错，通过一个MyOption的例子来举证一下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyOption</span>[+<span class="type">A</span>](<span class="params">val x: <span class="type">A</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse0</span></span>(<span class="keyword">default</span>: =&gt; <span class="type">A</span>): <span class="type">A</span> = ???</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只有这里是正确的，其他的两个方法声明都是存在问题的</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse1</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">default</span>: =&gt; <span class="type">B</span>): <span class="type">B</span> = ???</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getOrElse2</span></span>[<span class="type">B</span> &lt;: <span class="type">A</span>](<span class="keyword">default</span>: =&gt; <span class="type">B</span>): <span class="type">A</span> = ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中只有方法1是正确的，对于方法0是由于A出现在了逆变的位置上，对于2，我们抛开A的协变的性，单从这个方法所要表达的含义来说，这个方法完全没有问题，该方法想要表达的意思是：如果MyOption无值则返回一个类型为B的默认值（B是A的子类或者同类），也就是说，getOrElse2方法返回值类型上界是A，这从语义上比方法1更说的通，但是结合了A的协变性，就是错误的。应该在编译期就提示错误，使用下界解决协变问题本身就是一个权宜、折中的办法。</p><ol><li>Scala规范的型变位置是协变还是逆变位置的判定规则说明，如果A是协变的，那么如下方法的[B :&lt; A]的A所在的位置是逆变的，而A是协变的，因此编译出错</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOrElse</span></span>[<span class="type">B</span> &lt;: <span class="type">A</span>](<span class="keyword">default</span>: <span class="type">B</span>): <span class="type">A</span> = &#123;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="literal">null</span>) x <span class="keyword">else</span> <span class="keyword">default</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>因为MyOption是协变的，因此，假定Cat是Animal的子类，那么如下定义因为协变不会存在问题：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> opt0 = <span class="keyword">new</span> <span class="type">MyOption</span>[<span class="type">Animal</span>](<span class="keyword">new</span> <span class="type">Cat</span>)</span><br><span class="line"><span class="keyword">val</span> opt1 = <span class="keyword">new</span> <span class="type">MyOption</span>[<span class="type">Cat</span>](<span class="literal">null</span>)</span><br></pre></td></tr></table></figure><p>如下代码也没有问题：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ThirdParty</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getAnimal</span></span>: <span class="type">MyOption</span>[<span class="type">Animal</span>] = <span class="keyword">new</span> <span class="type">MyOption</span>[cat](<span class="literal">null</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> opt: <span class="type">Animal</span> = <span class="type">ThirdParty</span>.getAnimal.getOrElse(<span class="keyword">new</span> <span class="type">Animal</span>)</span><br></pre></td></tr></table></figure><p>上述代码中，如果getOrElse是上界约束的，那么这个就有编译错误。</p><p><code>val x = ThirdParty.getAnimal.getOrElse(1)</code>是否存在问题??</p><h2 id="存在类型"><a href="#存在类型" class="headerlink" title="存在类型"></a>存在类型</h2><p>Existential type对应的中文名称叫做存在类型。在参数化类型上，scala与java有一个重要的区别，因为java是从java5开始支持泛型的，1.4之前是没有的，因此为了向后兼容，java5允许泛型类不带类型参数，在这种情况下，Java5认为类型参数是Object，即List data = new ArrayLIst()等价于List<object> data = new ArrayLIst<object>()。而scala则不同，scala认为参数化类型是类型构造器，只有结合具体的类型参数才能当作类型使用，比如List[Int]，List是构造器，而Int是类型参数，List是不能够单独的作为类型进行使用的。</object></object></p><p>存在类型使用[_]表示，这里的_表示的是占位符，标识这里有一个类型参数，具体是什么它并不关心也不知道，在如下几种情况下，可以用到存在类型：</p><ol><li>classOf</li></ol><p>由于Java字节码编译出来后擦出了类型参数信息，因此，classOf[List[Int]]和classOf[List[String]]是完全一样的，这里为了强调获取的是LIst而不是类型参数的Class，最好使用classOf[List[_]]</p><ol start="2"><li>不关心类型参数的实际类型</li><li>与Java进行交互</li></ol><p>scala可以无缝的调用Java定义的类、接口、方法、变量等，如果Java定义了一个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionUtis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(java.util.Collection data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> data.size();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scala编译器推断出来的Size的类型参数是java.util.Collection[_]，也就是说，scala将不带参数的Java泛型解释成存在类型。</p><p>关于forSome</p><p>List[_]是一种简写写法，有些代码在使用存在类型的时候，使用forSome，这个有点啰嗦，不过起码要知道这种写法的含义：</p><ol><li>List[_]等价于List[T] forSome {type T}，T可以是任意的类型</li><li>List[_ &lt;: A]等价于Seq[T] forSome {type T &lt;: A}</li></ol><p>forSome风格的存在类型在Spark源代码中出现的并不多，如下是一个使用forSome定义的存在类型，他定义在EdgeRDD中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> [graphx] <span class="function"><span class="keyword">def</span> <span class="title">partitionsRDD</span></span>: <span class="type">RDD</span>[(<span class="type">PartitionID</span>, <span class="type">EdgePartition</span>[<span class="type">ED</span>, <span class="type">VD</span>])] <span class="keyword">forSome</span> &#123;<span class="class"><span class="keyword">type</span> <span class="title">VD</span>&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码等价于如下代码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> [graphx] <span class="function"><span class="keyword">def</span> <span class="title">partitionsRDD</span></span>: <span class="type">RDD</span>[(<span class="type">PartitionID</span>, <span class="type">EdgePartition</span>[<span class="type">ED</span>, _])]</span><br></pre></td></tr></table></figure><h2 id="自身类型SelfType"><a href="#自身类型SelfType" class="headerlink" title="自身类型SelfType"></a>自身类型SelfType</h2><p>Self Type，自身类型，初次看到这个词汇不知所云，更确切的应该称之为特质依赖类型Scala类型系统的自身类型(Self Type)主要有两个目的：</p><ol><li><p>指代当前对象，用作this的别名，在类型嵌套定义中，内部类可以通过这个别名访问外部类的对象</p></li><li><p>依赖注入</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  self =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a: <span class="type">Int</span>, b:<span class="type">Int</span>) = a + b</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner1</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(a:<span class="type">Int</span>) = self.sum(a, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> outer = <span class="keyword">new</span> <span class="type">Outer</span></span><br><span class="line"><span class="comment">// 这里区别于java的语法，java中是outer.new Inner</span></span><br><span class="line"><span class="keyword">val</span> inner1 = <span class="keyword">new</span> outer.<span class="type">Inner</span></span><br><span class="line"><span class="keyword">val</span> inner11 = <span class="keyword">new</span> inner1.<span class="type">Inner1</span></span><br><span class="line"></span><br><span class="line">println(inner11.sum(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>1)这里的self =&gt;就是自身类型，这里的self =&gt;可以看成是只依赖自身而没有依赖其它特质。</p><p>2)self的名称可以任意,比如this，that，myself都可以</p><p>3)这里的self.sum(a, 0)可以写成Outer.this.sum(a,0), 这里的语法跟Java类似，</p><ol start="2"><li>依赖控制(编译时检查一个trait依赖的其它trait是否存在)</li></ol><p>在Java web开发中，典型的三层结构：Controller-&gt;Service-&gt;DAO, Controller依赖Service，Service依赖DAO，如果是基于Spring依赖注入框架的web应用，那么Spring框架在启动时负责依赖的注入，注入分为构造注入和设值注入</p><p>在Scala中，通过自身类型可以实现特质之间的依赖控制，比如指定Service特质依赖DAO特质</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">trait IUserDao &#123;</span><br><span class="line">  def validateUser(name: String, passwd: String): Boolean = ???</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait IUserService &#123;</span><br><span class="line">  self: IUserDao =&gt;</span><br><span class="line"></span><br><span class="line">  def isvalidUser(name: String, passwd: String): Boolean = &#123;</span><br><span class="line">    self.validateUser(name, passwd)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val userService = new IUserService with IUserDao &#123;</span><br><span class="line">  override def validateUser(name: String, passwd: String): Boolean = &#123;</span><br><span class="line">    name.equals(&quot;wes&quot;) &amp;&amp; passwd.equals(&quot;wes&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">println(userService.isvalidUser(&quot;kk&quot;, &quot;wes&quot;))</span><br></pre></td></tr></table></figure><p>在上面的IUserService特质中，isValidUser调用了并没有在IUserService定义的validateUser方法，这里可以调用的原因是，通过self:IUserDAO=&gt;语句表示，混入IUserService的类，必须同时混入IUserDAO, 也就是说，IUserService特质依赖IUserDAO特质。因此这个类也就间接的定义了validateUser方法，因此IUserService方法可以调用validateUser方法。</p><p>Scala术语表(Scala Glossary)对Self Type的描述是Any concrete class that mixes in the trait must ensure that its type conforms to the trait’s self type，意思是：具体类混入一个特质时，必须同时混入这个特质定义的自身类型。在IuserService中self的类型包含了两个，也就是外部类和self所明确指定的类，具体可以通过如下代码进行验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(self.isInstanceOf[IUserDao])</span><br><span class="line">println(self.isInstanceOf[IUserService])</span><br></pre></td></tr></table></figure><p>通过自身类型实现依赖注入，这种实现方式称为蛋糕模式(Cake Pattern),这里的蛋糕应该称为分层蛋糕，一层叠一层的蛋糕，多特质混入可以认为是一个特质叠另一个特质，这有点像分层的蛋糕，一层是一个特质，比如：</p><p><code>val triathlon = new Player with Run with Ride With Swim</code></p><h2 id="上下文界定"><a href="#上下文界定" class="headerlink" title="上下文界定"></a>上下文界定</h2><p>上下文界定即ContextBound，他是一种通过上下文的隐式参数来对类型参数进行约束的技术，这里可以看出上下文界定的几个关键点：</p><ol><li>上下文界定的动机和目的是对类型参数进行约束</li><li>对类型参数进行约束的手段是通过上下文隐式参数</li><li>既然是对类型参数进行约束，那么必然涉及到参数化的类型（也就是常说的泛型）。比如M[T]，上下文界定的目的是对T进行约束，约束的做法是要求类型为M[T]的对象在上下文中隐式存在</li></ol><ol><li><p>从隐式参数说起</p><p>在Scala中，<strong>隐式参数</strong>有三个基本的用法（说明：隐式参数包含两层意思即泛型的参数以及隐式）</p><ul><li>为某种类型的参数提供默认值</li><li>为上下文提供默认的运行环境</li><li>为类型参数提供约束，要求类型参数支持某种能力</li></ul></li></ol><p>为某种类型的参数提供默认值略过不讲了</p><p>针对为上下文提供默认环境，隐式参数的这种用法，Scala中最经典的是用在异步处理scala.concurrent.Future接口，Future的每个方法都包含一个类型为ExecutionContext的隐式对象，ExecutionContext类似于Java的Executor、ExecutorService，即线程池对象。ExecutorContext用于执行Future对象本身所代表的一步任务，Future的foreach方法也包含一个类型为ExecutorContext的隐式对象，用于在异步任务处理结束得到异步处理的结果后，异步调度执行callback逻辑对结果进行进一步的处理。也就是说，ExecutorContext是为异步提供多线程运行时环境。Future构造器和foreach方法的签名对应如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>[<span class="type">T</span>](body: =&gt; <span class="type">T</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Future</span>[<span class="type">T</span>] = ???</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>[<span class="type">U</span>, <span class="type">T</span>](f: <span class="type">T</span>)(<span class="keyword">implicit</span> executor: <span class="type">ExecutionContext</span>): <span class="type">Unit</span> = ???</span><br></pre></td></tr></table></figure><p>Future的基本代码结构：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Future</span> &#123;</span><br><span class="line">  <span class="comment">// 异步任务代码块</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// 异步任务结果</span></span><br><span class="line">&#125; (<span class="type">ExecutorContext</span>.global).foreach(x =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对异步任务的结果再次进行异步处理</span></span><br><span class="line">&#125;) (<span class="type">ExecutorContext</span>.global)</span><br></pre></td></tr></table></figure><p>其中，ExecutorContext.global是scala定义的线程池，上面的代码是为ExecutorContext隐式对象现实的指定了ExecutorContext.global，也可以通过导入隐式对象到当前上下文，省略显式指定的ExecutorContext对象，通过这种方法代码会简洁很多，同时开发人员只需要关注任务逻辑和回调逻辑，而无需关心任务提交等，将任务本身的逻辑和任务提交执行的逻辑分离开来，具体如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="type">ExecutorContext</span>.<span class="type">Implicits</span>.global</span><br><span class="line"><span class="type">Future</span> &#123;</span><br><span class="line">  <span class="comment">// 异步任务代码块</span></span><br><span class="line">  ....</span><br><span class="line">  <span class="comment">// 异步任务结果</span></span><br><span class="line">&#125;.foreach(x =&gt; &#123;</span><br><span class="line">  <span class="comment">// 对异步任务的结果再次进行异步处理</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于为泛型参数提供约束，要求泛型参数支持某种能力。scala的集合比如List、Seq等包含max、maxBy方法用于对集合求最大值，求最大值也就意味着集合的元素是可比较排序的，如果集合的元素不能用于比较，那么max、maxBy必然会失败，那么这里就有两个问题：</p><ul><li>如何限制只有元素可排序的List才可以调用max、maxBy方法</li><li>如果元素不可排序的List调用了max、maxBy方法，是在编译时就失败还是在运行时失败</li></ul><p>Scala通过隐式参数类型约束限制了只有可排序的元素集合调用max、maxBy方法才能通过编译，也就是说，元素不可排序的List调用了max、maxBy方法会在编译时就失败，max的方法签名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def max(implicit cmp: Ordering[A]): A</span><br></pre></td></tr></table></figure><p>比如下面的代码编译失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">case class Person(val name: String, val age: Int)</span><br><span class="line">List(new Person(&quot;aaa&quot;, 1)).max</span><br></pre></td></tr></table></figure><ol start="2"><li><p>上下文界定</p><p>2.1 上下文界定跟上面说的隐式参数的第三点，为泛型参数提供约束，要求泛型参数支持某种能力完全一样，差别在于语法的不同上，上下文界定只是一种语法糖：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def max(a: T, b: T)(implicit cmp: Ordering[A]): A</span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">A</span>: <span class="type">Ordering</span>]: <span class="type">A</span></span><br></pre></td></tr></table></figure><p>[A: Ordering]这个语法就是上下文限定的语法（两个类型之间用冒号隔开，冒号的左边是参数类型，冒号的右边是类型构造器），它表示存在一个类型为Ordering[A]的隐式对象，上下文界定只是隐式参数的语法糖，一种快捷的写法。以max[A:B]为例，[A:B]表示存在一个类型为B[A]的隐式对象，也就是说，A最终用作B的类型参数，B是一个类型构造器（以A为类型参数）。在写[A:B]的时候常会错写为[A, B[A]]，这是不对的，上下文界定要求右侧的类型是类型构造器，不是具体的类型，写成B[A]表示的是一个具体的类型了。</p><p>2.2 implicitly</p><p>上面看到使用隐式参数和上下文界定是同一事物的两种写法，唯一的差别是隐式参数的写法可以获得到隐式参数的值，在上下文界定中却 没有这个值（比如上面的cmp），如果需要获取这个值的话，可以通过定义在predef中定义的implicitly这个方法得到，比如implicitly[Ordering[A]]，implicitly是一个无参函数，但却是一个泛型方法，提供给他的类型值就是要获得隐式值的类型。比如求两个值的较大者：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">A</span>: <span class="type">Ordering</span>](a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> cmp = implicitly[<span class="type">Ordering</span>[<span class="type">A</span>]]</span><br><span class="line">  <span class="keyword">if</span> (cmp.gt(a1, a2)) a1 <span class="keyword">else</span> a2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(<span class="number">12</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>Context Bound ,[Left: Right], requires types Left of some kind k and Right of kind k -&gt; *. That is, Left is some type or a type constructor, and Right is type constructor that can take Left as an argument to produce a concrete type. So, Right is never a concrete type, but Right[Left]always is.</p><h2 id="视图界定"><a href="#视图界定" class="headerlink" title="视图界定"></a>视图界定</h2><p>视图界定和上下文界定一样，也是通过上下文存在的一个隐式值来对类型参数进行约束（或者强制要求类型提供某些能力，比如可加减、可排序），但是上下文界定和视图界定通过隐式值，对类型参数进行处理的方式不同。上下文界定通过隐式参数进行类型约束，视图界定通过隐式转换进行类型约束，在前面上下文界定的例子中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>[<span class="type">A</span>: <span class="type">Ordering</span>](a1: <span class="type">A</span>, a2: <span class="type">A</span>): <span class="type">A</span> = &#123;</span><br><span class="line">  <span class="keyword">val</span> cmp = implicitly[<span class="type">Ordering</span>[<span class="type">A</span>]]</span><br><span class="line">  <span class="keyword">if</span> (cmp.gt(a1, a2)) a1 <span class="keyword">else</span> a2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(<span class="number">12</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure><p>要求在调用max方法的上下文中，存在一个类型为Ordering[A]的对象，也就是说，上下文界定是要求类型参数是类型类的成员，关于类型类在type class模式中会讲到。[A:Ordering]是隐式参数implicit ord: Ordering[A]的语法糖。</p><p>视界的写法[A &lt;% B]，其中A和B都是具体的类型，不像上下文界定中，B是类型构造器。视界要求存在一个隐式转换，可以将类型A转换为类型B，A的对象可以当作B类型用，这个隐式转换可以是隐式入参为A，出参为B的隐式方法，也可以是入参为A，出参为B的函数值，上面的max方法使用视界改写代码如下（需要注意是[T &lt;% Ordered[T]]）而不是[T &lt;% Ordered]：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def max1[T &lt;% Ordered[T]](a: T, b: T) = &#123;</span><br><span class="line">  if (a &gt; b) a else b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max1(122, 24)</span><br></pre></td></tr></table></figure><p>上面的代码能够正常工作的原因是：</p><ul><li>因为scala已经针对基本的可排序类型，比如Int、Long、Double、String提供了Int =&gt; Ordered[Int]的隐式转换，所以上面的隐式转换对象是存在的</li><li>a &gt; b能够正确工作的原因是， &gt; 是ordered定义的方法，因为 T can be viewed as ordered[T]，那么T可以使用Ordered[T]定义的方法，上面定义的max方法，如果对Person对象取max则失败</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">m</span> </span>= max1(<span class="type">Person</span>(<span class="string">"jack"</span>, <span class="number">12</span>), <span class="type">Person</span>(<span class="string">"Don"</span>, <span class="number">34</span>))</span><br></pre></td></tr></table></figure><p>原因是在max调用处的上下文中，并不存在一个Person =&gt; Ordered[Person]的隐式转换，需要定义一个隐式转换并云如刀上下文中：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">implicit</span> <span class="keyword">val</span> orderByAge = (p: <span class="type">Person</span>) =&gt; <span class="keyword">new</span> <span class="type">Ordered</span>[<span class="type">Person</span>] &#123;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">Person</span>): <span class="type">Int</span> = p.age - that.age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上文中加上这行代码就可以保障程序的正确执行了。</p><ul><li><p>视图界定有可能被废掉</p><p>视图界定只是上下文界定的一种特殊情况，视图界定可以做的，上下文界定一定可以做到，可能稍显繁琐。</p></li></ul><h2 id="type-class-模式"><a href="#type-class-模式" class="headerlink" title="type class 模式"></a>type class 模式</h2><p><a href="https://zhan-ge.gitbooks.io/scala/content/abstract-and-self-types/abstract-types.html" target="_blank" rel="noopener">参考链接</a></p><p>类型类是特殊的类，可以认为是高阶的class。</p><p>type class叫做类型类，该词汇来源于纯函数式编程语言Haskell，因为Hashkell语言里只有type，没有class的概念，因此在Haskell的世界里，type class很好的表达了type class的含义，class这里与类型无关，只是种类、类别的意思，或者叫做type family会更合适。</p><p>scala照搬了type class这个词汇，但是在scala、java这些class满天飞的面向对象语言里面，type、class都有确切的含义和指代，把type和class放到这里就成了四不像。</p><p>如前所说，在Scala里面，把type class理解成type family，类型家族，更确切，也更容易理解type class的语义是什么，能用来做什么。</p><p>type class是类型族的概念，那么就意味着有一个家族，这个家族有一堆类型作为家族成员。这里的家族就是类型类，家族成员是类型，在Scala中，</p><ol><li><p>类型类通常使用trait来定义，即类型类是一个接口，比如NumericLike，数字家族</p></li><li><p>每个家族都有其特征，类型类使用行为来表征这个家族的特征，对于数字家族，行为包括基本的加减乘除，每个行为就是一个抽象方法。需要注意点是，类型类对行为进行抽象，而不针对数据，因此类型类通常都是没有状态的</p></li><li><p>家族要有成员才能称为家族，type class的成员是类型，以NumericLike为例，类型T要成为NumericLike家族的成员，条件是当前仅当存在一个类型为NumericLike[T]的对象，比如如果存在NumericLike[Int], NumericLike[Doule]等对象，那么Int、Double都是NumericLike家族的成员</p></li></ol><p>通过上面第三点，可以看到，type class本身是一个参数化类型，M[T]，类型构造器M是type class，T是类型成员</p><p>参数化类型，我们见得多了，Java和Scala的集合都是类型参数化集合，比如List[Int],Seq[String],Set[Long]等，那么是不是定义个泛型类就是一个type class？显然不是，type class模式基本上可以看成是GOF 23种设计模式中的适配器模式，适配器模式有两种实现，一是基于类型继承，一是基于类型组合，type class是通过类型组合进行类行适配的技术。</p><p>给定类型List[Int],容器类型是List，容器的元素类型是Int，容器的类型List和容器的元素类型Int完全独立不相干，我们既不能说，Int is something like a List，也不能说 Int can act like a List</p><p>而type class则不同，给定一个类型类M，以及它的成员类型T，那么意味着存在着类型为M[T]的对象，M定义了一组表征它这个家族的行为，T必须向M定义的行为靠拢，也就是说，M和T之间存在着行为相似性，M和T不再完全独立不相干，它们的相关性体现在行为的相似性上。</p><p>上面说了很多关于对type class的理解，接下来看下type class在Scala中的实际应用，</p><p>Scala集合，比如List，Seq，定义了一个sum方法用于对集合求和，比如List(1,2,3).sum的结果是6，深入想一下就会发现，sum方法可能存在的问题：如果List中的元素不支持累加操作，那么sum方法必然失败，比如List(“1”,”How are you”).sum会失败，原因是字符串本身并不支持sum求和，具体的原因和解决办法在上下文界定那篇文章里讲到，这里我们又碰上上下文界定，这不是偶然的，因为，实际中，类型类都是基于上下文界定实现的</p><p>看下，List的sum方法的方法签名（A要具备B的能力，同时提供一个Numberic[B]的隐式转换，该隐式转换是一个类型类，接收一个类型B作为参数，最终生成的num包含的一些列方法将会用于后续的操作中）：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>[<span class="type">B</span> &gt;: <span class="type">A</span>](<span class="keyword">implicit</span> num: <span class="type">Numeric</span>[<span class="type">B</span>]): <span class="type">B</span> = foldLeft(num.zero)(num.plus)</span><br></pre></td></tr></table></figure><p>方法的签名表名，对于集合的元素类型A，要想通过编译，那么A必须是类型类Numeric的成员，从上面的签名也可以看到，类型类Numeric是一个泛型类型</p><p>Numeric接口的定义，Numeric接口定义了与数值相关的行为</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Numeric</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Ordering</span>[<span class="type">T</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">plus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">minus</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">times</span></span>(x: <span class="type">T</span>, y: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">negate</span></span>(x: <span class="type">T</span>): <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fromInt</span></span>(x: <span class="type">Int</span>): <span class="type">T</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toInt</span></span>(x: <span class="type">T</span>): <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toLong</span></span>(x: <span class="type">T</span>): <span class="type">Long</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toFloat</span></span>(x: <span class="type">T</span>): <span class="type">Float</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toDouble</span></span>(x: <span class="type">T</span>): <span class="type">Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为Scala已经为常见的数字类型，比如Int、Long、Double，通过定义Numeric[Int]、Numeric[Long]、Numeric[Long]隐式对象提供了默认的实现(如果对这些默认实现不满意，可以重新定义覆盖这些默认实现)，所以List(1,2,3)可以正常工作</p><p>因为，Scala没有将String纳入到Numeric这个家族中，因此调用List(“1”,”2”,”3”).sum会失败</p><p>假如我们现在希望List[String].sum得到的结果是List集合中所有字符串长度的和，那么我们可以定义Numeric[String]，将String纳入到Numeric家族中，并且根据sum的语义，实现Numeric的plus方法, 想法很美好。。。但是这种做法不可行，原因是Numeric的plus方法入参是两个字符串，出参同样是字符串，因此不能借助于List的sum方法来实现这个需求，这个需要自定义type class实现？</p><p>目前看，这个通过type class来实现这个需求，并不可行，只能List(“1”,”2”,”3”).map(_.length).sum？我再想想</p><h2 id="implicit类型关系证明"><a href="#implicit类型关系证明" class="headerlink" title="implicit类型关系证明"></a>implicit类型关系证明</h2><p>在上下文界定章节中，说到了隐式参数的灿哥基本功能：</p><ol><li>为某种类型的参数听过默认值</li><li>为上下文提供默认的运行环境</li><li>为类型参数提供约束，要求参数支持某种能力</li></ol><p>implicit类型证明可以归到第三种，为类型参数提供约束，只是在上下文界定的章节中，隐式参数通过要求M[T]类型的隐式参数存在，比如要求Ordering[Person]对象来对Person进行约束，而这里通过要求类型之间存在某种关系来达到类型约束的目的，隐式参数这里就是证明这种类型关系存在类型之间的关系，scala定义了两种：</p><p>A=:=B，代表了A和B是相同类型。A&lt;:&lt;B，A是B的子类或者A和B是同类型。</p><p>Scala的List有一个toMap方法，意思是将List[A]转换为Map[K, V]集合，对于普通的List如List(1, 2, 3)无法转换为Map集合，因为List的元素类型只有是Tuple2类型转换成Map集合才有意义，也就是只有List((1, “one”))这样的集合可以转换为Map，toMap的结果是Map[Int, String] (1 - &gt;  “one”,……)。Scala的做法就是通过定义隐式对象，通过这个隐式对象，要求List集合的元素类型是Tuple2的类型：A&lt;:&lt;(T, U)表示A是Tuple2的子类：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">toMap</span></span>[<span class="type">T</span>, <span class="type">U</span>](<span class="keyword">implicit</span> ev: <span class="type">A</span>&lt;:&lt;(<span class="type">T</span>,<span class="type">U</span>)): immutable.<span class="type">Map</span>[<span class="type">T</span>, <span class="type">U</span>] = &#123;</span><br><span class="line"><span class="keyword">val</span> b = immutable.<span class="type">Map</span>.newBuilder[<span class="type">T</span>, <span class="type">U</span>]</span><br><span class="line"><span class="keyword">for</span> (x &lt;- self) &#123;</span><br><span class="line">b += x</span><br><span class="line">&#125;</span><br><span class="line">b.result()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 上面这种类型约束并不少见，特别适合于操作只对某种特定的类型才有效的类型约束上。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>[<span class="type">T</span>](<span class="params">val data: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(that: <span class="type">Box</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> ev <span class="type">T</span> =:= <span class="type">Int</span>) = <span class="keyword">new</span> <span class="type">Box</span>(data + that.data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(that: <span class="type">Box</span>[<span class="type">T</span>])(<span class="keyword">implicit</span> ev <span class="type">T</span> &lt;:&lt; <span class="type">Ordered</span>[<span class="type">T</span>]) = <span class="keyword">if</span> (data &gt; that.data) <span class="keyword">this</span> <span class="keyword">else</span> that</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = <span class="string">s"Box[<span class="subst">$data</span>]"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Box的add方法只能用于Box[Int]，而Box的max方法则要求T必须是可排序的，即T是Ordered[T]的子类。在add方法中，并没有直接使用隐式参数ev，但是scala编译器通过这个隐式参数，可以把T当作Int使用，因此data+that.data是合法额的，+是Int定义的方法。</p><h2 id="关于typeOf"><a href="#关于typeOf" class="headerlink" title="关于typeOf"></a>关于typeOf</h2><p>scala提供了两个方法classOf、typeOf用来根据类型信息获取相应的类型对象，classOf定义在Predef中，typeOf定义在scala.reflect.runtime.universe中。</p><p>classOf[String]得到的是String.class，通过classOf获得泛型类的类型信息，比如classOf[List[Int]]，那么得到的是List.class，而List的参数类型的类型信息将丢失，因此，classOf[List[String]]和classOf[List[Int]]是完全一样的，都是classOf[List]</p><p>而typeOf则不同，它可以准确的得到类型参数的信息，即typeOf[List[String]]和typeOf[List[Int]]是不同的，如下代码输出List[Int]</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tpe = typeOf[<span class="type">List</span>[<span class="type">Int</span>]]</span><br><span class="line">println(tpe)</span><br></pre></td></tr></table></figure><ol start="2"><li>typeOf方法的结果类型TypeRef</li></ol><p>TypeRef继承自Type，Type的定义是：type Type &gt;: Null &lt;: AnyRef with TypeApi， 可以看到Type是对象类型，TypeRef的定义是：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeRef</span>(<span class="params">pre: <span class="type">Type</span>, sym: <span class="type">Symbol</span>, args: <span class="type">List</span>[<span class="type">Type</span>]</span>) <span class="keyword">extends</span> <span class="title">UniqueType</span> <span class="keyword">with</span> <span class="title">TypeRefApi</span>) </span>&#123;</span><br><span class="line">   <span class="comment">//class definition</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TypeRef的构造参数包含一个类型为Type的变量pre，因此，TypeRef可以看成是递归的结构，同时，TypeRef是一个case class，因此TypeRef可以通过模式匹配进行解构，如下代码所示：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>[<span class="type">T</span>: <span class="type">TypeTag</span>](<span class="params">val data: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printTypeParameter</span></span>() = &#123;</span><br><span class="line">    typeOf[<span class="type">T</span>] <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">Int</span>] =&gt; println(<span class="string">"Int"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">String</span>] =&gt; println(<span class="string">"String"</span>)</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t &lt;:&lt; typeOf[<span class="type">Seq</span>[_]] =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">TypeRef</span>(pre, sym, <span class="type">List</span>(elementType)) = typeOf[<span class="type">T</span>]</span><br><span class="line">        elementType <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">Int</span>] =&gt; println(<span class="string">"Seq[Int]"</span>)</span><br><span class="line">          <span class="keyword">case</span> t <span class="keyword">if</span> t =:= typeOf[<span class="type">String</span>] =&gt; println(<span class="string">"Seq[String]"</span>)</span><br><span class="line">          <span class="keyword">case</span> _ =&gt; println(<span class="string">"Seq[Unknown]"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> boxes = <span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Box</span>(<span class="number">10</span>), <span class="keyword">new</span> <span class="type">Box</span>(<span class="string">"20"</span>), <span class="keyword">new</span> <span class="type">Box</span>(<span class="type">Seq</span>(<span class="number">20</span>)), <span class="keyword">new</span> <span class="type">Box</span>(<span class="type">Seq</span>(<span class="string">"20"</span>)))</span><br><span class="line">boxes.foreach(_.printTypeParameter())</span><br></pre></td></tr></table></figure><p>上面的例子如果遇到了高阶类型，比如Box[Seq[Int]]，那么通过解构typeOf[Seq[Int]]得到Seq的类型参数的类型。</p><p>加入Box的类型是Box[Map[Int,String]]，那么析构的代码：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>[<span class="type">T</span>: <span class="type">TypeTag</span>](<span class="params">val data: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printTypeParameter</span></span>() = &#123;</span><br><span class="line">    typeOf[<span class="type">T</span>] <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> t <span class="keyword">if</span> t &lt;:&lt; typeOf[<span class="type">Map</span>[_,_]] =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="type">TypeRef</span>(pre, sym, <span class="type">List</span>(k,v)) = typeOf[<span class="type">T</span>]</span><br><span class="line">        <span class="keyword">if</span> (k =:= typeOf[<span class="type">Int</span>] &amp;&amp; v =:= typeOf[<span class="type">String</span>]) &#123;</span><br><span class="line">          println(<span class="string">"Map[Int,String])"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          println(<span class="string">"Map[Unknown])"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; println(<span class="string">"Unknown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> map = <span class="type">Map</span>(<span class="number">1</span>-&gt;<span class="string">"One"</span>)</span><br><span class="line"><span class="keyword">val</span> boxes = <span class="type">Seq</span>(<span class="keyword">new</span> <span class="type">Box</span>(map))</span><br><span class="line">boxes.foreach(_.printTypeParameter())</span><br></pre></td></tr></table></figure><h2 id="结构类型-Structural-Type"><a href="#结构类型-Structural-Type" class="headerlink" title="结构类型 Structural Type"></a>结构类型 Structural Type</h2><p>结构类型在实际项目中基本不会使用，这里简单介绍一下只是为了scala类型系统这个系列的完整性，另外如果真有人这么写，也保证我们能看的懂。</p><p>Scala结构类型，有时也成为Static Duck Typing,它是一种使用行为来表征一个类型的做法，这个类型是无名的，Scala在运行时，通过反射来根据结构类型来合成一个具体的类型，反射是一个相对比较耗时的操作，所以，实际中没有什么人用结构类型，一、代码很ugly，二、性能损失</p><ol><li>作为参数类型</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(resource: &#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span></span><br><span class="line"> &#125;): <span class="type">Unit</span> = &#123;</span><br><span class="line">   resource.close()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>() = println(<span class="string">"Resource is closed"</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>如下就是一个结构类型定义，它没有别的要求，只要定义了返回类型为Unit的close，那么就是满足这个类型的定义</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>(): <span class="type">Unit</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>结构类型别名</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Closable = &#123;</span><br><span class="line">   def close(): Unit</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>接着上面的Resource类，new Resource().isInstanceof[Closable]的结果为true</p><ol start="3"><li>类型参数约束</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">close</span></span>[<span class="type">T</span> &lt;: &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">close</span></span>() : <span class="type">Unit</span></span><br><span class="line">    &#125;](resource: <span class="type">T</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      resource.close()</span><br><span class="line">    &#125;</span><br><span class="line">close(<span class="keyword">new</span> <span class="type">Resource</span>)</span><br></pre></td></tr></table></figure><ol start="4"><li>结构类型作为返回值的类型</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def get: &#123;</span><br><span class="line">   def close(): Unit</span><br><span class="line"> &#125; = new Resource()</span><br></pre></td></tr></table></figure><p>从上面四个基本用法上可以到，结构类型可以当做普通类型一样使用，不过，一方面代码显得啰嗦，另一方面，结构类型在运行时通过反射合成一个具体的JVM能识别的普通class，性能有损耗</p><p>在jackson-scala上应用了这种结构型，不过纯粹是体验下这种写法，不是必须的。</p>  <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_json</span></span>(obj: <span class="type">AnyRef</span>, withPrettyPrinter: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">String</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> out = <span class="keyword">new</span> <span class="type">StringWriter</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> writer: &#123;<span class="function"><span class="keyword">def</span> <span class="title">writeValue</span></span>(writer: <span class="type">Writer</span>, obj: <span class="type">AnyRef</span>)&#125; = <span class="keyword">if</span> (withPrettyPrinter) mapper.writerWithDefaultPrettyPrinter() <span class="keyword">else</span> mapper</span><br><span class="line"></span><br><span class="line">    writer.writeValue(out, obj)</span><br><span class="line"></span><br><span class="line">   out.toString</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>mapper.writerWithDefaultPrettyPrinter() 和 mapper的类型不一致，但是都有相同的方法writeValue(writer: Writer, obj: AnyRef)，所以可以使用结构型来定义变量</strong></p><h2 id="单一实例类型"><a href="#单一实例类型" class="headerlink" title="单一实例类型"></a>单一实例类型</h2><p>在Scala里面，有时会将方法的返回值的类型定义成this.type,这是为了实现fluent API(链式API)。Java的StringBuilder的append方法是典型的fluent API，append方法可以连续调用，比如new StringBuilder().append(“a”).append(“b”).append(“c”).toString()得到的结果是字符串abc</p><p>StringBuilder可以这样做的原因是append方法的返回值的类型是StringBuilder，返回值是this，因此可以链式调用。Java的这种fluent api在面型子类对父类进行扩展的情况时，不能很好的表达，Scala对这种场景进行统一和完善，</p><ol><li>Java fluent API的问题</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">substract</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        total -= a;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Calculator <span class="title">add</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        total += a;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ComplexCalculator c = <span class="keyword">new</span> ComplexCalculator();</span><br><span class="line">        c.substract(<span class="number">1</span>).add(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面创建完ComplexCalculator类，依次调用substract和add方法等，调用完add方法后不能继续调用substract方法了，原因是，Java编译器判断出add方法的返回类型是Calculator，而Calculator上没有subtract方法，因此无法继续链式调用子类上定义的subtract方法，</p><ol start="2"><li>this.type</li></ol><p>Scala通过指定返回类类型是this.type可以保留this对象的实际类型，因为上面创建的对象类型ComplexCalculator，因此级联调用可以继续下去</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComplexCalculator</span> <span class="keyword">extends</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">subtract</span></span>(a: <span class="type">Int</span>): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= &#123;</span><br><span class="line">    total -= a</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> total: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(a: <span class="type">Int</span>): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= &#123;</span><br><span class="line">    total += a</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">result</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">val</span> c = <span class="keyword">new</span> <span class="type">ComplexCalculator</span>();</span><br><span class="line">c.subtract(<span class="number">1</span>).add(<span class="number">10</span>).subtract(<span class="number">3</span>).add(<span class="number">2</span>).subtract(<span class="number">6</span>);</span><br></pre></td></tr></table></figure><ol start="3"><li>类型单一实例</li></ol><p>上面this.type具有普遍意义，this表示一个对象，也就是说，Scala为每个对象都定义了一个type属性，这个type属性表示这个对象的类型，而且这个类型只有这个对象一个实例，比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">a1</span> </span>= <span class="keyword">new</span> <span class="type">A</span></span><br><span class="line"><span class="keyword">val</span> a2 = <span class="keyword">new</span> <span class="type">A</span></span><br><span class="line"><span class="keyword">val</span> x: a1<span class="class">.<span class="keyword">type</span> </span>= a1</span><br><span class="line"><span class="comment">//编译错，a2不是a1.type类型</span></span><br><span class="line"><span class="comment">//    val y:a1.type  = a2</span></span><br><span class="line">println(a1.isInstanceOf[a1<span class="class">.<span class="keyword">type</span>]) <span class="title">//true</span></span></span><br><span class="line"><span class="class"><span class="title">println</span>(<span class="params">a2.isInstanceOf[a1.type]</span>) <span class="title">//false</span></span></span><br></pre></td></tr></table></figure><p>a1.type这个类型只有a1一个对象，把a2赋值给类型为a1.type的变量报错，因为a2的类型a2.type和a1.type不同(typeOf[a1.type] =:= typeOf[a2.type]为false)</p><ol start="4"><li>object的类型</li></ol><p>Scala通过object关键字可以定义单例对象，这个object的名称既表示这个单例类的名称，又表示这个单例类的唯一实例，比如</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(str:<span class="type">Any</span>) = println(str)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print</span></span>(a: <span class="type">A</span><span class="class">.<span class="keyword">type</span>) </span>= a.print(a.isInstanceOf[<span class="type">A</span><span class="class">.<span class="keyword">type</span>])</span></span><br></pre></td></tr></table></figure><p>A既表示A这个单例类的名称，又表示A这个单例类的唯一对象，A.type表示对象A的类型, 直接使用A表示单例对象，</p><h2 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h2><p>Scala同Java一样，都是单类继承，多接口实现的语言，Scala里面接口称为特质，对应的，称为多特质混入。Scala类型系统的复合类型这个语法现象可以解决多接口继承(多特质混入)上的一个类型设计问题。以铁人三项比赛项目为例，铁人三项是游泳、长跑和骑行三个项目的组合，这里将游泳、长跑和骑行三个项目定义成三个特质</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span></span><br><span class="line"><span class="class"><span class="title">trait</span> <span class="title">Swim</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">swim</span></span>() = println(<span class="string">"triathlon swim"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() = println(<span class="string">"triathlon run"</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Ride</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ride</span></span>() = println(<span class="string">"triathlon ride"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个方法，传入一个铁人三项运动员对象，进行铁人三项比赛</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triathlon</span></span>(player: 铁人三项运动员): <span class="type">Unit</span> = &#123;</span><br><span class="line">  player.swim()</span><br><span class="line">  player.run()</span><br><span class="line">  player.ride()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的player要支持铁人三项的三个比赛项目，swim，run以及ride，那么的player的类型如何指定？在Java中，通常的做法是让Player继承Swim、Run和Ride接口，但是类型结构既复杂又不灵活。Scala通过复合类型来解决这个问题，如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">triathlon</span></span>(player: <span class="type">Player</span> <span class="keyword">with</span> <span class="type">Swim</span> <span class="keyword">with</span> <span class="type">Run</span> <span class="keyword">with</span> <span class="type">Ride</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">   player.swim()</span><br><span class="line">   player.run()</span><br><span class="line">   player.ride()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>调用方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> player = <span class="keyword">new</span> <span class="type">Player</span> <span class="keyword">with</span> <span class="type">Swimeet</span> <span class="keyword">with</span> <span class="type">Runmeet</span> <span class="keyword">with</span> <span class="type">Ridemeet</span></span><br><span class="line">triathlon(player)</span><br></pre></td></tr></table></figure><p>从上面可以看到，Scala有类似动态类型语言的特性，在声明变量时，可以动态的混入多个特质，类型可以即拿即用，如果需要改写某个特质的实现，可以像Java那样通过匿名内部类的方式，这在Scala中称为Type Refinement</p><p>最后说明一点，Java通过泛型的类型约束也能实现triathlon(player: Player with Swimeet with Runmeet with Ridemeet)这样的参数类型定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Swim</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Ride</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ride</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Triathlon</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> &lt;T extends Player &amp; Swim &amp; Run &amp; Ride&gt; <span class="function"><span class="keyword">void</span> <span class="title">triathlon</span><span class="params">(T player)</span> </span>&#123;</span><br><span class="line">        player.swim();</span><br><span class="line">        player.run();</span><br><span class="line">        player.ride();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是构造一个实现这些接口的player就比较麻烦了，只能定义一个Player，让Player实现Swim、Run和Ride接口</p><h2 id="类型投影"><a href="#类型投影" class="headerlink" title="类型投影"></a>类型投影</h2><p>在Scala中定义内部类的时候，由于类型的路径依赖，内部类的类型通常跟外部类的实例绑定在一起, 那实际中就需要解决一个问题：将内部类一般化，将内部类的类型跟外部类的实例解绑(因为Java中没有类型路径依赖，因此Java中内部类的类型和外部类的实例是天然解绑的，Java中使用Outer.Inner来表示通用的内部类，在Scala中，通过类型投影来解绑内部类与外部类对象的绑定)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Outer &#123;</span><br><span class="line"> </span><br><span class="line">  class Inner &#123;</span><br><span class="line">    def print=println(&quot;Inner is called&quot;)</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">val outer1 = new Outer</span><br><span class="line">val outer2 = new Outer</span><br><span class="line">val a1 = new outer1.Inner</span><br><span class="line">val a2 = new outer2.Inner</span><br><span class="line"> </span><br><span class="line">def work(inner: Inner类型) &#123;</span><br><span class="line">  inner.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的work方法，work接受一个Outer内部类Inner类型的对象，这里期望的Inner类型不与Outer类的对象绑定，即work接收任意的Inner类型的对象，那么这里的Inner类型如何指定？</p><ol><li>如果指定a1.type或者a2.type，那么work将只能接收a1或者a2作为输入参数，那么work的入参无法普遍适用于Inner类型的对象。这里也不能指定为Outer.Inner，</li></ol><p>通过这种方式指定会报编译错，通过这种方式指定表示Outer是一个object，而实际上Outer是一个class</p><p>Scala通过类型投影来实现内部类与外部类对象的解绑，语法是Outer#Inner，通过这种方式，如下语句都没有编译错：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a1 :<span class="type">Outer</span>#<span class="type">Inner</span> = <span class="keyword">new</span> outer1.<span class="type">Inner</span></span><br><span class="line"><span class="keyword">val</span> a2 :<span class="type">Outer</span>#<span class="type">Inner</span> = <span class="keyword">new</span> outer2.<span class="type">Inner</span></span><br></pre></td></tr></table></figure><p>在Hadoop MapReduce 程序中应用类型投影：</p><p>如下是Hadoop Mapper API的定义，从中可以看出Context是Mapper的内部类，并且map方法使用了这个内部类Context</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>[<span class="type">LongWritable</span>, <span class="type">Text</span>, <span class="type">Text</span>, <span class="type">IntWritable</span>] </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">MapperContext</span> </span>= <span class="type">Mapper</span>[<span class="type">LongWritable</span>, <span class="type">Text</span>, <span class="type">Text</span>, <span class="type">IntWritable</span>]#<span class="type">Context</span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">text2String</span></span>(value: <span class="type">Text</span>) = value.toString</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">string2Text</span></span>(value: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Text</span>(value)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">val</span> one = <span class="keyword">new</span> <span class="type">IntWritable</span>(<span class="number">1</span>)</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(key: <span class="type">LongWritable</span>, line: <span class="type">Text</span>, context: <span class="type">MapperContext</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> words = line.split(<span class="string">","</span>)</span><br><span class="line">    words.foreach(context.write(_, one))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于类型擦除，在上面定义了两个与Outer类型对象绑定的Inner类型的对象：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> a1 = <span class="keyword">new</span> outer1.<span class="type">Inner</span></span><br><span class="line"><span class="keyword">val</span> a2 = <span class="keyword">new</span> outer2.<span class="type">Inner</span></span><br></pre></td></tr></table></figure><p>虽然val a2 : outer2.Inner=a1有编译错，但是a1.isInstanceof[outer2.Inner]的结果是true，因为运行时，outer2.Inner经过类型擦除后，它的类型退化为投影类型，Outer#Inner</p><h2 id="抽象类型成员abstract-type-members"><a href="#抽象类型成员abstract-type-members" class="headerlink" title="抽象类型成员abstract type members"></a>抽象类型成员abstract type members</h2><p>在java的类和接口中，只有方法成员是可以抽象的，数据成员是不能抽象的，并且Java中没有类型成员的概念。在scala中不但有类型成员，而且方法成员、数据成员和类型成员都是可以抽象的。比如，如下定义A的数据成员是抽象的，这在Java中做不到：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> x: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> x: <span class="type">Int</span> = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>scala的抽象类型成员和类型参数在功能上有很多相似支持，都是对类型进行抽象，如下是他们的一些不同之处：</p><ol><li>抽象类型成员（就是用type牟定的）只适用于具有继承关系的类结构体系中，父类定义抽象类型，子类通过继承实现父类定义的抽象成员，在此基础上使用这个类型，而类型参数则不要求通过继承指定具体类型</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">In</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">get</span></span>: <span class="type">In</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">CatBox</span> <span class="keyword">extends</span> <span class="title">Box</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">In</span> </span>= <span class="type">Cat</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span> </span>= <span class="keyword">new</span> <span class="type">Cat</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过类型参数指定的话如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat1</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Box1</span>[<span class="type">T</span> &gt;: <span class="type">Cat1</span>] </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>: <span class="type">T</span> = <span class="keyword">new</span> <span class="type">Cat1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">Box1</span>().get</span><br></pre></td></tr></table></figure><ol start="2"><li>抽象类型不能出现在类的构造参数位置，如下的抽象类型定义有编译出错，抽象类型不能出现在对应的构造参数位置：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>(<span class="params">data: <span class="type">In</span></span>) </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">In</span></span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class">  <span class="title">def</span> <span class="title">get</span></span>: <span class="type">In</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>抽象类型需要有子类的具体化，从语义上来说，抽象类型将和抽象类通常一起演化，也就是说，抽象类型的具体类型和抽象类的实现类通常是相关的，比如：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">S</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">source</span></span>: <span class="type">S</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(): <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">StringBuilder</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> source = <span class="keyword">new</span> <span class="type">StringBuilder</span>(<span class="string">"hello world"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>() = source.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteArrayReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="class"><span class="keyword">type</span> <span class="title">S</span> </span>= <span class="type">Array</span>[<span class="type">Byte</span>]</span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> source = <span class="string">"hello"</span>.getBytes()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>() = <span class="keyword">new</span> <span class="type">String</span>(source)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型参数通常和类型构造器之间并没有联系，比如scala集合和集合元素之间的类型，比如List[Int]和Int并没有联系。不过上面的Reader同样是可以用类型参数来实现，也就是是说，Reader这个例子并不是抽象类型由于类型参数。</p><ol start="4"><li>在上面的例子中，抽象类型在子类中完成实例化，那么在子类中这个类型就是确定的，可以拿这个类型做这个类型支持的操作，而在类型参数中，通常需要类型参数约束来为类型参数指定他能支持的操作（比如上下界、视界、上下文界定等类型参数约束技术）。</li></ol><p>到目前为止，都是抽象类型能做到的，类型参数也能做到的，而类型参数能做到的，抽象参数不一定可以做的到，具体如下：</p><ol><li>如果类结构定义除了涉及到类型参数化外，还涉及到类型的继承，通常抽象类型是比较好的选择，继承类的类型不再是参数化类型，那么使用抽象类型很合适。</li><li>类型参数膨胀：如下，每个子类都携带类型参数，通过类型参数的方式，类型参数的指定比较啰嗦重复，但是这种类型继承层次以及类型结构，实际并不多见：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">trait X[S, T, U]</span><br><span class="line"></span><br><span class="line">trait Y[S, T, U] extends X[S, T, U]</span><br><span class="line"></span><br><span class="line">trait Z[S, U] extends Y[S, String, U]</span><br><span class="line"></span><br><span class="line">class XYZ[S] extends Z[S, Int]</span><br><span class="line"></span><br><span class="line">new XYZ[Boolean]</span><br></pre></td></tr></table></figure><p>我们可以通过抽象类型版本进行改造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">trait X1 &#123;</span><br><span class="line">  type S</span><br><span class="line">  type T</span><br><span class="line">  type U</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trait Y1 extends X1</span><br><span class="line"></span><br><span class="line">trait Z1 extends Y1 &#123;</span><br><span class="line">  type T = String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class XYZ1 extends Y1 &#123;</span><br><span class="line">  type U = Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class XYZ2[S] extends Y1 &#123;</span><br><span class="line">  type U = Int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new XYZ1</span><br><span class="line"></span><br><span class="line">new XYZ2[Boolean]</span><br></pre></td></tr></table></figure><p>上面通过抽象类型改造之后，在声明最后一个类的时候，由于我们要具化对象因此也使用了类型参数相结合的方式声明了泛型类。</p><ol start="3"><li>抽象类型成员与方法的依赖类型结合实现磁铁模式，这个在方法依赖类型中有详细的阐述</li></ol><h2 id="方法依赖类型"><a href="#方法依赖类型" class="headerlink" title="方法依赖类型"></a>方法依赖类型</h2><p>抽象类型和方法依赖类型组合实现了抽象工厂模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">abstract class Computer &#123;</span><br><span class="line"></span><br><span class="line">  def memory: String</span><br><span class="line"></span><br><span class="line">  def CPU: String</span><br><span class="line"></span><br><span class="line">  def disk: String</span><br><span class="line"></span><br><span class="line">  override def toString: String = s&quot;memory: $memory, cpu: $CPU, disk: $disk&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">abstract class ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  type C &lt;: Computer</span><br><span class="line"></span><br><span class="line">  def create: C</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create(factory: ComputerFactory): factory.C = factory.create</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DellFactory extends ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">  class DellComputer extends Computer &#123;</span><br><span class="line">    override def memory = &quot;dell memory&quot;</span><br><span class="line"></span><br><span class="line">    override def CPU = &quot;dell cpu&quot;</span><br><span class="line"></span><br><span class="line">    override def disk = &quot;dell disk&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override type C = DellComputer</span><br><span class="line"></span><br><span class="line">  override def create = new DellComputer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class AppleFactory extends ComputerFactory &#123;</span><br><span class="line"></span><br><span class="line">  class AppleComputer extends Computer &#123;</span><br><span class="line">    override def memory = &quot;dell memory&quot;</span><br><span class="line"></span><br><span class="line">    override def CPU = &quot;dell cpu&quot;</span><br><span class="line"></span><br><span class="line">    override def disk = &quot;dell disk&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override type C = AppleComputer</span><br><span class="line"></span><br><span class="line">  override def create = new AppleComputer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的方法中<code>def create(factory: ComputerFactory): factory.C = factory.create</code>就是一个方法依赖类型，方法的返回值的类型依赖于方法的入参的类型，传入不同的工厂得到对应的工厂的产品，正式抽象工厂模式。</p><h2 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h2><p>symbol的字面意思是符号、记号、标志等，具体到scala反射系统symbol表示的意思是带名符号，“带名”的意思是每个symbol都有一个name（Symbol特质定义了name方法），同时Symbol这个符号用来刻画Scala的语法要素，即<strong>抽象语法树的语法要素</strong>（这里可能会涉及元编程的内容）。</p><p>Scala的Symbol特质定义了一系列的子特质，比如：TypeSymbol、ClassSymbol、TermSymbol、MethodSymbol等。</p><ol><li>使用TypeSymbol用来刻画类型，TypeSymbol特质定义可一系列的操作用来获取类型信息<ul><li>如果TypeSymbol表示类型参数，那么这个类型是否是逆变的、是否是协变的</li><li>TypeSymbol表示的类型是否是类型别名</li><li>TypeSymbol表示的类型是否是抽象类型</li><li>TypeSymbol表示的类型是否是存在类型</li><li>如果TypeSymbol表示类型构造器，那么可以获取该类型构造器的类型参数集合</li></ul></li><li>使用ClassSymbol用来刻画Scala的类和接口，ClassSymbol特质定义了一系列操作用来判断：<ul><li>一个类或者特质是否是密封类（sealed trait）</li><li>这个类是否是case class</li><li>是否是特质</li><li>是否是抽象类</li><li>ClassSymbol可以用来获取父类或者父特质等</li></ul></li><li>使用MethodSymbol用来刻画Scala的方法，MethodSymbol特质定义了一系列的操作用来刻画一个方法<ul><li>该方法是否是类的主构造</li><li>方法的返回值类型</li><li>方法声明的异常类型集合</li><li>方法的参数列表级每个参数列表的类型</li><li>参数类型是否是变长类型等</li></ul></li><li>使用TermSymbol用来刻画Scala的变量和方法，TermSymbol是MethodSymbol的父类，但是scala并没有为变量定义一个FieldSymbol特质，为什么TermSymbol既用来刻画变量又用来刻画方法（刻画了方法很少的一部分特征，其他的在MethodSymbol中刻画的），这是因为Scala有统一访问原则，意思是这些方法可以当作变量使用，比如父类定义的变量可以在子类中以定义方法的方式重写，父类定义的方法可以在子类中一定义变量的方式进行重写。TermSymbol定义的操作：<ul><li>变量是Val还是var</li><li>判断方法是getter还是setter</li><li>是否是lazy变量</li><li>获取变量对应的getter或者setter方法</li><li>TermSymbol表示的参数是否是传名参数，这里可以看到方法参数也是TermSymbol</li><li>TermSymbol如果表示方法参数，那么这个参数是否带有默认值</li></ul></li></ol><p>因为方法属于某个类或者特质，方法参数属于某个方法，那么用于刻画方法、类或者特质、方法参数的Symbol就应该包含关系，Symbol的定义确实定义了owner方法用来描述Symbol之间的包含关系</p><p>在上面梳理的TypeSymbol、ClassSymbol、MethodSymbol、TermSymbol的时候，并没有包含对package、可见权限控制、是否final的描述。这些内容定义在了他们的公共父类Symbol中，Symbol包含如下方法：</p><p>isImplicit、isAbstract、isPrivate….等方法，从上面的描述中可以看到Symbol用来刻画scala抽象语法树的构成成分，将这些成分使用统一的Symbol特质描述，这跟Java类型泛型系统定义的如下类（定义在java.lang.reflect包中）类似：Constructor、Type….</p><p>最后通过一个简单的例子来演示一下Symbol的用法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import scala.reflect.runtime.universe._</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line"></span><br><span class="line">  val x = 10</span><br><span class="line">  def print() = println(x)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">val x: Symbol = typeOf[A].member(TermName(&quot;x&quot;))</span><br><span class="line">val print: Symbol = typeOf[A].member(TermName(&quot;print&quot;))</span><br><span class="line">println(x.asTerm.isVal)</span><br><span class="line">println(x.asTerm.isVar)</span><br><span class="line">println(print.asMethod.isPublic)</span><br></pre></td></tr></table></figure><p>这里不清楚为什么x.asTerm.isVal也是false，需要研究一下</p><h2 id="Typesymbol、Type与TypeRef"><a href="#Typesymbol、Type与TypeRef" class="headerlink" title="Typesymbol、Type与TypeRef"></a>Typesymbol、Type与TypeRef</h2><p>Java由于类型擦除特性导致编译时的参数在运行时会丢失，scala通过TypeTag隐式对象将编译时的类型参数信息维持到了运行时，也就是说，scala通过TypeTag解决了Java编译时的类型参数信息在运行时丢失的问题。</p><p>Scala使用Type、TypeRef表示运行时的类型信息，可以看成是加强版的Java Class对象，这里说的Tyoe对应到Symbol中的TypeSymbol</p><ol><li>析构TypeRef</li></ol><p>TypeRef是Type的子类，TypeRef一个case class，当我们获取到一个Type对象时，这个对象通常也是TypeRef类型，因为TypeRef时case class，因此可以使用模式匹配的方式对其进行析构（获取TypeRef内部构造信息），TypeRef的析构函数的定义如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(tpe: <span class="type">TypeRef</span>): <span class="type">Option</span>[(<span class="type">Type</span>, <span class="type">Symbol</span>, <span class="type">List</span>[<span class="type">Type</span>])]</span><br></pre></td></tr></table></figure><p>可以看到，对TYpeRef进行析构将得到一个三元组，(Type, Symbol, List[Type])，这个三元组的意思在ScalaDoc定义了一些示例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">T</span> # <span class="type">C</span>[<span class="type">T_1</span>,.....,<span class="type">T_n</span>]<span class="type">TypeRef</span>(<span class="type">T</span>, <span class="type">C</span>, <span class="type">List</span>(<span class="type">T_1</span>, .... , <span class="type">T_n</span>))</span><br><span class="line">p.<span class="type">C</span>[<span class="type">T_1</span>,...,<span class="type">T_n</span>]<span class="type">TypeRef</span>(p<span class="class">.<span class="keyword">type</span>, <span class="title">C</span>, <span class="title">List</span>(<span class="params"><span class="type">T_1</span>,....,<span class="type">T_n</span></span>))</span></span><br><span class="line"><span class="class"><span class="title">C</span>[<span class="type">T_1</span>,...,<span class="type">T_n</span>]<span class="title">TypeRef</span>(<span class="params"><span class="type">NoPrefix</span>, <span class="type">C</span>, <span class="type">List</span>(<span class="type">T_1</span>,...,<span class="type">T_n</span></span>))</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">#</span> <span class="title">C</span> <span class="title">TypeRef</span>(<span class="params"><span class="type">T</span>, <span class="type">C</span>, <span class="type">Nil</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">p</span>.<span class="title">C</span><span class="title">TypeRef</span>(<span class="params">p.type, <span class="type">C</span>, <span class="type">Nil</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">C</span><span class="title">TypeRef</span>(<span class="params"><span class="type">NoPrefix</span>, <span class="type">C</span>, <span class="type">Nil</span></span>)</span></span><br></pre></td></tr></table></figure><p>元组的第一个元素是类型的路径类型，比如对于p.C，类型C的路径是p，这里通过p.type得到路径p的类型</p><p>元组的第二个元素是类型本身，具体的是TypeSymbol</p><p>元组的第三个元素是类型的参数类型列表，每个参数类型本身也是Type类型</p><ol start="2"><li>根据类型的到Type对象（或者TypeRef对象）</li></ol><p>通过runtime.Universe定义的typeOf方法获取指定类型的Type对象</p><ul><li>无类型参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class A</span><br><span class="line">import scala.reflect.runtime.universe._</span><br><span class="line">val tpe = typeOf[A]</span><br><span class="line">val TypeRef(pre, sym, List()) = tpe</span><br></pre></td></tr></table></figure><p>得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defined class A</span><br><span class="line">import scala.reflect.runtime.universe._</span><br><span class="line">tpe: reflect.runtime.universe.Type = A</span><br><span class="line">pre: reflect.runtime.universe.Type = type</span><br><span class="line">sym: reflect.runtime.universe.Symbol = class A</span><br></pre></td></tr></table></figure><ul><li>类型嵌套</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.reflect.runtime.universe._</span><br><span class="line"><span class="keyword">val</span> tpe = typeOf[<span class="type">List</span>[<span class="type">Seq</span>[<span class="type">Int</span>]]]</span><br><span class="line"><span class="keyword">val</span> <span class="type">TypeRef</span>(pre, sym, <span class="type">List</span>(tp))=tpe</span><br></pre></td></tr></table></figure><p>对应结果如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.reflect.runtime.universe._</span><br><span class="line">tpe1: reflect.runtime.universe.<span class="type">Type</span> = <span class="type">List</span>[<span class="type">Seq</span>[<span class="type">Int</span>]]</span><br><span class="line">pre1: reflect.runtime.universe.<span class="type">Type</span> = scala<span class="class">.<span class="keyword">type</span></span></span><br><span class="line"><span class="class"><span class="title">sym1</span></span>: reflect.runtime.universe.<span class="type">Symbol</span> = <span class="class"><span class="keyword">type</span> <span class="title">List</span></span></span><br><span class="line"><span class="class"><span class="title">tp</span></span>: reflect.runtime.universe.<span class="type">Type</span> = <span class="type">Seq</span>[<span class="type">Int</span>]</span><br></pre></td></tr></table></figure><ul><li>两个类型参数</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tpe2 = typeOf[<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>]]</span><br><span class="line"><span class="keyword">val</span> <span class="type">TypeRef</span>(pre2, sym2,<span class="type">List</span>(k, v)) = tpe2</span><br></pre></td></tr></table></figure><p>析构上面的Type，对应的结果如下</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tpe2: reflect.runtime.universe.<span class="type">Type</span> = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Int</span>]</span><br><span class="line">pre2: reflect.runtime.universe.<span class="type">Type</span> = scala.<span class="type">Predef</span><span class="class">.<span class="keyword">type</span></span></span><br><span class="line"><span class="class"><span class="title">sym2</span></span>: reflect.runtime.universe.<span class="type">Symbol</span> = <span class="class"><span class="keyword">type</span> <span class="title">Map</span></span></span><br><span class="line"><span class="class"><span class="title">k</span></span>: reflect.runtime.universe.<span class="type">Type</span> = <span class="type">String</span></span><br><span class="line">v: reflect.runtime.universe.<span class="type">Type</span> = <span class="type">Int</span></span><br></pre></td></tr></table></figure><ol start="3"><li>根据对象得到该对象对应类型的Type对象</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def getType[T: TypeTag](obj: T): Type = typeOf[T]</span><br></pre></td></tr></table></figure><p>需要注意的是，上下文界定的T: TypeTag是必须的，typeOf方法要求上下文存在一个类型为TypeTag[T]的隐式对象</p><ol start="4"><li>类型关系比较</li></ol><p>Type定义了两个函数用于判断类型关系，=:=用于判断两个Type是否相等，类似于Java Class对象的 ==，&lt;:&lt;用于判断两个Type是否存在继承关系，类细于Java Class对象的isAssignableFrom方法。</p><p>为什么Scala需要定义两个看上去像是运算符的方法来判断类型关系呢，这是由于Scala的特性，使用Java定义的方法会出现误判的情况。</p><h2 id="Mirror"><a href="#Mirror" class="headerlink" title="Mirror"></a>Mirror</h2><p>Mirror的字面意思是镜像、映像，可以认为是从某个视角对某个事物的反应，这个事物时本尊，Mirror都是本尊的副本、影子、映像等。在Scala反射系统里面，如何理解Mirror可以有两种解读思路：</p><ol><li>沿着刚才的思路，Mirror可以认为是从某个视角对事物的反映，那么在Scala反射系统里，这里的视角就是ClassLoader，而事物时ClassPath上的类，不同的ClassLoader可能会加载ClassPath上相同的或者不同的类，因此Mirror可以看成是运行时被某个ClassLoader加载起来的类，他们是ClassPath上所有class的一种映像。</li><li>Reflect (或者Reflection)和Mirror都有反映的意思，比如，to reflect、to mirror，所以Mirror在这里是一个动词，可以理解成反射动作，可以把Mirror理解成Reflect。</li></ol><p>Mirror是从ClassLoader的视角对ClassPath上的类的映像，因此只有有了ClassLoader才能获取一个runtime Mirror（scala的反射系统分为Runtime Mirror和compile time Mirror），如下代码定义了一个case class Person，然后使用Person类的类加载器获取一个Mirror对象，这个Mirror对象是通过调用在runtime.universe中定义的runtimeMirror得到的：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, salary: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">raiseSalary</span></span>(salary: <span class="type">Int</span>) = <span class="keyword">this</span>.salary + salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> loader = classOf[<span class="type">Person</span>].getClassLoader</span><br><span class="line"><span class="comment">// 根据ClassLoader获取该ClassLoader视角runtime reflection mirror</span></span><br><span class="line"><span class="keyword">val</span> mirror: <span class="type">Mirror</span> = runtimeMirror(loader)</span><br></pre></td></tr></table></figure><p>有了上面的Mirror，就可以进行反射操作了，反射动作包含如下几个：</p><ol><li>ClassMirror：通过Mirror的reflectClass方法可以对一个Class进行反射，获得一个ClassMirror对象，这个ClassMirror对象可以用来获得构造方法对应的MethodMirror</li><li>InstanceMirror：通过Mirror的reflect方法可以对一个实例（Instance）进行反射，获得一个InstanceMirror对象，通过该对象可以获得MethodMirror、FieldMirror，他们用来对方法和成员变量进行反射</li><li>MethodMirrior：使用MethodMirror可以对方法进行反射调用，类似Java的Method.invoke方法，不同于Java的Method类，Java的Method是不包含该方法所属对象的，当调用Method.invoke方法，该方法作用在哪个对象上是作为invoke方法传入的。</li><li>FieldMirror：使用FieldMirror可以对成员变量进行反射，包括get和set方法</li><li>ModuleMirror：使用了Mirror的reflectModule方法，可以对object进行反射，如下是使用上面提到的Mirror的详细例子：</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span>, salary: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">raiseSalary</span></span>(salary: <span class="type">Int</span>) = <span class="keyword">this</span>.salary + salary</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> loader = classOf[<span class="type">Person</span>].getClassLoader</span><br><span class="line"><span class="keyword">val</span> mirror: <span class="type">Mirror</span> = runtimeMirror(loader)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对Class反射获取ClassMirror</span></span><br><span class="line"><span class="keyword">val</span> classSymbol = typeOf[<span class="type">Person</span>].typeSymbol.asClass</span><br><span class="line"><span class="keyword">val</span> cm: <span class="type">ClassMirror</span> = mirror.reflectClass(classSymbol)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据ClassMirror获取构造函数Mirror，构造函数Mirror是一个MethodMirror</span></span><br><span class="line"><span class="comment">// 不过这个MethodMirror是与类相关的</span></span><br><span class="line"><span class="keyword">val</span> cstSymbol = typeOf[<span class="type">Person</span>].decl(termNames.<span class="type">CONSTRUCTOR</span>).asMethod</span><br><span class="line"><span class="keyword">val</span> ctrom: <span class="type">MethodMirror</span> = cm.reflectConstructor(cstSymbol)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用构造方法Mirror创建对象</span></span><br><span class="line"><span class="keyword">val</span> p = ctrom(<span class="string">"wes"</span>, <span class="number">12</span>, <span class="number">1000</span>).asInstanceOf[<span class="type">Person</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对对象进行反射，得到InstanceMirror</span></span><br><span class="line"><span class="keyword">val</span> im: <span class="type">InstanceMirror</span> = mirror.reflect(p)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射调用函数</span></span><br><span class="line"><span class="keyword">val</span> methodRaiseSalary = typeOf[<span class="type">Person</span>].decl(<span class="type">TermName</span>(<span class="string">"raiseSalary"</span>)).asMethod</span><br><span class="line"><span class="keyword">val</span> rm = im.reflectMethod(methodRaiseSalary)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> salary = rm.apply(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">println(salary)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反射获取对象的成员对象，可以反射调用</span></span><br><span class="line"><span class="keyword">val</span> fieldSalary = typeOf[<span class="type">Person</span>].decl(<span class="type">TermName</span>(<span class="string">"salary"</span>)).asTerm</span><br><span class="line"><span class="keyword">val</span> fm: <span class="type">FieldMirror</span> = im.reflectField(fieldSalary)</span><br><span class="line"></span><br><span class="line">println(fm.get)</span><br><span class="line">fm.set(<span class="number">100</span>)</span><br><span class="line">println(fm.get)</span><br></pre></td></tr></table></figure><p>对应结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">defined class Person</span><br><span class="line"></span><br><span class="line">loader: ClassLoader = scala.tools.nsc.interpreter.IMain$TranslatingClassLoader@16c6a4f2</span><br><span class="line">mirror: reflect.runtime.universe.Mirror = JavaMirror with scala.tools.nsc.interpreter.IMain$TranslatingClassLoader@16c6a4f2 of type class scala.tools.nsc.interpreter.IMain$TranslatingClassLoader with classpath [(memory)] and parent being scala.reflect.internal.util.ScalaClassLoader$URLClassLoader@53dab604 of type class scala.reflect.internal.util.ScalaClassLoader$URLClassLoader with classpath [file:/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre/lib/resources.jar,file:/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre/lib/rt.jar,file:/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre/lib/jsse.jar,file:/Library/Java/JavaVirtualMachines/jdk1.8.0_202.jdk/Contents/Home/jre/lib/jce.jar,file:/Library/Java/JavaVirtualMachines/jdk1.8.0_20...</span><br><span class="line"></span><br><span class="line">classSymbol: reflect.runtime.universe.ClassSymbol = class Person</span><br><span class="line">cm: reflect.runtime.universe.ClassMirror = class mirror for Person (bound to null)</span><br><span class="line"></span><br><span class="line">cstSymbol: reflect.runtime.universe.MethodSymbol = constructor Person</span><br><span class="line">ctrom: reflect.runtime.universe.MethodMirror = constructor mirror for def &lt;init&gt;(name: String, age: Int, salary: Int): Person (bound to null)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p: Person = Person(wes,12,1000)</span><br><span class="line"></span><br><span class="line">im: reflect.runtime.universe.InstanceMirror = instance mirror for Person(wes,12,1000)</span><br><span class="line"></span><br><span class="line">methodRaiseSalary: reflect.runtime.universe.MethodSymbol = method raiseSalary</span><br><span class="line">rm: reflect.runtime.universe.MethodMirror = method mirror for def raiseSalary(salary: Int): Int (bound to Person(wes,12,1000))</span><br><span class="line"></span><br><span class="line">salary: Any = 1100</span><br><span class="line"></span><br><span class="line">1100</span><br><span class="line"></span><br><span class="line">fieldSalary: reflect.runtime.universe.TermSymbol = value salary</span><br><span class="line">fm: reflect.runtime.universe.FieldMirror = field mirror for private[this] val salary: Int (bound to Person(wes,12,1000))</span><br><span class="line"></span><br><span class="line">1000</span><br><span class="line"></span><br><span class="line">100</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><a href="https://scala.cool/tags/Scala-%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spring cloud 学习笔记</title>
      <link href="/2021/09/21/spring-cloud-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/09/21/spring-cloud-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>spring cloud是基于spring boot开发的微服务框架的典范，在微服务领域同样也有dubbo，初步从网上查了一下，dubbo在功能上可以认为是spring cloud的一个子集，另外spring cloud使用的是http的协议进行的服务调用，而dubbo使用的rpc的协议进行的服务调用。本次主要针对spring cloud中的功能模块的学习进行总结。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><p>spring cloud的服务注册与发现有多种可能的实现，比较常见的可以是eureka server，使用和配置的过程如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里引入了eureka-server以来，就是用来实现服务注册中心的，接下来我们启动一个web应用，并加上<code>@EnableEurekaServer</code>注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Hello world!</span><br><span class="line"> */</span><br><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class RegisterCenter &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        new SpringApplicationBuilder(RegisterCenter.class).web(true).run(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们指定配置文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server.port=1111</span><br><span class="line">eureka.client.register-with-eureka=false</span><br><span class="line">eureka.client.fetch-registry=false</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:$&#123;server.port&#125;/eureka</span><br></pre></td></tr></table></figure><p>启动服务我们可以看到对应的页面如下：</p><p><img src="//southrivers.github.io/2021/09/21/spring-cloud-学习笔记/image-20210921221409964.png" alt="image-20210921221409964"></p><p>上图中红框标出来的就是在该注册中心中的对应的服务的实例。通常情况下我们可以构建高可用的服务注册中心，并且也可以选择zookeeper等作为服务注册中心（zk是cp的注册中心，eureka是ap的注册中心，通常枪框下我们的注册中心不可用不应该影响服务的可用状态，因此eureka在某种程度上更适合作为注册中心）。</p><h2 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h2><p>在微服务架构中，我们将系统拆分成一个一个的微服务，如果一个服务出现故障，就可能会因为服务的依赖传递蔓延到整个系统中，因此产生了断路器模式，spring cloud 使用了Netflix hystrix来实现断路器的功能。我们创建几个微服务，来分别实现一定的功能。引入pom文件如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-ribbon<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-feign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在应用的启动类上面加上<code>@EnableCircuitBreaker</code>注解来开启断路器的功能，接下来需要在调用方的函数上增加<code>@HystrixCommand(fallbackMethod = &quot;fallbackAdd&quot;)</code>注解，这种方式可以直接制定回落的方法，不过更好的一种方法其实是实现指定的接口，在接口中完善回落方法，正常情况下请求是通过代理完成服务的调用，当调用失败的时候将会调用对应类的对应方法。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.feign.FeignClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"><span class="keyword">import</span> springcloud.service.fallback.ConsumerServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"compute-service"</span>, fallback = ConsumerServiceImpl<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/add"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function">String <span class="title">add</span><span class="params">(@RequestParam(<span class="string">"a"</span>)</span> Integer a, @<span class="title">RequestParam</span><span class="params">(<span class="string">"b"</span>)</span> Integer b)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们在feignclient注解上指定了fallback的实现类，对应的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> springcloud.service.ConsumerService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerServiceImpl</span> <span class="keyword">implements</span> <span class="title">ConsumerService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"something wrong"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样当我们请求服务失败的时候就会直接跳转到该实现类的方法上。</p><h2 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h2><p>一半的公司都会实现配置中心，类似于CMDB的一个功能，用来给各个服务提供统一的配置中心，好处的话自然是可以在多个系统中维护一份配置信息，在spring cloud中也有类似的功能框架spring cloud config，spring cloud config基于应用、版本、环境来管理配置信息，并支持git，也就是我们可以通过git来实现配置信息的管理，接下来我们引入依赖，并配置相关的信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-config-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建应用入口，并通过<code>@EnableConfigServer</code>开启配置服务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.config.server.EnableConfigServer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableConfigServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(ConfigApplication<span class="class">.<span class="keyword">class</span>).<span class="title">web</span>(<span class="title">true</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置服务的信息，并指定配置的地址等信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=config-server</span><br><span class="line">server.port=7001</span><br><span class="line"># 这里的key值是uri，不是url</span><br><span class="line">spring.cloud.config.server.git.uri=https://github.com/southrivers/spring-cloud-config.git</span><br><span class="line">spring.cloud.config.server.git.searchPaths=repo</span><br><span class="line">spring.cloud.config.username=username</span><br><span class="line">spring.cloud.config.password=xxxxxxx</span><br></pre></td></tr></table></figure><p>最后启动服务就可以从git上拉取配置信息。</p><h2 id="服务网关"><a href="#服务网关" class="headerlink" title="服务网关"></a>服务网关</h2><p>我们一般使用nginx来实现负载均衡，在某种程度上nginx像是服务的网关，那为什么还要再再spring cloud中多引入一个网关的功能呢？我们知道微服务一般是无状态的，也就是说我们的权限等相关的信息不应该放在每一个微服务上，如果放到各个服务上，权限相关的代码看起来必定不是很清爽，因此我们引入了Netflix zuul作为服务的网关，该组建出了具备路由、负载均衡之外还具备权限控制的功能，这样我们就可以将权限相关的控制逻辑转移到这里，并使得微服务代码具备更高的可服用以及可测试性。引入如下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Brixton.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建应用入口并使用<code>@EnableZuulProxy</code>开启zuul：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.SpringCloudApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hello world!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableZuulProxy</span></span><br><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gateway</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> SpringApplicationBuilder(Gateway<span class="class">.<span class="keyword">class</span>).<span class="title">web</span>(<span class="title">true</span>).<span class="title">run</span>(<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后增加配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=gateway</span><br><span class="line">server.port=11000</span><br><span class="line"></span><br><span class="line">zuul.routes.api-a.path=/api-a/**</span><br><span class="line">zuul.routes.api-a.serviceId=COMPUTE-SERVICE</span><br><span class="line"></span><br><span class="line">zuul.routes.api-b.path=/api-b/**</span><br><span class="line">zuul.routes.api-b.serviceId=CONSUMER-SERVICE</span><br><span class="line">eureka.instance.hostname=localhost</span><br><span class="line"># 这里一定要是true才可以，否则会报forword error的错误</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://localhost:1111/eureka</span><br></pre></td></tr></table></figure><p>如上，我们在配置信息中指定路由的url前缀匹配的服务，并配置在服务启动的时候就获取相应的配置信息。这样所有的请求将会通过zuul转发到对应的服务。</p><h2 id="调用链追踪"><a href="#调用链追踪" class="headerlink" title="调用链追踪"></a>调用链追踪</h2><p>在分布式的微服务中，如果服务间的依赖比较复杂，是需要分析服务间的调用关系及相互影响的，也就是我们常说的调用链分析，在spring cloud中有比较成熟的调用链分析技术：sleuth，其本质是zipkin client的一个封装，首先我们需要启动一个zipkin server：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.zipkin.java<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zipkin-autoconfigure-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Edgware.SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们通过注解<code>@EnableZipkinServer</code>来开启zipkin server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import zipkin.server.EnableZipkinServer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Hello world!</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZipkinServer</span><br><span class="line">public class ZipkinServer &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(ZipkinServer.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后指定服务的配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.port=9411</span><br></pre></td></tr></table></figure><p>接下来我们只需要在对应的服务中引入相应的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>就可以在服务调用的时候像zipkin server注册相应的信息了，对应结果如下：</p><p><img src="//southrivers.github.io/2021/09/21/spring-cloud-学习笔记/image-20210921221409964.png" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间仓促，对应的实现原理还没有来得及分析，stream也没有补充（stream是服务总线，可以实现各个服务对某一事件的订阅，从而达到对应服务统一更新配置信息等相关功能），对应的完整代码地址如下：<a href="https://github.com/southrivers/spring-cloud-study" target="_blank" rel="noopener">git地址</a>，后续有时间的话继续完善。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int[] dp;</span><br><span class="line">    public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        dp = new int[amount+1];</span><br><span class="line">        Arrays.fill(dp,-6);</span><br><span class="line">        return  dd(coins,amount);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int dd(int[] coins,int amount)&#123;</span><br><span class="line">        if(amount&lt;0) return -1;</span><br><span class="line">        if(amount==0) return 0;</span><br><span class="line">        if(dp[amount]!=-6) return dp[amount];</span><br><span class="line">        int res=Integer.MAX_VALUE,g=0;</span><br><span class="line">        for(int f:coins)&#123;</span><br><span class="line">            g=dd(coins,amount-f);</span><br><span class="line">            if(g==-1) continue;</span><br><span class="line">            res=Math.min(res,g+1);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[amount]=res==Integer.MAX_VALUE?-1:res;</span><br><span class="line">        return dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int[] tmp; </span><br><span class="line">    public int coinChange(int[] coins, int amount) &#123;</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        tmp = new int[amount + 1];</span><br><span class="line">        Arrays.fill(tmp, -666);</span><br><span class="line">        return help(coins, amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int help(int[] coins, int amount) &#123;</span><br><span class="line">        if (amount == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (amount &lt; 0) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (tmp[amount] != -666) </span><br><span class="line">            return tmp[amount];</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        for (int coin : coins) &#123;</span><br><span class="line">            int subProblem = coinChange(coins, amount-coin);</span><br><span class="line">            if (subProblem &lt; 0) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.min(res, subProblem + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp[amount] = (res == Integer.MAX_VALUE) ? -1 : res;</span><br><span class="line">        return tmp[amount];</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">作者：priate1</span><br><span class="line">链接：https://leetcode-cn.com/problems/coin-change/solution/java-dong-tai-gui-hua-by-priate1-jn3d/</span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas使用总结</title>
      <link href="/2021/06/26/pandas%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2021/06/26/pandas%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="详细接口"><a href="#详细接口" class="headerlink" title="详细接口"></a>详细接口</h1><ul><li>重新设置索引列</li><li>/bin/zsh -c “$(curl -fsSL <a href="https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;" target="_blank" rel="noopener">https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)&quot;</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.set_index(<span class="string">"row"</span>)</span><br></pre></td></tr></table></figure><ul><li>矩阵转置操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.transpose(df)</span><br></pre></td></tr></table></figure><ul><li>行操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df.xs(<span class="string">"BB"</span>, level=<span class="number">0</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>代码演示，读取excel进行类型转换，当前存在类型转换失败的问题，带定位。TODO</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置选择中文索引列正常</span></span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重新设置索引列，也即是横坐标</span></span><br><span class="line">    df = pd.read_excel(<span class="string">'/Users/shuaizi/Desktop/excel/test-excel.xlsx'</span>)</span><br><span class="line">    df1 = df.set_index(<span class="string">'姓名'</span>)</span><br><span class="line">    sys.stdout.write(str(df1))</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"\n=================\n"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># df数据类型转换</span></span><br><span class="line">    df1[<span class="string">'age'</span>]=pd.to_numeric(df1[<span class="string">'age'</span>], errors=<span class="string">'ignore'</span>, downcast=<span class="string">'float'</span>).fillna(<span class="number">0</span>)</span><br><span class="line">    print(str(df1))</span><br><span class="line">    print(<span class="string">"\n=================\n"</span>)</span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    df2 = np.transpose(df1)</span><br><span class="line">    sys.stdout.write(str(df2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择某两列进行画图</span></span><br><span class="line">    df1.plot.line()</span><br><span class="line">    plt.show()</span><br><span class="line">    <span class="comment"># 展示柱形图</span></span><br><span class="line">    df1.plot.bar()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A(第一步) --&gt; B(第二部)</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>路由器那些事</title>
      <link href="/2021/05/18/%E8%B7%AF%E7%94%B1%E5%99%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2021/05/18/%E8%B7%AF%E7%94%B1%E5%99%A8%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>二层交换机解决了同一个子网内的通信，当数据交换跨子网之后就需要借助路由器来完成，<strong>路由器的本质就是用来指导ip报文（并非mac报文）转发的设备</strong>。不同于交换机，路由器的每一个接口都包含了对应子网的ip（<strong>就是网关</strong>），并且各接口对应了不同的子网（ip不同），并且路由器包含了arp表项、<em>mac地址表(不确定，三层交换机应该是有的，路由器应该也有)</em>，本地路由表，更一般的，我们的个人pc其实就可以制作成一个路由器（虽然性能扛不住）。</p><h1 id="数据报请求流程"><a href="#数据报请求流程" class="headerlink" title="数据报请求流程"></a>数据报请求流程</h1><p>最后说明一下在有交换机、路由器同时存在的网络上进行数据包的转发的流程：</p><ul><li>当主机发送一个报文到指定的地址的时候，<strong>该主机</strong>会首先判断destip和sourceip是不是处于同一个网段(判断是否处于同一个子网可以简单的通过掩码和各自的ip按位进行与操作，如果得到的结果一致，那么就处于同一个子网，反之不处于同一个子网)</li><li>同一个子网<ul><li>同一个子网则发送arp广播报文获取目标ip的mac地址，中间的设备起到广播的作用</li></ul></li><li>不同子网<ul><li>当源设备和目标设备处于不同的子网的时候就会请求<strong>网关</strong>的帮助，发送arp的广播报文获取网关mac</li><li>填充网关mac然后单播过去，网关收到数据之后去掉二层头，获取对应的destip，然后查询路由信息表，从路由器中的本地路由表中<strong>获取出接口以及下一跳</strong></li><li>继续获取下一跳的mac地址并转发，如果达到目标网络（如何判断到达目标网络？判断nexthop的ip和目标ip同一个网段即可），则直接arp报文广播获取对应设备的mac，进而单播过去，二层直接找交换机要mac</li><li>接下来将会填充出接口的mac地址作为源地址，并填充下一跳接口的mac地址作为目标地址，上述流程持续进行至下一跳（nexthop）对应的ip地址和请求报文中的destip处于同一个子网为止，这样就会继续根据上面同一个子网的规则进行处理</li></ul></li></ul><p>当然上面过程中的设备都是包含了mac地址表，因此在获取到了对应的mac地址后是都会缓存到对应的设备上，这样后续就可以不再通过arp获取对应的mac地址了。</p><p>上面我们接触到了网关的概念，这是设备上配置的，不过更一般的相连的路由器之间可以认为是互为网关的，路由其中的路由表保存了彼此的信息，这也说明了路由的双向的特点。</p><h1 id="路由表项的建立"><a href="#路由表项的建立" class="headerlink" title="路由表项的建立"></a>路由表项的建立</h1><ul><li><p>直连路由：直连路由要求设备连线连好，并且要求ip配置好即可</p></li><li><p>静态路由：</p><ul><li>配置方法：<code>ip route-static ip（目标网络ip）mask（目标掩码，指定全255可以精确匹配ip）  nexthopip（ip）</code>（preference 100优先级指定可选），可以自动匹配出口。</li><li>display ip routing-table protocol static 查看全部的静态路由配置项（有些低优先级的路由如果不加上protocol static是不会出现的）</li></ul><p>  <strong>通常情况下是在路由器上配置缺省路由的，这样可以保证总会找到下一跳（在局域网中通常会使用nat出口作为网关，这样配置了缺省路由之后能保证大多数情况下局域网可以访问外网）只需要对应的ip和mask全部为0即可</strong></p></li><li><p>动态路由：OSPF算法，TODO待补充</p></li></ul><p>路由表项建立之后，对应的路由表中就包含了最优的路由表，路由在选择的时候，在去往相同的目的地址的路由条目中prefer、cost采用二次比较（越小越好）的方式来优选路由，如果两者相同，则会形成等价路由。另外一般路由表中也会存在一个缺省路由，缺省路由是目标网段和对应的掩码全0的特殊路由条目。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p><strong>在讲解使用场景之前，需要特别强调路由器不处理vlan信息，因此到达路由器的数据都是去除了tag的信息，但是路由器的子接口是可以处理vlan信息的（子接口更像是二层交换机上的A口，因为其会剥掉对应的vlan tag；同样三层交换机的vlan也更多的像是二层交换机的A口。在其后就是路由寻址转发的过程了，当然转发的过程）</strong></p><h2 id="一个三层设备连接不同的子网"><a href="#一个三层设备连接不同的子网" class="headerlink" title="一个三层设备连接不同的子网"></a>一个三层设备连接不同的子网</h2><h3 id="多臂路由"><a href="#多臂路由" class="headerlink" title="多臂路由"></a>多臂路由</h3><ul><li>场景：交换机连接了不同的子网，交换机之上存在一个<em>三层交换机或者路由器（不确定是什么）</em>，需要保证下面的不同vlan的子网互通</li><li>解决方案：配置二层交换机的用户侧和交换机侧都为A口即可，在配置A口的时候配置其对应的vlan即可</li></ul><p>优点：简单缺点：vlan不共享物理连接，浪费资源</p><h3 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h3><p>eth-trunk也是可以子接口的！！！！基于上述多臂路由的缺点，路由器提供了子接口的功能，并且子接口绑定了vlan，这样一个物理接口通过虚拟多个子接口，进而可以实现类似于多臂路由的功能。</p><ul><li><p>场景：同多臂路由，不过要求路由器只有一个接口供外部使用</p></li><li><p>解决方案：在一个接口上创建多个子接口，并单独配置子接口即可</p><ul><li><p>主机侧：  配置ip、掩码、网关（<strong>网关用下面创建的子接口的地址</strong>）</p></li><li><p>交换机：</p><ul><li>创建vlan</li><li>用户侧，配置A口</li><li>路由器侧配置T口，并允许A口对应的vlan可以通过</li></ul><p>  <strong>需要强调一点，创建A、T口都需要预先在交换机上创建vlan</strong></p></li><li><p>路由器侧配置多个子接口</p><ul><li><code>interface ethernet 0/1.xxx</code>（xxx为子接口编号，和用户vlan无关，另外这条命令在执行的时候，如果已经有了该接口则会直接进入，如果该接口不存在，则会创建并进入接口，总之接下来就可以配置子接口了）</li><li><code>vlan-type dot1q yyy</code>，这一步是配置该子接口的vlan为yyy，<strong>路由器才有子接口，交换机是不存在子接口的，因为接口需要ip</strong>，<strong>这样配置路由器的作用是当该子接口接收到对应vlan的报文的时候会去掉对应的tag，不过子接口的vlan只可以配置一个，不可以是多个</strong>。</li><li><code>ip address 用户侧网关地址（192.168.0.1） 用户侧掩码（255.255.255.0）</code></li><li>退出当前接口并继续创建和配置其他子接口（<strong>有多少个子网</strong>，就创建多少个子接口，因为子接口是作为子网的网关存在的）</li></ul><p>路由器上配置好之后，就可以通过<code>display ip routing-table</code>来查看对应的路由信息了，这个时候应该就可以看到该路由器上的路由表增加了<em>子接口的路由信息</em>。（？？？？TODO不确定是不是需要在子接口的创建过程中先创建vlan？？？？？）</p></li></ul></li></ul><h3 id="三层交换机做网关"><a href="#三层交换机做网关" class="headerlink" title="三层交换机做网关"></a>三层交换机做网关</h3><p>上述单臂路由中我们通过<strong>路由器</strong>子接口完成了不同子网的数据的转发，不过现实中还存在具备三层功能的交换机，这种交换机同时具备二层和三层的功能，因此通常情况下也是可以用作网关设备的（既然都提到网关了，那肯定是有ip的，既然有了ip了那肯定是实现的路由功能了）。</p><ul><li>解决方案：<ul><li>主机侧：配置ip、掩码、网关（就是下面路由功能配置的ip地址）</li><li>交换机：<ul><li>交换机功能配置：<ul><li><code>vlan batch x y</code> 创建交换机vlan</li><li>进入端口配置A、T口（通常用户侧就是A口）</li></ul></li><li>路由器功能配置<ul><li><code>interface vlanif x</code>（这里的x是前面配置交换机创建的vlan，接收去tag，发送加tag）</li><li><code>ip address ip地址 掩码</code>（这里的掩码和前面主机的网关是对应起来的）</li></ul></li></ul></li></ul></li></ul><p><strong>新加的交换机都需要配置vlan，并且新增的接口也都需要进行配置才可以使用</strong></p><h1 id="IDC网络配置"><a href="#IDC网络配置" class="headerlink" title="IDC网络配置"></a>IDC网络配置</h1><p>这里仅提供数据中心网络配置的思路：</p><ul><li>将主机和网关打通</li><li>打通路由器</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>三层交换机暂时先总结到这里，后面有时间再详细补充。<strong>强调一下二层交换、三层路由都是可以聚合端口的，并且三层路由聚合后是可以再进行子接口的拆分的</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>二层交换机那些事</title>
      <link href="/2021/05/18/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2021/05/18/%E4%BA%8C%E5%B1%82%E4%BA%A4%E6%8D%A2%E6%9C%BA%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络是分层的，我们通常所说的以太网是数据链路层的网络，这是因为以太是数据链路层面上的一种协议，其所对应的设备就是二层交换机，接下来看一下二层交换机的通信原理</p><h1 id="以太网二层交换机通信原理"><a href="#以太网二层交换机通信原理" class="headerlink" title="以太网二层交换机通信原理"></a>以太网二层交换机通信原理</h1><p>二层交换机在接收到主机发送的报文的时候会学习报文中的源mac地址，并在交换机上面的<strong>mac地址表</strong>中查找对应的目的mac地址所对应的端口，如果找不到就直接广播该报文。这其中包含了两个对象：主机、交换机。</p><ul><li>主机：会缓存arp表项（ip和mac地址的对应关系），可以使用arp -a来查看，通常情况下arp表项是动态的。</li><li>二层交换机：会缓存mac地址信息和端口的对应情况，不过其中不会包含对应的arp表项，因为arp表项是ip和mac地址的对应关系，很明显交换机并不具备ip信息。</li></ul><p>上面我们知道主机会缓存ip对应的mac信息，不过这些信息并不是从一开始就存在的，而是动态生成的，并且具有老化时间。arp表项的生成依赖于arp协议，这是从主机发送的广播报文（对应的目的mac为全f）。</p><p>上面的这种方式存在以下两种问题：</p><ul><li>当同一个子网内包含了较多的主机的时候，将会形成广播风暴</li><li>没有对单播的数据报文进行访问控制</li></ul><p>上述问题的解决依赖于以太网的vlan技术</p><h1 id="以太网vlan技术"><a href="#以太网vlan技术" class="headerlink" title="以太网vlan技术"></a>以太网vlan技术</h1><p>以太网的vlan技术是通过配置交换机的端口实现了同一个子网的不同组的划分，这样可以保证数据的交换只会发生在特定的区间内（并不一定是同组，跟端口类型有关系），从而减少了广播风暴，并且实现了单播报文的控制。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>以太网的vlan是通过在目的mac和源mac地址后面增加一定的字节用来标识该报文所属的vlan，交换机的端口将会处理和其相关的报文。这里有两个主体：报文、交换机端口，我们将会从交换机的端口出发，来深入了解一下端口对于报文的处理的逻辑：</p><ul><li><p>access口：</p><ul><li>接收报文处理规则：接收无tag的报文，此时会加上端口的pvid，接收的数据包含tag的时候只允许tag和pvid相等的情况</li><li>发送报文处理规则：只能够发送包含的tag和该接口对应的pvid相同的数据帧</li><li>配置端口命令：<ul><li>默认进入用户管理界面</li><li>使用 <code>system-view</code> 进入系统视图</li><li>创建<code>全局的vlan</code>，vlan batch 3 to 4，其中如果vlan不连续可以直接使用空格来表征(也可以vlan 4创建一个vlan)</li><li>配置端口vlan，需要先进入对应的端口，指定其对应的接口类型和pvid：<ul><li><code>interface Gb 0/0/1</code> (指定端口)</li><li><code>port link-type access</code>（指定端口类型）</li><li><code>port default vlan 3</code>(配置端口pvid) </li><li><code>diaplay this</code> 可以查看配置是否生效，最后可以quit退出</li></ul></li></ul></li><li>使用场景：通常使用在交换机和终端的链接的地方</li></ul></li><li><p>trunk口：</p><ul><li><p>接收报文处理规则：接收无tag的报文，此时会加上端口对应的pvid，接收的数据帧中包含的tag需要在该接口的<code>vlan-list</code>（起到了pvid的作用，不过范围更广了）中才接收，<strong>这一点和a口类似，只不过a口允许的是pvid，这里允许的是一个list</strong></p></li><li><p>发送报文处理规则：判断数据帧的tag是否在vlan-list中，如果在才处理，并且<code>和pvid相等，则去掉tag</code>并转发，如果和<strong>pvid不同则透传</strong>，这个是增强的A口的功能（A口不具备透传非pvid的情况）</p></li><li><p>配置端口命令：</p><ul><li>默认进入用户管理界面</li><li>使用 <code>system-view</code> 进入系统视图</li><li>配置端口vlan，需要先进入对应的端口，指定其对应的接口类型和pvid：<ul><li>进入端口：<code>interface Eth-trunk 1</code></li><li>配置端口类型： <code>port link-type trunk</code></li><li>配置vlan-list：<code>port trunk allow-pass vlan 4</code>（允许pvid为4的数据通过）</li></ul></li></ul><p>  <strong>值得注意的是这里并没有配置trunk的pvid，而是使用了系统默认的pvid，其实是可以的</strong></p></li><li><p>使用场景：通常用在交换机之间的数据交换，当vlan-list和pvid一致的时候trunk实现的就是access接口</p></li></ul></li><li><p>hybrid口：</p><ul><li>接收报文处理规则：如果数据报文是untag的报文就直接加上pvid，否则判断vlan-list中是否包含了该tag，是则接受，否则丢弃，可以看到这和trunk端口类似。</li><li>发送报文处理规则：接口发送报文的时候判断数据报文是否在vlan-list中，是才处理，否则不处理，对于是的情况如果数据帧中对应的vlanid在untag vlan-list中则剥去标签并转发，否则直接透传，<strong>可以看到这里增强了Trunk口的剥去pvid的规则</strong></li><li>配置端口命令：<ul><li>默认进入用户管理界面</li><li>使用 <code>system-view</code> 进入系统视图</li><li>配置端口vlan，需要先进入对应的端口，指定其对应的接口类型和pvid：<ul><li><code>interface xxx</code> 进入接口</li><li><em><code>undo port default vlan(解除vlan其他类型的限制，初始化可以不用作)</code></em></li><li><code>port link-type hybrid</code>，指定端口类型</li><li><code>port hybrid pvid vlan 3</code>，指定端口的pvid</li><li><code>port hybrid untagged vlan 3 to 5</code>，指定端口能处理的untag vlan-list</li></ul></li></ul></li><li>使用场景：一般是在A口和trunk都不满足的情况下使用，<strong>更一般的是用来实现不同vlan之间的通信（通过vlan的untag vlan-list实现，毕竟是要去不同vlan对应的标签的），而且通常应该是在主机侧，并不在交换机之间</strong></li></ul></li></ul><h1 id="以太网端口聚集技术"><a href="#以太网端口聚集技术" class="headerlink" title="以太网端口聚集技术"></a>以太网端口聚集技术</h1><p>以太网端口聚集技术用来实现端口的负载均衡、并可以实现链路的备份。</p><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法"></a>具体做法</h2><ul><li>默认进入用户管理界面</li><li>使用 <code>system-view</code> 进入系统视图</li><li><code>sysname xxx</code> 重命名设备</li><li><code>interface Eth-Trunk 1</code>，创建eth-trunk端口</li><li><code>trunkport GigabitEthernet 0/0/9</code>将指定接口添加到对应的eth-trunk中</li><li><code>interface Eth-Trunk 1</code> 进入eth-trunk端口</li><li><code>port link-type trunk</code>，配置ethtrunk类型并指定其vlan-list：<code>port trunk allow-pass vlan 4</code>或者<code>port trunk allow-pass vlan 3 5</code>添加也可以</li></ul><h1 id="以太网堆叠技术"><a href="#以太网堆叠技术" class="headerlink" title="以太网堆叠技术"></a>以太网堆叠技术</h1><p>TODO 省略</p><h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><p>display mac-addressdisplay this save</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程读书笔记</title>
      <link href="/2021/04/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/04/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>并发一直以来是面试的重难点，从事java开发也有几年的经验了，但是并发这一块一直都是软肋，有幸同事建议看一下王宝令的极客时间，收获颇丰。我们从并发编程中存在的问题入手，并来一步一步的分析解决这些问题所用到的方法，最后引出并发编程真正的执行者：线程。</p><p>并发编程可以从三个方面来划分：</p><ul><li>分工：宏观上的分工，即如何给线程安排任务</li><li>同步：分配给线程的任务之间有依赖的关系，如何保障线程按照编排的顺序来执行</li><li>互斥：线程在执行任务的时候可能会涉及到多个线程访问共享变量的情况，如何保障线程执行的正确性就需要对共享变量的互斥访问，其中互斥访问又可以分成两种方案<ul><li>有锁互斥</li><li>无锁互斥</li></ul></li></ul><p>整体划分如下： </p><p><img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/zhengti.png" alt></p><p>个人理解，同步的一种特例就是互斥：通过互斥使得线程按照特定的顺序执行。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>并发编程出现问题的根源在于：</p><ul><li><p>原子性：由于计算机硬件之间运行的速度不匹配，因此计算机在操作系统软件的层面形成了分时的系统，由此而引入的问题是在高级语言层面上看起来是一步执行完的操作，在cpu指令上则拆分了多个操作，一个真正的操作可能是会在切换了多个线程之后才执行完。如下图所示：<img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/yuanzi.png" alt></p></li><li><p>可见性：由于计算机硬件之间运行的速度不匹配，除了在操作系统的层面上通过分时充分保障cpu被充分使用外，还引入了cpu对应的缓存来平衡硬件运行速度的差异。线程在执行的时候会先将主存数据加载到cpu对应的缓存，对于具备多核的cpu则会针对主存数据形成多份拷贝，如果不同的线程对数据进行了修改，其修改操作并不是直接修改主存中的数据，而是修改的cpu缓存中的数据，这样对于其他线程来说该修改操作就是不可见的，如下图所示：<img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/kejian.png" alt></p></li><li><p>有序性：编译器、处理器为了优化性能，在保证单线程正确执行的前提下，有时候会调整程序的先后顺序，调整的目的无非是为了充分使用缓存，但是这些调整仅仅保障了单线程下执行正确，并无法保障多线程下操作的正确。比较经典的一个例子是双重检测来创建单例：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">  static Singleton instance;</span><br><span class="line">  static Singleton getInstance()&#123;</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">      synchronized(Singleton.class) &#123;</span><br><span class="line">        if (instance == null)</span><br><span class="line">          instance = new Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通常见到的这种单例的写法看起来很完美了，不过很遗憾，这里还是存在一些问题：指令重排带来的问题，假定一个线程进入到<code>instance = new Singleton();</code>这一步了，但是创建对象的操作并非原子操作，因此可能会出现先开辟一块内存，指向instance，此时instance就满足部位null的情况，然而对象却还没有来的及初始化，因此这种情况下我们直接返回的对象是存在问题的对象。</p><p>综上：缓存导致的可见性问题，线程切换带来的原子性问题，编译优化带来的有序性问题，java引入了内存模型来解决这几个问题，内存模型解决了可见性、有序性的问题，而原子性的问题则是由互斥来解决的</p><h3 id="java内存模型（非jvm）"><a href="#java内存模型（非jvm）" class="headerlink" title="java内存模型（非jvm）"></a>java内存模型（非jvm）</h3><p>java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法，具体点就是volatile、synchronized、final关键字以及happens-before规则。</p><ul><li>volatile：volatile通过禁用缓存解决了可见性的问题，这样volatile的读写都是操作的主存（但是没有解决原子性的问题，也就是当针对volatile执行非原子操作的时候要特别注意），<strong>另外volatile是针对引用的可见性，并不是引用内部字段的可见性，因此对于一般的对象，即使使用了volatile来修饰也没有办法保证其所包含字段的可见性的</strong>。除了解决可见性问题之外，在jdk1.5之后volatile对其做了功能性的增强，具体参见happens-before原则</li><li>final：代表对应的字段是不可变的，对于基本类型来说就是值，普通对象就是引用的值。<em>final通常是用在构造函数中对值进行初始化，在使用final关键字的时候需要注意的就是指针逃逸的情况，虽然我们知道final代表的字段是不变的，不过如果我们在构造函数中将当前对象赋值给全局的静态变量则可能会由于指令重排导致对象还没有来得及真正的初始化就直接暴露出来了</em>。因此严禁在构造函数中将对象的引用暴露出来，这样很可能能会造成指针逃逸，具体代码演示如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">final int x;</span><br><span class="line">public FinalFieldExample() &#123; </span><br><span class="line">    x = 3; </span><br><span class="line">    y = 4; </span><br><span class="line">    // 此处就是讲this逸出， </span><br><span class="line">    global.obj = this;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><ul><li>成员变量为final时的初始化<ul><li>定义变量时候赋值</li><li>构造函数中赋值</li><li>构造代码块中赋值</li></ul></li><li>类变量为final时的初始化<ul><li>定义变量的时候赋值</li><li>静态代码块中初始化</li></ul></li></ul></li><li><p>happens-before规则：通过约束编译器优化的方式实现了前面操作的结果相对于后续的操作是可见的（个人感觉有判断条件的规则才是真正的规则）</p><ul><li>程序顺序性规则：从单线程的角度来看程序前面对某个变量的修改操作一定对后续操作可见</li><li>对一个volatile变量的写操作，happen-before于对这个变量的读操作。这一个规则怎么看都像是禁用缓存的意思，好像是在强调volatile读到的总是最新的值，不过其真实的意思是在强调对volatile变量的操作禁用指令重排，这样前面双重检测的对象如果使用了volatile修饰了，那么就能够保障对象在写入内存的时候一定不会再是还没有来得及初始化的对象</li><li>传递性规则：A happen before B、B happen before C，则 A happen before C</li><li>管程中锁的规则：对一个锁的解锁happen before于后续对这个锁的加锁（java中对应的就是synchronized），java中的加锁是通过编译器帮忙实现的</li><li>线程start规则：线程A启动线程B，则子线程B可以看到父线程A在启动子线程B之前的操作（感觉这个和顺序性有点像，不过顺序性是单线程，这里是多个线程）</li><li>线程join规则：父线程A调用了子线程B的join方法，则子线程的操作happen before于该join方法，父线程会等待子线程执行完。一种通用的模式，经常会看到Thread.currentThread().join()出现在源代码中，这种是让主线程不退出，通过子线程持续对外提供服务的一种方式。</li></ul></li></ul><h3 id="原子性问题解决方案："><a href="#原子性问题解决方案：" class="headerlink" title="原子性问题解决方案："></a>原子性问题解决方案：</h3><p>前面的java内存模型解决了可见性和有序性的问题，不过并没有解决原子性的问题，在java中原子性问题的解决方案是采用管程的模型。管程对应的英文是Monitor，也可以叫做监视器，所谓管程是指管理共享变量以及对共享变量的操作过程，让他们支持并发，对应到java中就是管理类的成员变量以及成员方法，让其成为线程安全的类，这也是在任何语言中解决并发问题的关键。</p><h4 id="管程模型"><a href="#管程模型" class="headerlink" title="管程模型"></a>管程模型</h4><p>如下图所示为管程对应的模型：</p><p><img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/guancheng.png" alt></p><p>被封装的共享变量或者方法对外提供的统一的入口，入口处有一个等待队列，这个队列代表了管程的互斥的作用，其保证每次只有一个线程进入到该入口。管程同时引入了条件变量，每个条件变量对应了一个等待队列（区别于入口等待队列），这个等待队列用于实现管程的同步的作用，当线程在执行的时候发现某个条件不满足，就会进入该条件变量对应的等待队列，这个时候是允许其他的线程进入管程的（因为进入等待队列会释放其持有的锁）。当某个条件满足的时候，我们可以通知该条件变量对应的等待队列中的线程重新进入入口等待队列，发起抢锁的操作，<strong>抢锁失败之后对应的线程会重新进入条件变量的等待队列（这一点很重要）</strong>。</p><h5 id="管程实现范式"><a href="#管程实现范式" class="headerlink" title="管程实现范式"></a>管程实现范式</h5><p>java中选择的管程的模型是MESA，线程B在通知（<strong>是通知</strong>）完线程A条件满足的时候，线程B并不是立即释放锁并退出，而是会继续执行完接下来的操作，这就会引入一个问题，线程A在执行的时候发现条件又不满足了（<strong>或许其他线程又改变了这个条件使得之前满足的条件不再满足了</strong>），这样就引入了java中管程实现的特定的范式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(条件不满足) &#123; </span><br><span class="line">    wait();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于管程的实现，在jdk1.5之前提供的默认的管程的实现是synchronized，之后在并发编程包中提供了AQS框架实现的管程，其本质上统统是锁，接下来具体看一下相关的细节。</p><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p>synchronized是jdk提供的默认的管程的实现，默认只有一个条件变量，因此也只对应了一个等待队列。前面在介绍happens before的时候已经介绍了管程中锁的规则，加锁happen before于解锁之前，这是可见性和有序性的体现，除此之外其可以保证操作的原子性。synchronized可以用来修饰方法、代码块、对象。synchronized的加锁、解锁的过程自动进行的，javap反编译一下能够看到synchronized修饰的block前后分别会加上<code>monitor enter； monitor exit</code>，另外需要知道的是synchronized修饰静态方法的时候锁定的是当前的类，修饰的是非静态方法的时候，所定的对象是this。<strong>synchronized进行了锁膨胀的优化，有时间可以研究一下</strong></p><p><strong>锁对应的方法之间是具备可见性规则的，因为block的访问涉及到happen before的规则，<em>而对于无锁的方法，有锁的方法对共享变量的操作对其不一定可见</em>，要保障可见则需要对无锁的方法加锁，或者将共享资源禁用缓存，也就是使用volatile进行修饰，不过很遗憾，volatile修饰的变量只可以是基本类型，修饰的是普通对象的话还是有可能无法访问到普通对象的最新的值（当然加锁的话需要是同一把锁才可以）</strong></p><p>锁保障了原子性，并通过happens-before规则解决了可见性、有序性的问题，但是锁的使用也带来了死锁的问题：锁和其对应的资源之间的关系为1:N，其中N &gt;= 1，当锁保护的资源不相关的时候，可以用不同的锁保护不同的资源，这种锁叫做细粒度锁，细粒度锁可以提高并行度，是性能优化的一个重要手段。不过细粒度锁是可能会由于相互等待导致死锁出现，例如当一个业务依赖于两个不同的加锁操作的时候可能就会出现相互等待锁的释放而进入死锁的状态</p><h5 id="产生条件（从资源的角度来看）"><a href="#产生条件（从资源的角度来看）" class="headerlink" title="产生条件（从资源的角度来看）"></a>产生条件（从资源的角度来看）</h5><ul><li>互斥，共享资源X和Y只能被一个线程占用（锁的排他性）</li><li>占有且等待，线程A已经获得共享资源X，在等待共享资源Y的时候，<strong>不释放</strong>共享资源X</li><li>不可抢占，其他线程不能强行抢占已经其他线程占有的资源</li><li>循环等待，线程A等待线程B占有的资源，反之亦然</li></ul><p>只有在上面四个条件都发生的情况下，才会出现死锁；因此只需要破坏其中一个条件就可以避免死锁发生。</p><p>解决方案：</p><ul><li>破坏占用且（循环）等待条件，一次申请所有的资源，如果申请不到，快速失败即可</li><li>破坏不可抢占条件，java语言层面提供的synchronized无法破坏这个条件，Lock可以解决这个问题（TODO 如何解决的）</li><li>破坏循环等待条件，对资源进行排序，获取资源失败就快速失败即可</li></ul><p>破坏占用且等待的条件中一次申请所有的资源，通常采用的模式是忙等带，在并发量很低的情况下，这种做法没有什么问题，一旦并发量上来之后，这种循环等待的方案就不合适了，比较好的方案是采用<strong>等待-通知</strong>的机制，如果线程要求的条件不满足，则线程阻塞自身，进入等待状态，当条件满足的时候，通知等待的线程重新执行即可，这样做的好处是可以避免cpu的空转。（说明：即便上面是等待通知机制，可以将其理解为不是线程中的同步，而是互斥，也就是为了解决互斥带来的死锁问题）</p><p>占用且循环等待实施方案：</p><ul><li>忙等待：最常用的就是原子类中通过cas的操作来更新变量，这种方式的缺点是会消耗大量的cpu的计算资源</li><li>等待-通知：线程首先获取互斥锁，当线程要求的条件不满足的时候，释放互斥锁，进入等待状态（等待状态是释放了锁的状态，阻塞是还没有获取到锁的状态），当要求的条件满足的时候，通知等待的线程，重新获取互斥锁即可</li></ul><p>java中内置的synchronized配合wait、notify、notifyAll可以轻松实现等待通知的机制，其为管程的一种实现方式，如下图所示：</p><p><img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/dengdai.png" alt></p><p>当线程进入synchronized保护的临界区的时候，如果线程执行的条件不满足，那么是可以通过调用wait方法释放当前获取到的锁资源而进入等待的状态，在条件满足的时候可以通过notify或者notifyAll来唤醒等待队列中的线程，notify只能保证在唤醒的时刻条件是满足的，并且推荐使用notifyAll来实现线程的通知机制，这样是可以尽量保证线程的公平性的，因为notify是随机挑选一个线程进行唤醒，这很可能会导致有些线程永远不会被通知到。需要明确一点，这里的两个队列分别是阻塞队列和互斥锁的等待队列，被唤醒的线程只会是互斥锁的等待队列，而线程在不满足条件而进入阻塞队列之后，jvm线程调度操作只会从阻塞队列中选择线程。另外既然synchronized是管程的一种实现方式，那么其实现等待通知的机制必然也是上面所提到的范式。</p><p>另外需要强调的是尽量使用notifyAll而不是notify，这是为了防止信号的丢失：假设我们有资源 A、B、C、D，线程 1 申请到了 AB，线程 2 申请到了 CD，此时线程 3 申请 AB，会进入等待队列（AB 分配给线程 1，线程 3 要求的条件不满足），线程 4 申请 CD 也会进入等待队列。我们再假设之后线程 1 归还了资源 AB，如果使用 notify() 来通知等待队列中的线程，有可能被通知的是线程 4，但线程 4 申请的是 CD，所以此时线程 4 还是会继续等待，而真正该唤醒的线程 3 就再也没有机会被唤醒了。</p><p>上面提到了wait的使用，因此顺便提一下wait和sleep的异同：</p><ul><li>不同点<ul><li>wait会释放锁而sleep不会释放锁资源，也正因为如此wait只能在同步方法和代码块中使用，而sleep可以在任何场景中使用</li><li>wait无需捕捉异常，而sleep需要捕捉。</li></ul></li><li>共同点：<ul><li>都会让渡cpu执行时间，等待再次被调度</li></ul></li></ul><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>接下来通过<strong>等待-通知</strong>的机制来实现一个同步阻塞队列：//TODO</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>上面介绍了并发编程中存在的问题，以及解决这些问题而引入的一些概念、方案，并衍生出新的问题以及新问题的解决方案，接下来我们看一下并发编程的真正的执行者：线程吧。需要说明一下，线程其实包含了两种层次的线程，一种是编程语言级别的线程，一种是操作系统级别的线程</p><h3 id="通用线程生命周期"><a href="#通用线程生命周期" class="headerlink" title="通用线程生命周期"></a>通用线程生命周期</h3><p>通用的线程生命周期包含了：</p><ul><li>初始状态：编程语言级别的线程被创建、未被分配cpu</li><li>可运行状态：操作系统级别的线程被创建，可以分配cpu</li><li>运行状态：有空闲的cpu，并且被分配给可运行状态的线程</li><li>阻塞状态：当线程等待某个事件的时候（管程对应的条件变量），线程就会转换到休眠的状态，同时会释放cpu，等到等待的事件满足，该线程被唤醒之后就会从阻塞状态转变成可运行状态</li><li>终止状态： 线程正常执行完或者执行的过程中异常结束，终止状态的线程将不会再转换成其他的状态</li></ul><p>如下图所示：</p><p><img src="//southrivers.github.io/2021/04/02/并发编程读书笔记/xiancheng.png" alt></p><h3 id="java线程生命周期"><a href="#java线程生命周期" class="headerlink" title="java线程生命周期"></a>java线程生命周期</h3><p>区别于通用线程生命周期，java中线程的生命周期对部分状态进行了合并及拆分，最终如下：</p><ul><li>初始状态：同上，编程语言级别的线程被创建，操作系统级别的线程并没有创建，对应到语言就是new一个thread</li><li>运行状态：运行状态是上面的可运行与运行状态的合并，只要调用线程对象的start方法就可以了</li><li>阻塞状态：线程在使用synchronized修饰的方法的时候，由于互斥的原因，进入入口队列中等待的状态</li><li>等待状态<ul><li>无限等待状态：<ul><li>在synchronized修饰的方法中调用了wait的方法会导致线程进入到无限的等待状态中</li><li>Thread.join方法的调用，主调线程将会等待被调线程执行完之后才可以继续执行，这时候主调线程就会进入无限的等待状态中</li><li>LockSupport.park方法的调用会使得调用这个方法的线程陷入无限的等待状态中，当调用unpark方法之后又可以将线程唤醒</li></ul></li><li>限时等待状态：<ul><li>无限等待状态中的加入时间参数</li><li>调用Thread.sleep方法</li></ul></li></ul></li><li>终止状态：线程正常执行完或者执行过程中抛出异常的时候就会导致线程终止，当我们希望在执行的过程中直接终止线程，可以使用interrupt方法，不推荐使用stop等方法，这些方法会导致线程持有的锁无法释放。</li></ul><p>前面我们提到的线程终止方案的时候有提到interrupt，现就对其简要介绍：interrupt会给线程发送一个通知，不过线程在接收到该通知的时候，可以选择处理也可以选择忽略，当线程处于运行状态的时候，线程可以直接通过isInterrupted() 方法来检测是否收到中断的通知，并进行相关的处理处理该通知，不过当线程处于等待状态的时候，不管是等待状态的哪一种状态，都会使得线程抛出异常，并且需要强调的是在抛出异常之后该中断标记位会复位，因此我们如果希望正常的处理这个通知，是需要在捕获异常之后进行重新的置位，通用的模式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread th = Thread.currentThread();</span><br><span class="line">while(true) &#123;</span><br><span class="line">  if(th.isInterrupted()) &#123;</span><br><span class="line">    break;</span><br><span class="line">  &#125;</span><br><span class="line">  // 省略业务代码无数</span><br><span class="line">  try &#123;</span><br><span class="line">    Thread.sleep(100);</span><br><span class="line">  &#125;catch (InterruptedException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节主要是介绍了并发编程中的锁、线程相关的知识，接下来将会介绍并发编程常见的工具类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>raft总结</title>
      <link href="/2021/01/31/raft%E6%80%BB%E7%BB%93/"/>
      <url>/2021/01/31/raft%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>分布式一致性协议应该是分布式系统中最重要的基石了，但凡涉及到分布式相关的技术都必然绕不开这个话题。根据cap理论可知分布式一致性有两种形态：</p><ul><li>最终一致性</li><li>强一致性</li></ul><p>不过<strong>分布式一致性</strong>中的<strong>一致</strong>究竟应该如何理解，我其实是一直有疑问的。最早我的理解是假定是分布式系统是一个状态机，那么<strong>所有节点中的状态时刻都一致</strong>，这就叫做状态一致性。我尝试说服我自己就是这样的，但是分布式系统必然存在节点之间的通信，通信带来的延迟必然会导致状态的不一致，而如果状态一致之后才对外可用，那么新的问题又来了，我怎么样知道你和我一致呢？我们知道网络中存在丢包和延迟的情况，如果真是要所有的节点达到一个一致的状态之后才可用，那么必定会在效率上大打折扣。另外一点<strong>可用是什么意思</strong>我也一直无法理解。在翻越了大量的资料之后，也学习并查看了比较经典的分布式一致性算法诸如：paxos、raft，最终有了一个猜测，<strong>与其说这些算法叫做分布式一致性算法，不如说叫做分布式共识算法</strong>。<strong>分布式一致性强调的是一致性，也就是内部状态一致，是针对一个集群，而分布式共识强调的是共识，是对外部的提议达成共识，这本身存在两个集群或者说系统（提议集群、决策集群，在极端的情况下提议集群和决策集群可以是一个集群，这就是内部的leader选举的过程），不过在决策集群达成共识的时候，决策集群的内部的状态可能并不是一致性的状态，只需要大部分节点的状态一致即可，这里的大部分就涉及了另外一个名词：quorum</strong>。之所以大部分一致而不是所有节点的状态一致，原因是可以提高容错，毕竟如果集群中有一个节点不可用，就会导致集群不可用，那么和只有一个节点对外提供服务有什么区别呢？</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>下面进入我们的正题：raft协议介绍，需要强调一下：</p><ul><li><strong>raft集群中的节点需要有一半以上可用，如果没有一半以上的节点可用，那么整个集群无法对外提供服务（这个在异常分析的时候尤其重要）</strong>。</li><li><strong>当日志复制遇到问题之后，不用改在日志复制的角度尝试解决，而是将其归入leader异常选举的情况，这样就可以顺利的化解问题。</strong></li></ul><p>raft协议的实现可以分为以下几个部分：</p><ul><li>leader选举</li><li>日志的复制</li></ul><h2 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h2><p>leader的选举存在两种情况：</p><h3 id="正常选举"><a href="#正常选举" class="headerlink" title="正常选举"></a>正常选举</h3><p>在服务初始化的时候，假设还没有用户端的请求过来，这个时候，集群中的节点会自动随机完成leader的选举，不过这种情况比较简单，因为还没有涉及到客户端的日志。</p><h3 id="异常选举"><a href="#异常选举" class="headerlink" title="异常选举"></a>异常选举</h3><p>首先可以肯定的是所有的节点是都可以参与leader选举的，不过其他节点在给参与投票的节点投票的时候可以选择投或者不投，选择投不投票的原则则显得尤为重要了：</p><ul><li>如果节点已经投过了，则不可以再投</li><li>在收到投票请求的时候会比对两个参数：任期term以及日志的最后一个索引的大小看，通过这种二次比较可以选择投票或者不投票给这个节点，我们知道一旦日志被应用到多数的节点，那么必然会有一半以上的节点日志是最新的，而其他的节点在发起选举的时候，要求这个节点给他选票的时候就可以发现日志最新条件不满足了，最终这半数以上的节点会投反对票，基线情况就是剩下的不到一半的节点全部投了赞成票，即便是这个样子，赞成票的总数也还是没有达到一半以上，因此这种决议就会失败。</li></ul><p>上述leader选举的过程中整个服务对外是会存在一个不可用的状态的，但是，不是一直不可用（至少选举刚发出的这个时刻有可能是可用的）。</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>在选出来leader之后，接下来就是对外提供服务了，raft是采用状态机的方式对外提供服务的。具体点就是：日志+状态机，日志有点类似预写日志的方式，而状态机则是将日志中的命令执行，可以知道在初始状态一致并且按照相同的顺序执行了相同的命令的命令的话，那么分布式服务对外呈现的状态一定是一致的，这里的一致是指用于决策的分布式对外达成了共识，并且内部也进入了一致的状态。</p><p>日志的处理过程分为以下几个阶段：</p><ul><li>leader接收客户端的请求（如果是follower接收到请求的话，会将这个请求路由转发到leader）</li><li>在leader记录日志之后（uncommitted），将该请求转发到所有的follower节点</li><li>follower在收到leader发过来的请求的时候会同样记录到日志中（uncommitted），同时会给leader发出响应</li><li>leader在接收到客户端的响应之后会判断quorum个数的节点是否都响应了，如果响应的话，此时leader中的消息会进入committed状态，同时leader会通过消息告诉其他的follower节点，你们可以提交了。</li></ul><p>上述整个流程执行下来尤其和2pc提交相似，不过不同的是，上述过程并不要求所有节点都成功复制日志，只要有半数以上的节点即可。需要强调一点只有committed后的消息才会被应用到状态机。接下来我们分析一下上述过程中可能存在的问题：</p><ul><li>leader在接收到请求后直接挂了，此时会进入选举leader的状态，因此这个过程我们将会统一归入到leader选举中</li><li>leader在接收到消息之后，并将请求转发到对应的follower上，此时follower可能由于某种原因没有办法给到服务端的响应，如果异常的follower个数未达到半数，此时服务可以继续对外提供（牢记半数以上的节点对外可用这个条件是整个服务可用的基础）；如果异常的follower达到半数，则直接返回失败给客户端。那已经被记录的消息将会一直存在于集群中，不过由于follower的消息是uncommitted的状态，因此消息不会被应用到状态机，整个系统对外一致。（再次出现leader选举也不会应用这种uncommitted的日志）</li><li>leader在接收到半数的服务发过来的响应之后，就会将对应的消息进行committed，并返回客户端成功commit的消息，如果此时leader发生了宕机，或者说leader在发出了部分（少于半数）follower的commit消息之后就出现了宕机：<ul><li>leader应用了日志到状态机中，但是没有给客户端成功发送响应，此时客户端会等待服务端重新选举出来leader，要么由新的leader告知其结果，要么进入fast fail状态</li><li>leader应用日志到状态机中，并且返回客户端成功的响应，但是在leader给follower commit消息的时候挂了此时会进入leader的选举中：<ul><li>leader在选举中忽然复活了</li><li>leader在新的节点成为新的leader的过程中一直处于死亡状态</li></ul></li></ul></li></ul><p>最后一种情况是比较复杂的，不过出现这种情况意味着leader需要重新选举，我们只需要保障leader的选举是安全的，就可以保证最终的状态是一个可预知并且是正确的。</p><p>上面的情况可以分析得知leader的安全选举才是真正的核心</p><h2 id="异常问题"><a href="#异常问题" class="headerlink" title="异常问题"></a>异常问题</h2><h3 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h3><p>当集群所在的网络出现分区之后，主节点形成一个小的集群，其他的节点形成一个大的集群的时候，大的集群会通过选主选出来新的leader，不过由于原来的leader还在运行（leader不会主动下线），这样就会导致整个集群出现两个leader，两个leader由于网络故障，互相之间不知道彼此存在，不过客户端和两个leader之间可能是可以联通的，这样形成的整体上的非对称网络分区就会导致客户端看起来有两个leader，在执行一些操作的时候，会发现由于leader的闪烁导致结果不可预测。出现这种问题的之后可以通过下掉旧的leader的方式来解决（需要在节点的程序自己实现，记录最近是不是还有follower心跳是ok的）</p><h3 id="日志复制异常"><a href="#日志复制异常" class="headerlink" title="日志复制异常"></a>日志复制异常</h3><p>当选出来的leader提交了不是自己任期的日志的时候（这里的提交是commited，集群中大多数都有某个日志条目），可能会在提交的过程中down机，最终新出来的leader会把这些认为是提交了的日志给覆盖掉，最终会导致集群可能已经被应用到状态机的日志又被删除，最终集群中的这么多节点之间出现不一致，这种问题的解决方案是，本任期的leader只提交当前任期的日志信息，其他的则通过递归的方式提交上去，只有在其他的日志都提交上去之后，当前任期的日志才最终提交上去，这种模式尤其类似于线程的join机制，让本任期的日志提交阻塞在提交其他任期的日志。这样就可以解决日志复制异常存在的问题。</p><h2 id="节点的动态变迁"><a href="#节点的动态变迁" class="headerlink" title="节点的动态变迁"></a>节点的动态变迁</h2><p>TODO</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>raft是简化版的paxos，原因是paxos的每一个过程都包含了类似于leader选举、达成共识两个阶段，而raft在leader选举完成之后，下一次服务不会再次进行leader选举，这样就把每个提议都要执行的两个步骤优化成了一个步骤了。另外我们经常听到的：DNS服务器就可以认为是采用最终一致性的模式来解释分布式一致性（共识）协议，我认为这种说法是不对的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 计算机网络相关</title>
      <link href="/2020/12/30/linux-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/12/30/linux-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>提起网络相关的内容，将其和操作系统进行关联起来是不合适的，不过鉴于我们能研究的网络相关的技术都是linux相关的内核子系统，因此姑且称之为linux 计算机网络吧。计算机网络中充斥着各种协议，我曾经试着翻了很多的资料，但给人的感觉都是浩如烟海。最近重新看了以下linux相关的书，略有心得，因此特别记录下。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="网络中的分层"><a href="#网络中的分层" class="headerlink" title="网络中的分层"></a>网络中的分层</h2><p>常见的网络分层的模型是七层模型或者是OSI开放系统互联模型，OSI将网络划分为4层，也是我们最常见的，具体如下：</p><ul><li>数据链路层：该层在收发数据的时候对应了局域网的mac地址，会将传输的数据切分成帧。mac地址可以认为是物理地址。</li><li>互联网络层：也就是IP层，其存在的目的是<strong>找到一条链路</strong>使得计算机彼此之间可以通信。网络层也会将数据切分为分组，并由接收端进行重组，我们可以将IP看作逻辑地址。</li><li>传输层：在两个建立了链路的计算机上，控制应用程序之间的数据传输，传输层的目的是在<strong>客户端和服务端应用程序之间建立链接</strong>，<strong>区别于找到链路</strong>，这里建立链接的前提肯定是存在一个链路，也就是IP层面上是通畅的，常用的传输层的控制协议就是TCP或者UDP。传输层使用端口号唯一的区分应用程序，服务端的端口号通常是固定的，客户端的端口号通常是动态生成的，并且每个端口对应的套接字缓冲区维护了几个队列。对于TCP协议来说，其还要保证通过这个链接的数据按照指定的顺序到达。</li><li>应用层：负责传输的实际内容</li></ul><p>这里首先强调以下，我们所说的网络分层都是协议层面上的，具体点反映到内核层面上的，即便是应用层，也是内核层面上的，如下图所示：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/OSI.png" alt></p><p>对应的结构在内核中反映为：<strong>不同的层次由分离的代码实现，不同层次的代码之间通过明确定义的接口来交换数据或者发送命令</strong>，简单来说可以近似认为协议即接口规范。</p><p>有个问题可能是我们比较纠结的，那就是既然有了Mac 地址为什么还需要IP地址，或者反过来，关于这个问题我也查了一下网上的说法，并结合自己的看法，主要原因有以下几点：</p><ul><li>IP地址必须是因为我们需要通过逻辑地址（IP地址）找到一条通往目标计算机的链路，通过MAC很显然无法高效找到对应的主机，除非网络中所有的主机的路由表中都存放了其他机器的mac地址，不过这显然是不可能的</li><li>既然有了IP地址，为什么还要多一个mac地址呢？这是因为局域网的通信是基于mac地址的，这样的说法或许没有什么说服力，试想一下，如果在局域网中存在dhcp的服务使得局域网中的主机ip可以动态的变更，那么如果使用IP来进行传输数据的话是不是可能会在某次的传输过程中出现差错呢？</li></ul><h2 id="内核网络子系统"><a href="#内核网络子系统" class="headerlink" title="内核网络子系统"></a>内核网络子系统</h2><p>区别于TCP/IP的分层（协议上的分层），内核网络子系统也是分层的结构，这些分层和TCP/IP的分层是对应起来的，可以认为是协议的具体的实现。</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/OSI.png" alt></p><p>图中可以知道，我们常说的<strong>各层传输协议都是存在于内核空间的，就应用层来说也是存在于内核空间的，虽然加了个应用</strong>。<strong>和分层相关的还有就是数据的传输</strong>。如下图所示：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/data.png" alt></p><p>其中在首部包含了描述数据段所使用协议的基本信息，方便数据在接收到之后的解析。</p><h2 id="套接字的由来"><a href="#套接字的由来" class="headerlink" title="套接字的由来"></a>套接字的由来</h2><p>在linux中遵循着一切皆文件的基本原则，正常的读写操作直接访问即可，但是对于网卡会有所例外，原因的话是无法在打开<strong>网卡</strong>的时候指定我们为了传输数据而使用的<strong>链接</strong>（<strong>网卡不是链接，网卡可以当作工厂，用来生产链接</strong>），也无法指定链接在各层中所使用的协议。因此内核需要提供一个通用的接口（并非网卡，该接口可以屏蔽网卡的差异引入的问题）来供程序访问访问网络，这就引申除了套接字。<strong>套接字用于定义和建立网络连接，屏蔽了底层的协议</strong>，套接字完成创建之后会得到一个inode，这样我们接下来就可以通过操作inode来完成网络数据的读写，这样我们又回归到了一切皆文件的主体。当然网卡承载了套接字的通信。</p><p><strong>套接字是通过系统调用由内核生成的</strong>，bind用于给当前这个套接字绑定地址。我们通常所说的<strong>阻塞、非阻塞是针对服务端来说的</strong>，并非针对客户端（针对客户端没什么意义的）。对于服务端来说建立一个socket需要三个函数：</p><ul><li>bind将套接字绑定到一个地址</li><li>listen通知套接字等待客户端连接请求的到来，该函数会创建一个队列，将所有希望建立链接的客户端放到这里，这里的队列以TCP队列为例，可以分为<ul><li>半链接队列：<a href="https://www.cnblogs.com/xiaolincoding/p/12995358.html" target="_blank" rel="noopener">TCP队列资料参考</a></li><li>全连接队列：</li></ul></li><li>accept用来接收等待队列上的第一个客户端的链接请求，队列为空的时候将处于阻塞的状态，直到有想要进行连接的客户端的到来（由listen将客户端放进来）</li></ul><p><strong>该过程中我们看到了队列，看到了等待，不过这并不是阻塞IO中的阻塞的含义，因为这个阶段还处于建立链接的过程，并没有发生文件的读写操作</strong>。上面的过程中最终会返回一个socket，该socket对应了一个文件描述符，接下来的通信就可以通过read或者write来操作这个文件描述符来完成了。而read或者write的才是阻塞IO中的阻塞的真正的含义。该socket是由监听的服务器fork出来的，并会注册到内核中（关于socket及其中的队列后文会进行描述）。</p><p>对于客户端主动关闭链接的情况，服务端会返回一个长度为0的数据流，这样服务端就可以终止数据的处理了。</p><h2 id="套接字缓冲区"><a href="#套接字缓冲区" class="headerlink" title="套接字缓冲区"></a>套接字缓冲区</h2><p>内核在收发数据的时候需要使用套接字缓冲区（socket buffer）来提升网络中收发数据的性能。其主要用来在网络实现的<strong>各个层次之间交换数据</strong>，这种数据的交换并不是基于复制而是基于指针引用的。其对应的结构如下：</p><p><strong>sk_buff是内核空间和用户空间公用的一个结构体，但是数据则涉及到拷贝，也就是内核空间和数据空间数据是存在拷贝的，内核的各层之间则不存在数据的拷贝，而是通过结构体中的指针</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">struct  sk_buff</span><br><span class="line">&#123;</span><br><span class="line">     struct  sk_buff *next;</span><br><span class="line">     struct  sk_buff *prev;</span><br><span class="line">     struct  sock *sock ; //struct sock是socket在网络层的表示，其中存放了网络层的信息</span><br><span class="line">     </span><br><span class="line">     unsigned  int  len; //下面有介绍</span><br><span class="line">     unsigned  int  data_len;  //下面有介绍</span><br><span class="line">     __u16   mac_len ;  //数路链路层的头长度</span><br><span class="line">     __u16   hdr_len ;  //writable header length of cloned skb</span><br><span class="line">     unsigned  int  truesize ;  //socket buffer(套接字缓存区的大小)</span><br><span class="line">     atomic_t users ;  //对当前的struct sk_buff结构体的引用次数；</span><br><span class="line">     __u32   priority ;  //这个struct sk_buff结构体的优先级</span><br><span class="line">     </span><br><span class="line">     sk_buff_data_t transport_header ;  //传输层头部的偏移量</span><br><span class="line">     sk_buff_data_t network_header ;    //网络层头部的偏移量</span><br><span class="line">     sk_buff_data_t mac_header ;        //数据链路层头部的偏移量</span><br><span class="line">     </span><br><span class="line">     char  *data ;  //socket buffer中数据的起始位置；</span><br><span class="line">     sk_buff_data_t tail ;  //socket buffer中数据的结束位置；</span><br><span class="line">     char  *head ;  //socket buffer缓存区的起始位置；</span><br><span class="line">     sk_buffer_data_t end ;  //socket buffer缓存区的终止位置；</span><br><span class="line">     </span><br><span class="line">     struct  net_device *dev;  //将要发送struct sk_buff结构体的网络设备或struct sk_buff的接收</span><br><span class="line">                             //网络设备</span><br><span class="line">     int  iif;   //网络设备的接口索引号；</span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     struct  timeval tstamp ;  //用于存放接受的数据包的到达时间；</span><br><span class="line">     </span><br><span class="line">     __u8  local_df : 1 ,   //allow local fragmentaion;</span><br><span class="line">           cloned   : 1 ,  // head may be cloned</span><br><span class="line">           ;</span><br><span class="line">     </span><br><span class="line">     __u8  pkt_type : 3 ,  //数据包的类型；</span><br><span class="line">           fclone   : 2,   // struct sk_buff clone status</span><br><span class="line">     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上结构所示套接字缓冲区通过其中包含的各种指针与一个内存区域相关联，如下图所示：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/sk_buff.png" alt></p><p>这里可以看到套接字缓冲区并不是真正的数据空间，其也是通过指针与一个内存空间相关联，该内存空间存在于内核之中。另外也可以知道sk_buff指向的内存空间对应了数据链路层面上的帧（毕竟对应的内存空间包含了各种协议头）。</p><p>套接字缓冲区的基本思想是通过指针的移动来增删协议首部，这样就避免了在各层中拷贝传递数据。接下来对上述结构体中的字段进行详细的描述：</p><ul><li>head、end指向数据在内存中的起始和截止的位置，这个区域可能大于实际的长度，因为在产生分组的时候并不能确定分组的长度，多长合适应该是和传输协议相关的（生产数据的时候会在意长度）。</li><li>data、tail指向协议数据区域的起始和结束位置</li><li>mac_header等各种header分别指向对应协议的首部</li></ul><p>基于如上的结构体可以看的出来，套接字缓冲区可以用于所有的协议类型，毕竟指针只一下协议头就完事了。对应协议相关的数据的提取则可以使用xxx_header函数完成，如tcp报文的提取可以使用tcp_header，这些函数都需要一个sk_buff的参数，并返回重新解释的数据。除了上述套接字基本成员外，还包含了用于处理相关数据以及管理套接字缓冲区自身的其他成员,如prev、next指针，这个是套接字缓冲区队列，分组数据放置在等待队列中（队列中的每一项似一个完整的数据）。其结构如下所示：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/sk_buff_queue.png" alt></p><h2 id="报文发送案例学习"><a href="#报文发送案例学习" class="headerlink" title="报文发送案例学习"></a>报文发送案例学习</h2><h3 id="数据结构概述"><a href="#数据结构概述" class="headerlink" title="数据结构概述"></a>数据结构概述</h3><p>内核和用户空间套接字之间的接口实现在c标准库中，使用了socketcall系统调用，对于<strong>程序使用的每个套接字</strong>而言，都对应了一个socket结构和一个sock结构，其中socket充当了到用户空间的接口，面向的是用户的应用程序，而sock充当了到内核空间的接口，面向的是内核进程（每个socket都包含了sock结构），其中对应的数据结构分别如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">struct socket</span><br><span class="line">&#123;</span><br><span class="line">     socket_state  state; // socket state</span><br><span class="line">      </span><br><span class="line">     short   type ; // socket type</span><br><span class="line">      </span><br><span class="line">     unsigned long  flags; // socket flags</span><br><span class="line">      </span><br><span class="line">     struct fasync_struct  *fasync_list;</span><br><span class="line">      </span><br><span class="line">     wait_queue_head_t wait;</span><br><span class="line">      </span><br><span class="line">     struct file *file;</span><br><span class="line">      </span><br><span class="line">     struct sock *sock;  // socket在网络层的表示；这个结构在套接字缓冲区中也有看到，其本质上就是套接字在内核空间的表示，放到这个结构中更多的是一种映射关系</span><br><span class="line">      </span><br><span class="line">     const struct proto_ops *ops;</span><br><span class="line">           </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type：指定所用协议类型的数字标识</li><li>state：表示套接字链接的状态，不过<strong>不同于TCP建联过程中的全联接、半连接</strong>，个人感觉意义不大，可以忽略</li><li>file：指向一个伪的文件实例，用于要接字通信</li></ul><p>上述套接字并未绑定任何的协议，而是通过proto_ops指针指向一个数据结构，该结构中包含了协议以及用于处理特定协议的函数，这也是linux中常见的模式了：（通过指针化将具体的实现交由特定的业务来实现，从而使得业务更通用）。</p><p>上述结构体中的sock字段对应了内核层面上的套接字，其结构对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">struct sock &#123;</span><br><span class="line">    struct sock_common  __sk_common;</span><br><span class="line">    #define sk_family       __sk_common.skc_family</span><br><span class="line">    #define sk_state        __sk_common.skc_state</span><br><span class="line">    #define sk_reuse        __sk_common.skc_reuse</span><br><span class="line">    #define sk_bound_dev_if     __sk_common.skc_bound_dev_if</span><br><span class="line">    #define sk_node         __sk_common.skc_node</span><br><span class="line">    #define sk_bind_node        __sk_common.skc_bind_node</span><br><span class="line">    #define sk_refcnt       __sk_common.skc_refcnt</span><br><span class="line">    unsigned char       sk_shutdown : 2,</span><br><span class="line">                        sk_no_check : 2,</span><br><span class="line">                        sk_userlocks : 4;</span><br><span class="line">    unsigned char       sk_protocol;</span><br><span class="line">    unsigned short      sk_type;</span><br><span class="line">    int         sk_rcvbuf;</span><br><span class="line">    socket_lock_t       sk_lock;</span><br><span class="line">    wait_queue_head_t   *sk_sleep;</span><br><span class="line">    struct dst_entry    *sk_dst_cache;</span><br><span class="line">    struct xfrm_policy  *sk_policy[2];</span><br><span class="line">    rwlock_t        sk_dst_lock;</span><br><span class="line">    atomic_t        sk_rmem_alloc;</span><br><span class="line">    atomic_t        sk_wmem_alloc;</span><br><span class="line">    atomic_t        sk_omem_alloc;</span><br><span class="line">    struct sk_buff_head sk_receive_queue;</span><br><span class="line">    struct sk_buff_head sk_write_queue;</span><br><span class="line">    int         sk_wmem_queued;</span><br><span class="line">    int         sk_forward_alloc;</span><br><span class="line">    unsigned int        sk_allocation;</span><br><span class="line">    int         sk_sndbuf;</span><br><span class="line">    int         sk_route_caps;</span><br><span class="line">    int         sk_hashent;</span><br><span class="line">    unsigned long       sk_flags;</span><br><span class="line">    unsigned long           sk_lingertime;</span><br><span class="line"></span><br><span class="line">    struct &#123;</span><br><span class="line">        struct sk_buff *head;</span><br><span class="line">        struct sk_buff *tail;</span><br><span class="line">    &#125; sk_backlog;</span><br><span class="line">    struct sk_buff_head sk_error_queue;</span><br><span class="line">    struct proto        *sk_prot;</span><br><span class="line">    struct proto        *sk_prot_creator;</span><br><span class="line">    rwlock_t        sk_callback_lock;</span><br><span class="line">    int         sk_err,</span><br><span class="line">                sk_err_soft;</span><br><span class="line">    unsigned short      sk_ack_backlog;</span><br><span class="line">    unsigned short      sk_max_ack_backlog;</span><br><span class="line">    __u32           sk_priority;</span><br><span class="line">    struct ucred        sk_peercred;</span><br><span class="line">    int         sk_rcvlowat;</span><br><span class="line">    long            sk_rcvtimeo;</span><br><span class="line">    long            sk_sndtimeo;</span><br><span class="line">    struct sk_filter        *sk_filter;</span><br><span class="line">    void            *sk_protinfo;</span><br><span class="line">    struct timer_list   sk_timer;</span><br><span class="line">    struct timeval      sk_stamp;</span><br><span class="line">    struct socket       *sk_socket;</span><br><span class="line">    void            *sk_user_data;</span><br><span class="line">    struct page     *sk_sndmsg_page;</span><br><span class="line">    struct sk_buff      *sk_send_head;</span><br><span class="line">    __u32           sk_sndmsg_off;</span><br><span class="line">    int         sk_write_pending;</span><br><span class="line">    void            *sk_security;</span><br><span class="line">    void            (*sk_state_change)(struct sock *sk);</span><br><span class="line">    void            (*sk_data_ready)(struct sock *sk, int bytes);</span><br><span class="line">    void            (*sk_write_space)(struct sock *sk);</span><br><span class="line">    void            (*sk_error_report)(struct sock *sk);</span><br><span class="line">    int             (*sk_backlog_rcv)(struct sock *sk,</span><br><span class="line">                    struct sk_buff *skb);</span><br><span class="line">    void            (*sk_destruct)(struct sock *sk);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述结构体中的__sk_common字段是套接字在网络层的最小的表示（可以认为是身份标识，不携带数据的那种，分组数据到来之后寻找数据对应的socket的时候会用到），其他的字段对应如下：</p><ul><li>sk_shutdown是一组标志位，SEND_SHUTDOWN and/or RCV_SHUTDOWN。</li><li>sk_userlocks， SO_SNDBUF and SO_RCVBUF。</li><li>sk_rcvbuf表示接收缓冲区的字节长度。</li><li>sk_rmem_alloc表示接收队列已提交的字节数。</li><li>sk_receive_queue<strong>表示接收的数据包的队列</strong>。</li><li>sk_wmem_alloc表示发送队列已提交的字节数。</li><li>sk_write_queue<strong>表示发送数据包的队列</strong>。</li><li>sk_sndbuf表示发送缓冲区的字节长度。</li><li>sk_flags，SO_LINGER (l_onoff)，SO_BROADCAST，SO_KEEPALIVE，SO_OOBINLINE。</li><li>sk_prot是指定的域内部的协议处理函数集，它是套接口层跟传输层之间的一个接口，提供诸如bind, accept, close等操作。</li><li>sk_ack_backlog表示当前的侦听队列。</li><li>sk_max_ack_backlog表示最大的侦听队列。</li><li>sk_type表示套接字的类型，如SOCK_STREAM。</li><li>sk_protocol表示在当前域中套接字所属的协议。</li></ul><p>由上面的结构体可知，每一个sock都对应了多个队列，不同的sock对应的队列也不同。除了上述字段之外，还有一些字段代表的是函数，这些函数将会在特定事件发生的时候被回调，具体可以根据名称来判断。</p><p><strong>三者之间的关系：socket—-&gt; sock —–&gt; queue（多个） ——&gt;sk_buff</strong>。<strong>其中socket是系统调用返回给用户的一个用来和网络打交道的句柄，存在于内核空间，sock则包含了多个队列，队列中的每一个元素都是sk_buff，sock用于实现和网络层面上的数据的交换。也存在于内核空间</strong> 以上结构体都是存在于内核空间，因此这里其实并不涉及数据的拷贝（未涉及到用户的应用程序）</p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/syscall.png" alt></p><p>socketcall系统调用可以通过虚拟文件系统进入内核，其最终会根据返回的inode像操作文件一样读写网络数据，这里我们提到的inode和上面的socket的映射关系是在这个系统调用的时候触发的sock_alloc系统调用完成绑定的，最终inode就像一层代理一样，真正的读写操作通过底层的socket所支持的操作来完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">static struct socket *sock_alloc(void)</span><br><span class="line">&#123;</span><br><span class="line">    struct inode *inode;</span><br><span class="line">    struct socket *sock;</span><br><span class="line"></span><br><span class="line">    inode = new_inode_pseudo(sock_mnt-&gt;mnt_sb);//创建一个inode，用于将sock和文件系统相关联</span><br><span class="line">    if (!inode)</span><br><span class="line">        return NULL;</span><br><span class="line"></span><br><span class="line">    sock = SOCKET_I(inode);//根据inode获取socket_alloc结构体中socket成员</span><br><span class="line">...</span><br><span class="line">    return sock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在真正的像操作文件一样来操作socket还需要一些准备工作，如bind、listen、创建套接字等，这些所有的套接字相关的操作都是通过sys_socketcall来进行分发处理的，对应的函数见上图。</p><p>socket创建流程图：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/socket_create.png" alt></p><p>前面也已经提到sock_alloc是用来将socket和inode进行绑定的，而最后一步sock_map_fd则为套接字创建一个伪文件，并为其分配一个文件描述符，将其作为系统调用的结果返回。</p><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><p>如下：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/recv.png" alt></p><p>将用于确定目标套接字的文件描述符传递到该系统调用，fget_light根据task_struct的描述符数组查找对应的file实例。sock_from_file则用来确定与之关联的inode，并通过SOCKET_I找到最终对应的套接字。接下来sock_recvmsg调用特定于协议的接收程序（通过指针指向的方式来指定接收程序）来完成数据的接收：</p><ul><li>如果接收队列（socket-&gt;sock-&gt;receive_queue）上有至少一个分组，则移除并返回该分组</li><li>如果接收队列为空，进程则使用wait_for_packet使自身进入随眠，直到有数据到达。数据到达之后回调函数就会被唤醒（<strong>通过中断来完成</strong>），接下来会使用move_addr_to_user将数据拷贝到用户空间</li></ul><p>上述过程中我们看到了阻塞的过程，这也是传统的BIO的模式</p><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/send.png" alt></p><p>如上所示，fget_light和sock_from_file根据文件描述符查找相关的套接字。发送数据则使用move_addr_to_kernel将数据从用户空间拷贝到内核空间，然后sock_sendmsg使用特定协议来生成一个分组数据转发到更低的协议层。（<strong>需要说明一下转发到更低的协议层则是通过head指针的移动来生成更低层级的报文，从而避免了多次拷贝</strong>）。</p><h3 id="传输层（将接收到的报文按照socket进行分组）"><a href="#传输层（将接收到的报文按照socket进行分组）" class="headerlink" title="传输层（将接收到的报文按照socket进行分组）"></a>传输层（将接收到的报文按照socket进行分组）</h3><p>两个基于IP的主要传输协议分别是UDP和TCP，我们来看一下UDP数据报文接收的过程：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/udp_sock.png" alt></p><p>如上演示了IP数据包在传输到UDP层面后报文的处理，简单的分析一下：</p><ul><li>__udp4_lib_lookup用于查找与目标匹配的内核内部的套接字sock（非socket，socket是面向应用层的），如果找不到这样的套接字，则会直接丢弃该报文。如果找到对应的套接字则将对应的报文放置到读经的队列，这个过程具体分为以下几个步骤：<ul><li>等待套接字交付数据的进程，一致在sk_sleep队列上睡眠（这个是数据交付前的一直存在的状态）</li><li>调用skb_queue_tail将包含数据的套接字缓冲区插入链表的末端</li><li>启用回调函数sk_data_ready通知等待在sk_sleep队列上休眠的进程，有数据到了</li></ul></li></ul><p>TCP数据报文的处理过程稍显复杂，具体可以分为：</p><ul><li>三次握手建立连接</li><li>数据流按序传输</li><li>四次挥手断开链接</li></ul><p>三次握手、四次挥手的过程已经在其他的章节有介绍过，因此这里不打算花篇幅来介绍了，数据传输的过程参考UDP的数据传输。</p><h3 id="网络层（接收报文，并未分组）"><a href="#网络层（接收报文，并未分组）" class="headerlink" title="网络层（接收报文，并未分组）"></a>网络层（接收报文，并未分组）</h3><p>网络层除负责接收和发送数据外，还负责在不直连的系统之间<strong>转发和路由分组</strong>，<strong>查找最佳的路由，并选择适当的网络设备来发送分组</strong>。鉴于每一种传输协议（UDP、TCP等）所支持的分组的长度不尽相同，IP协议也会将较大的分组切分成较小的单位，供接收方进行组合。接收分组数据的整体处理流程图如下：</p><p><img src="//southrivers.github.io/2020/12/30/linux-计算机网络/ip_dev.png" alt></p><ul><li>分组到达ip_rev之后，首先会做一些校验的工作</li><li>接着会调用一个netfilter，这个filter的功能是个切面的功能，提供了扩展的能力，我们常见的防火墙的功能就是基于此处实现的。</li><li>判断分组的目的地是本地还是远端计算机，是本地则直接传到传输层，否则转到互联网的输出路径上。<ul><li>交付到本地的传输层：<ul><li>分片组合：由于IP分组可能是分片的，因此这里需要将分片重新合并，对应的处理过程如下：<img src="//southrivers.github.io/2020/12/30/linux-计算机网络/ip_combine.png" alt>内核在一个独立的缓存中管理原本属于一个分组的各个分片，该缓存称之为分片缓存（fragment cache）。在缓存中，属于同一个分组中的各个分片保存在同一个队列中，直到所有的数据都到来，这里的缓存区别于sk_buff，此时还没有足以形成sk_buff的数据量（要分组数据到期之后才可以）。上面的过程中ip_find用于根据分片ID、原地址、目标地址等头参数找到一个分组，如果找不到就会新建一个分组，接下来就是使用ip_frag_queue将分组置于队列上。最后使用ip_frag_reasm将分片重新组合，并释放申请的分片缓存区域。</li><li>交付到本地传输层</li></ul></li><li>分组转发：大致可以分为以下三个过程<ul><li>寻找路由表</li><li>分组分片</li><li>路由准发<h3 id="网络访问层"><a href="#网络访问层" class="headerlink" title="网络访问层"></a>网络访问层</h3>最后这里介绍一下网络访问层，前面都是在内核子系统内部处理数据，并没有涉及到真正的网络设备，网络访问层通过与网卡的驱动程序协作完成计算机之间信息的传输。在内核的层面上，每一个网络设备都标示为net_device的结构体的实例。在分配并填充该结构的实例之后会将设备注册到内核。net_device结构包含了与特定设备相关的所有的信息，对应结构体如下：</li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">struct net_device</span><br><span class="line">   &#123;</span><br><span class="line">       //用于存放网络设备的设备名称；</span><br><span class="line">       char name[IFNAMSIZ];</span><br><span class="line"></span><br><span class="line">       //网络设备的别名；</span><br><span class="line">       char *ifalias;</span><br><span class="line"></span><br><span class="line">       //网络设备的接口索引值，独一无二的网络设备标识符；</span><br><span class="line">       int ifindex;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //这个字段用于构建网络设备名的哈希散列表，而struct net中的</span><br><span class="line">      //name_hlist就指向每个哈希散列表的链表头；</span><br><span class="line">      struct hlist_node name_hlist;</span><br><span class="line"></span><br><span class="line">        //用于构建网络设备的接口索引值哈希散列表，在struct net中的</span><br><span class="line">      //index_hlist用于指向接口索引值哈希散列表的链表头；</span><br><span class="line">      struct hlist_node index_hlist;</span><br><span class="line"></span><br><span class="line">      //用于将每一个网络设备加入到一个网络命名空间中的网络设备双链表中</span><br><span class="line">      struct list_head dev_list;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的标识符,其状态类型被定义在&lt;linux/if.h&gt;之中；</span><br><span class="line">      unsigned int flags;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的标识符，但对用户空间不可见；</span><br><span class="line">      unsigned short  priv_flags;</span><br><span class="line"></span><br><span class="line">      //接口硬件类型，在&lt;if_arp.h&gt;中定义了每一个接口硬件类型；</span><br><span class="line">      unsigned short type；</span><br><span class="line"></span><br><span class="line">      //网络设备接口的最大传输单元；</span><br><span class="line">      unsigned mtu;</span><br><span class="line"></span><br><span class="line">      //硬件接口头长度；</span><br><span class="line">      unsigned short hard_header_len;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的MAC地址；</span><br><span class="line">      unsigned char *dev_addr;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的单播模式</span><br><span class="line">      int uc_promisc;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的混杂模式；</span><br><span class="line">      unsigned int promiscuity;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的全组播模式；</span><br><span class="line">      unsigend int allmulti;</span><br><span class="line"></span><br><span class="line">      //secondary unicast mac address</span><br><span class="line">      struct netdev_hw_addr_list uc;</span><br><span class="line"></span><br><span class="line">      //list of device hw address;</span><br><span class="line">      struct netdev_hw_addr_list dev_addrs;</span><br><span class="line"></span><br><span class="line">      //hw broadcast address;</span><br><span class="line">      unsigned char broadcast[MAX_ADDR_LEN];</span><br><span class="line"></span><br><span class="line">      //multicast mac address;</span><br><span class="line">      struct dev_addr_list *mac_list;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        //网络设备接口的数据包接收队列；</span><br><span class="line">      struct netdev_queue rx_queue;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的数据包发送队列；</span><br><span class="line">      struct netdev_queue *tx;</span><br><span class="line"></span><br><span class="line">      //Number of TX queues allocated at alloc_netdev_mq() time</span><br><span class="line">      unsigned int num_tx_queues;</span><br><span class="line"></span><br><span class="line">      //Number of TX queues currently active in device;</span><br><span class="line">      unsigned int real_num_tx_queues;</span><br><span class="line"></span><br><span class="line">      //Max frame per queue allowned;</span><br><span class="line">      unsigned long tx_queue_len;</span><br><span class="line"></span><br><span class="line">        //网络设备接口的状态；</span><br><span class="line">      unsigned long state;</span><br><span class="line"></span><br><span class="line">      //网络设备接口的统计情况；</span><br><span class="line">      struct net_device_state states;</span><br><span class="line"></span><br><span class="line">      //用于执行网络设备所在的命名空间；</span><br><span class="line">      struct net *nd_net;     </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>net_device结构中大多数成员都是函数指针，执行与网卡相关的典型任务，这些函数是在网络设备注册的时候指定的，这在某种意义上有点类似于VFS，内核层面上提供接口，真正的交互则交给具体的网卡驱动来实现。</p><h4 id="接收分组"><a href="#接收分组" class="headerlink" title="接收分组"></a>接收分组</h4><p>分组数据到达的时间是不可以确定的，因此现代设备都使用中断来知会内核数据到了，网络驱动程序（特定于网卡的程序）对特定于设备的中断设置了相关的处理程序，每当数据到了之后就会回调该函数完成分组数据的处理。不过数据的具体处理出现两种策略：</p><ul><li>传统方法：中断实时处理，这种方式的缺陷是每当有数据过来的时候都会触发中断，进而可能会导致cpu忙于处理中断而无法真正有效的处理数据了</li><li>NAPI：第一个分组数据到来之后，驱动程序关闭中断请求通知，内核一直对数据进行处理，当没有数据到来之后再次开启中断请求，让内核接受中断。</li></ul><h4 id="发送分组"><a href="#发送分组" class="headerlink" title="发送分组"></a>发送分组</h4><p>在分组数据发送到目标计算机之前，首先会使用ARP的协议确定目标计算机的物理地址。由网卡的驱动程序来确定将要发送的分组放置到哪一个队列上。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于计算机网络的总结到此为止！来日方长，后面看有什么没有整理的再进行补充吧</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 进程管理和调度</title>
      <link href="/2020/12/27/linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/"/>
      <url>/2020/12/27/linux-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%92%8C%E8%B0%83%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>现代操作系统都是可以同时运行多个任务的，这里的任务我们称之为进程，可以划分的更细一点：即有线程（轻量级的进程），在操作系统的层面上进程和线程除了在内存空间上的区别之外并未其他区别，他们都是使用task_struct来进行描述的。既然同时运行多个进程，那么必然涉及的就是进程的管理、调度以及生命周期，最近查阅了相关的资料，姑且记之。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>进程是正在运行的程序，需要一些资源来完成自己的任务，其中包含了几个容易混淆的概念：</p><ul><li><p>进程和程序： 程序通常成为text段（在内存管理中有说明，就是进程的一块内存空间），进程除了包含text段外，还需要程序计数器、cpu寄存器、堆、栈、数据段等用来存放运行时信息。</p></li><li><p>进程和线程： 在linux下，线程也叫做轻量级进程，也需要一个task_struct来描述，两者的区别是线程没有自己独立的内存空间，线程是共享父进程的内存空间的。这里我们提到的<strong>task_struct就是描述进程的结构体</strong>。</p></li></ul><p>如下一张图来展示一下进程的内存空间分布：</p><p><img src="//southrivers.github.io/2020/12/27/linux-进程管理和调度/jcnckj.png" alt></p><p>上面是进程的资源的分布，不过这些资源需要一个结构来进行管理，管理这块内存空间的结构我们称之为<strong>进程控制块-也即是pcb（也可以叫做进程管理器）</strong>，pcb对应的数据结构就是上面的task_struct。进程控制块的主要作用如下：</p><ul><li>实现cpu的调度</li><li>在一定的策略下分配资源给进程（这里的资源应该是包含cpu的，上面只是调度）</li><li>实现进程同步和进程间的通讯</li><li>实现避免死锁策略和保护机制</li></ul><h2 id="进程创建和结束"><a href="#进程创建和结束" class="headerlink" title="进程创建和结束"></a>进程创建和结束</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><p>上面介绍了进程的一些基本概念，接下来我们来看一下进程的生命周期，在进入正题之前我们先看一下进程的状态（<strong>这里的进程的状态指用户进程的状态，并非内核进程的状态，或者通俗点说就是用户态进程的状态，而非内核态</strong>）。</p><ul><li>task_running：进程出于运行（系统当前的进程）或者准备运行状态（等待系统将cpu分配给它，已经具备了除cpu之外的所有的资源，不会因为其他的资源而陷入等待）</li><li>task_interruptable：等待某个条件如中断、信号、socket、信号量等资源（等待状态）</li><li>task_uninterruptable：<strong>进程处于睡眠状态，信号无法唤醒，只有wakeup才可以唤醒</strong>，这种情况不是太好理解，需要结合上面提到的是用户进程而非内核进程来进行理解，用户进程出于睡眠状态，比如读写外设的过程中，进程陷入内核态，用户进程在这个状态的时候就不可以被打断，否则可能出现意想不到的问题</li><li>task_stopped： 进程停止，进程收到响应的信号的时候就会进入该状态</li><li>task_traced： 进程执行被调试器停止，调试程序使用ptrace系统调用来监控程序，<strong>没有研究过</strong></li><li>exit_zombie： 俗称的墓碑状态，该进程已经结束，但是父进程还没有调用wait4或者waitpid返回当前进程的信息，此时<strong>进程描述符（task_struct）</strong>仍然存在</li><li>exit_dead：进程的最终状态，父进程调用wait4或者waitpid后，系统正在删除该进程，对应的进程描述符也会被销毁</li></ul><h4 id="状态转换过程中的异常"><a href="#状态转换过程中的异常" class="headerlink" title="状态转换过程中的异常"></a>状态转换过程中的异常</h4><p>接下来说一下进程状态转换的时候会出现的一些异常：</p><ul><li>僵尸进程：当进程在父进程还没有调用wait4或者waitpid的时候就退出了，那么该进程对应的进程描述符就没有办法销毁，引发的最终的问题就是内存的泄漏，不过进程描述符本身消耗的内存也不是太大。这种情况下只可以通过重启机器来重制这些进程</li><li>孤儿进程：当某个父进程退出的时候其子进程还在执行，这种情况下子进程会被init进程收养</li></ul><h4 id="进程状态转换示意图"><a href="#进程状态转换示意图" class="headerlink" title="进程状态转换示意图"></a>进程状态转换示意图</h4><p>最后来用一张图来描述一下进程状态转换：</p><p><img src="//southrivers.github.io/2020/12/27/linux-进程管理和调度/jczt.png" alt></p><h3 id="描述进程的结构体"><a href="#描述进程的结构体" class="headerlink" title="描述进程的结构体"></a>描述进程的结构体</h3><p>上面介绍了进程的状态之后，还需要介绍一下进程描述符，毕竟进程的创建就是生成这个进程描述符，每个进程的描述符包含了进程状态、地址空间、打开的文件、进程优先级等信息，如下我们看一下结构体：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line">struct task_struct &#123;</span><br><span class="line">    volatile long state;    /* -1 unrunnable, 0 runnable, &gt;0 stopped */</span><br><span class="line">    void *stack;</span><br><span class="line">    atomic_t usage;</span><br><span class="line">    unsigned int flags; /* per process flags, defined below */</span><br><span class="line">    unsigned int ptrace;</span><br><span class="line"></span><br><span class="line">    int lock_depth;     /* BKL lock depth */</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_SMP</span><br><span class="line">#ifdef __ARCH_WANT_UNLOCKED_CTXSW</span><br><span class="line">    int oncpu;</span><br><span class="line">#endif</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    int prio, static_prio, normal_prio;</span><br><span class="line">    unsigned int rt_priority;</span><br><span class="line">    const struct sched_class *sched_class;</span><br><span class="line">    struct sched_entity se;</span><br><span class="line">    struct sched_rt_entity rt;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_PREEMPT_NOTIFIERS</span><br><span class="line">    /* list of struct preempt_notifier: */</span><br><span class="line">    struct hlist_head preempt_notifiers;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * fpu_counter contains the number of consecutive context switches</span><br><span class="line">     * that the FPU is used. If this is over a threshold, the lazy fpu</span><br><span class="line">     * saving becomes unlazy to save the trap. This is an unsigned char</span><br><span class="line">     * so that after 256 times the counter wraps and the behavior turns</span><br><span class="line">     * lazy again; this to deal with bursty apps that only use FPU for</span><br><span class="line">     * a short time</span><br><span class="line">     */</span><br><span class="line">    unsigned char fpu_counter;</span><br><span class="line">#ifdef CONFIG_BLK_DEV_IO_TRACE</span><br><span class="line">    unsigned int btrace_seq;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    unsigned int policy;</span><br><span class="line">    cpumask_t cpus_allowed;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_TREE_PREEMPT_RCU</span><br><span class="line">    int rcu_read_lock_nesting;</span><br><span class="line">    char rcu_read_unlock_special;</span><br><span class="line">    struct rcu_node *rcu_blocked_node;</span><br><span class="line">    struct list_head rcu_node_entry;</span><br><span class="line">#endif /* #ifdef CONFIG_TREE_PREEMPT_RCU */</span><br><span class="line"></span><br><span class="line">#if defined(CONFIG_SCHEDSTATS) || defined(CONFIG_TASK_DELAY_ACCT)</span><br><span class="line">    struct sched_info sched_info;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    struct list_head tasks;</span><br><span class="line">    struct plist_node pushable_tasks;</span><br><span class="line"></span><br><span class="line">    struct mm_struct *mm, *active_mm;</span><br><span class="line"></span><br><span class="line">/* task state */</span><br><span class="line">    int exit_state;</span><br><span class="line">    int exit_code, exit_signal;</span><br><span class="line">    int pdeath_signal;  /*  The signal sent when the parent dies  */</span><br><span class="line">    unsigned int personality;</span><br><span class="line">    unsigned did_exec:1;</span><br><span class="line">    unsigned in_execve:1;   /* Tell the LSMs that the process is doing an</span><br><span class="line">                 * execve */</span><br><span class="line">    unsigned in_iowait:1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /* Revert to default priority/policy when forking */</span><br><span class="line">    unsigned sched_reset_on_fork:1;</span><br><span class="line"></span><br><span class="line">    pid_t pid;</span><br><span class="line">    pid_t tgid;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_CC_STACKPROTECTOR</span><br><span class="line">    /* Canary value for the -fstack-protector gcc feature */</span><br><span class="line">    unsigned long stack_canary;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * pointers to (original) parent process, youngest child, younger sibling,</span><br><span class="line">     * older sibling, respectively.  (p-&gt;father can be replaced with</span><br><span class="line">     * p-&gt;real_parent-&gt;pid)</span><br><span class="line">     */</span><br><span class="line">    struct task_struct *real_parent; /* real parent process */</span><br><span class="line">    struct task_struct *parent; /* recipient of SIGCHLD, wait4() reports */</span><br><span class="line">    /*</span><br><span class="line">     * children/sibling forms the list of my natural children</span><br><span class="line">     */</span><br><span class="line">    struct list_head children;  /* list of my children */</span><br><span class="line">    struct list_head sibling;   /* linkage in my parent&apos;s children list */</span><br><span class="line">    struct task_struct *group_leader;   /* threadgroup leader */</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * ptraced is the list of tasks this task is using ptrace on.</span><br><span class="line">     * This includes both natural children and PTRACE_ATTACH targets.</span><br><span class="line">     * p-&gt;ptrace_entry is p&apos;s link on the p-&gt;parent-&gt;ptraced list.</span><br><span class="line">     */</span><br><span class="line">    struct list_head ptraced;</span><br><span class="line">    struct list_head ptrace_entry;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * This is the tracer handle for the ptrace BTS extension.</span><br><span class="line">     * This field actually belongs to the ptracer task.</span><br><span class="line">     */</span><br><span class="line">    struct bts_context *bts;</span><br><span class="line"></span><br><span class="line">    /* PID/PID hash table linkage. */</span><br><span class="line">    struct pid_link pids[PIDTYPE_MAX];</span><br><span class="line">    struct list_head thread_group;</span><br><span class="line"></span><br><span class="line">    struct completion *vfork_done;      /* for vfork() */</span><br><span class="line">    int __user *set_child_tid;      /* CLONE_CHILD_SETTID */</span><br><span class="line">    int __user *clear_child_tid;        /* CLONE_CHILD_CLEARTID */</span><br><span class="line"></span><br><span class="line">    cputime_t utime, stime, utimescaled, stimescaled;</span><br><span class="line">    cputime_t gtime;</span><br><span class="line">    cputime_t prev_utime, prev_stime;</span><br><span class="line">    unsigned long nvcsw, nivcsw; /* context switch counts */</span><br><span class="line">    struct timespec start_time;         /* monotonic time */</span><br><span class="line">    struct timespec real_start_time;    /* boot based time */</span><br><span class="line">/* mm fault and swap info: this can arguably be seen as either mm-specific or thread-specific */</span><br><span class="line">    unsigned long min_flt, maj_flt;</span><br><span class="line"></span><br><span class="line">    struct task_cputime cputime_expires;</span><br><span class="line">    struct list_head cpu_timers[3];</span><br><span class="line"></span><br><span class="line">/* process credentials */</span><br><span class="line">    const struct cred *real_cred;   /* objective and real subjective task</span><br><span class="line">                     * credentials (COW) */</span><br><span class="line">    const struct cred *cred;    /* effective (overridable) subjective task</span><br><span class="line">                     * credentials (COW) */</span><br><span class="line">    struct mutex cred_guard_mutex;  /* guard against foreign influences on</span><br><span class="line">                     * credential calculations</span><br><span class="line">                     * (notably. ptrace) */</span><br><span class="line">    struct cred *replacement_session_keyring; /* for KEYCTL_SESSION_TO_PARENT */</span><br><span class="line"></span><br><span class="line">    char comm[TASK_COMM_LEN]; /* executable name excluding path</span><br><span class="line">                     - access with [gs]et_task_comm (which lock</span><br><span class="line">                       it with task_lock())</span><br><span class="line">                     - initialized normally by flush_old_exec */</span><br><span class="line">/* file system info */</span><br><span class="line">    int link_count, total_link_count;</span><br><span class="line">#ifdef CONFIG_SYSVIPC</span><br><span class="line">/* ipc stuff */</span><br><span class="line">    struct sysv_sem sysvsem;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_DETECT_HUNG_TASK</span><br><span class="line">/* hung task detection */</span><br><span class="line">    unsigned long last_switch_count;</span><br><span class="line">#endif</span><br><span class="line">/* CPU-specific state of this task */</span><br><span class="line">    struct thread_struct thread;</span><br><span class="line">/* filesystem information */</span><br><span class="line">    struct fs_struct *fs;</span><br><span class="line">/* open file information */</span><br><span class="line">    struct files_struct *files;</span><br><span class="line">/* namespaces */</span><br><span class="line">    struct nsproxy *nsproxy;</span><br><span class="line">/* signal handlers */</span><br><span class="line">    struct signal_struct *signal;</span><br><span class="line">    struct sighand_struct *sighand;</span><br><span class="line"></span><br><span class="line">    sigset_t blocked, real_blocked;</span><br><span class="line">    sigset_t saved_sigmask; /* restored if set_restore_sigmask() was used */</span><br><span class="line">    struct sigpending pending;</span><br><span class="line"></span><br><span class="line">    unsigned long sas_ss_sp;</span><br><span class="line">    size_t sas_ss_size;</span><br><span class="line">    int (*notifier)(void *priv);</span><br><span class="line">    void *notifier_data;</span><br><span class="line">    sigset_t *notifier_mask;</span><br><span class="line">    struct audit_context *audit_context;</span><br><span class="line">#ifdef CONFIG_AUDITSYSCALL</span><br><span class="line">    uid_t loginuid;</span><br><span class="line">    unsigned int sessionid;</span><br><span class="line">#endif</span><br><span class="line">    seccomp_t seccomp;</span><br><span class="line"></span><br><span class="line">/* Thread group tracking */</span><br><span class="line">    u32 parent_exec_id;</span><br><span class="line">    u32 self_exec_id;</span><br><span class="line">/* Protection of (de-)allocation: mm, files, fs, tty, keyrings, mems_allowed,</span><br><span class="line"> * mempolicy */</span><br><span class="line">    spinlock_t alloc_lock;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_GENERIC_HARDIRQS</span><br><span class="line">    /* IRQ handler threads */</span><br><span class="line">    struct irqaction *irqaction;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    /* Protection of the PI data structures: */</span><br><span class="line">    spinlock_t pi_lock;</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_RT_MUTEXES</span><br><span class="line">    /* PI waiters blocked on a rt_mutex held by this task */</span><br><span class="line">    struct plist_head pi_waiters;</span><br><span class="line">    /* Deadlock detection and priority inheritance handling */</span><br><span class="line">    struct rt_mutex_waiter *pi_blocked_on;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_DEBUG_MUTEXES</span><br><span class="line">    /* mutex deadlock detection */</span><br><span class="line">    struct mutex_waiter *blocked_on;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">    unsigned int irq_events;</span><br><span class="line">    int hardirqs_enabled;</span><br><span class="line">    unsigned long hardirq_enable_ip;</span><br><span class="line">    unsigned int hardirq_enable_event;</span><br><span class="line">    unsigned long hardirq_disable_ip;</span><br><span class="line">    unsigned int hardirq_disable_event;</span><br><span class="line">    int softirqs_enabled;</span><br><span class="line">    unsigned long softirq_disable_ip;</span><br><span class="line">    unsigned int softirq_disable_event;</span><br><span class="line">    unsigned long softirq_enable_ip;</span><br><span class="line">    unsigned int softirq_enable_event;</span><br><span class="line">    int hardirq_context;</span><br><span class="line">    int softirq_context;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_LOCKDEP</span><br><span class="line"># define MAX_LOCK_DEPTH 48UL</span><br><span class="line">    u64 curr_chain_key;</span><br><span class="line">    int lockdep_depth;</span><br><span class="line">    unsigned int lockdep_recursion;</span><br><span class="line">    struct held_lock held_locks[MAX_LOCK_DEPTH];</span><br><span class="line">    gfp_t lockdep_reclaim_gfp;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">/* journalling filesystem info */</span><br><span class="line">    void *journal_info;</span><br><span class="line"></span><br><span class="line">/* stacked block device info */</span><br><span class="line">    struct bio *bio_list, **bio_tail;</span><br><span class="line"></span><br><span class="line">/* VM state */</span><br><span class="line">    struct reclaim_state *reclaim_state;</span><br><span class="line"></span><br><span class="line">    struct backing_dev_info *backing_dev_info;</span><br><span class="line"></span><br><span class="line">    struct io_context *io_context;</span><br><span class="line"></span><br><span class="line">    unsigned long ptrace_message;</span><br><span class="line">    siginfo_t *last_siginfo; /* For ptrace use.  */</span><br><span class="line">    struct task_io_accounting ioac;</span><br><span class="line">#if defined(CONFIG_TASK_XACCT)</span><br><span class="line">    u64 acct_rss_mem1;  /* accumulated rss usage */</span><br><span class="line">    u64 acct_vm_mem1;   /* accumulated virtual memory usage */</span><br><span class="line">    cputime_t acct_timexpd; /* stime + utime since last update */</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CPUSETS</span><br><span class="line">    nodemask_t mems_allowed;    /* Protected by alloc_lock */</span><br><span class="line">    int cpuset_mem_spread_rotor;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_CGROUPS</span><br><span class="line">    /* Control Group info protected by css_set_lock */</span><br><span class="line">    struct css_set *cgroups;</span><br><span class="line">    /* cg_list protected by css_set_lock and tsk-&gt;alloc_lock */</span><br><span class="line">    struct list_head cg_list;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FUTEX</span><br><span class="line">    struct robust_list_head __user *robust_list;</span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">    struct compat_robust_list_head __user *compat_robust_list;</span><br><span class="line">#endif</span><br><span class="line">    struct list_head pi_state_list;</span><br><span class="line">    struct futex_pi_state *pi_state_cache;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_PERF_EVENTS</span><br><span class="line">    struct perf_event_context *perf_event_ctxp;</span><br><span class="line">    struct mutex perf_event_mutex;</span><br><span class="line">    struct list_head perf_event_list;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_NUMA</span><br><span class="line">    struct mempolicy *mempolicy;    /* Protected by alloc_lock */</span><br><span class="line">    short il_next;</span><br><span class="line">#endif</span><br><span class="line">    atomic_t fs_excl;   /* holding fs exclusive resources */</span><br><span class="line">    struct rcu_head rcu;</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">     * cache last used pipe for splice</span><br><span class="line">     */</span><br><span class="line">    struct pipe_inode_info *splice_pipe;</span><br><span class="line">#ifdef  CONFIG_TASK_DELAY_ACCT</span><br><span class="line">    struct task_delay_info *delays;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_FAULT_INJECTION</span><br><span class="line">    int make_it_fail;</span><br><span class="line">#endif</span><br><span class="line">    struct prop_local_single dirties;</span><br><span class="line">#ifdef CONFIG_LATENCYTOP</span><br><span class="line">    int latency_record_count;</span><br><span class="line">    struct latency_record latency_record[LT_SAVECOUNT];</span><br><span class="line">#endif</span><br><span class="line">    /*</span><br><span class="line">     * time slack values; these are used to round up poll() and</span><br><span class="line">     * select() etc timeout values. These are in nanoseconds.</span><br><span class="line">     */</span><br><span class="line">    unsigned long timer_slack_ns;</span><br><span class="line">    unsigned long default_timer_slack_ns;</span><br><span class="line"></span><br><span class="line">    struct list_head    *scm_work_list;</span><br><span class="line">#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span><br><span class="line">    /* Index of current stored adress in ret_stack */</span><br><span class="line">    int curr_ret_stack;</span><br><span class="line">    /* Stack of return addresses for return function tracing */</span><br><span class="line">    struct ftrace_ret_stack *ret_stack;</span><br><span class="line">    /* time stamp for last schedule */</span><br><span class="line">    unsigned long long ftrace_timestamp;</span><br><span class="line">    /*</span><br><span class="line">     * Number of functions that haven&apos;t been traced</span><br><span class="line">     * because of depth overrun.</span><br><span class="line">     */</span><br><span class="line">    atomic_t trace_overrun;</span><br><span class="line">    /* Pause for the tracing */</span><br><span class="line">    atomic_t tracing_graph_pause;</span><br><span class="line">#endif</span><br><span class="line">#ifdef CONFIG_TRACING</span><br><span class="line">    /* state flags for use by tracers */</span><br><span class="line">    unsigned long trace;</span><br><span class="line">    /* bitmask of trace recursion */</span><br><span class="line">    unsigned long trace_recursion;</span><br><span class="line">#endif /* CONFIG_TRACING */</span><br><span class="line">    unsigned long stack_start;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有点长，这也是从其他地方拷贝过来的。里面大致包含了以下几种信息：</p><ul><li>标识符：描述本进程的唯一标识符，用来区别其他进程</li><li>状态：任务状态，推出代码，退出信号等</li><li>优先级：相对于其他进程的优先级</li><li>程序计数器：程序中即将被执行的下一条指令的地址</li><li>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li><li>上下文数据：进程执行时处理器的寄存器中的数据</li><li>I/O状态信息：包括显示的I/O请求，分配的进程I/O设备和进程使用的文件列表</li><li>记账信息：可能包括处理器时间总和，使用的时钟总和，时间限制，记帐号等</li></ul><h3 id="进程结构体内存分布"><a href="#进程结构体内存分布" class="headerlink" title="进程结构体内存分布"></a>进程结构体内存分布</h3><p>由于下文会涉及进程调度相关的内容，因此这里强调以下，task_struct中同样包含了进程队列指针，所有进程均有各自的PCB。且各个PCB会串在一起，形成一个双向链表。其next_task和prev_task就表示上一个或下一个PCB，即前后指针。进程链表的头和尾都是0号进程。对应的指针如<em>next_task，</em>prev_task，当然还有更多的指针，接下来我们用一张图来演示一下这个结构：</p><p><img src="//southrivers.github.io/2020/12/27/linux-进程管理和调度/task_struct.png" alt></p><p>进程对应的结构体如上所示，这种结构体被thread_info所指向，下图描述了thread_info、进程内核栈、task_struct之间的关系：</p><p><img src="//southrivers.github.io/2020/12/27/linux-进程管理和调度/linux_p_stck.png" alt></p><p>这里需要说明一下，内核会给每个进程分配8k的内存，用来存储thread_info结构和内核栈，<strong>内核栈</strong>是由于进程在内核态运行的时候需要自己的堆栈来保存一些变量，这个栈不同于用户态进程所用的栈。另外thread_info是由于针对不同的平台，我们访问的方式不尽相同，thread_info封装了通用的逻辑来访问task_struct</p><p>上面说明了进程相关的结构体，值得注意的是在上图中其实还包含一个esp指针，该指针是cpu栈的指针，用来存放栈顶单元的地址。这样我们就可以将进程在cpu上调度的整体流程给串起来了：esp指针 -&gt; thread_info -&gt; task_struct -&gt; 进程运行时信息（包含调度等），至此就可以通过时钟中断定期去驱动对应的进程执行。</p><h3 id="进程调度队列相关"><a href="#进程调度队列相关" class="headerlink" title="进程调度队列相关"></a>进程调度队列相关</h3><p>进程调度还涉及的一个概念就是队列了，当下的计算机一般都是多cpu、多核，每个cpu都对应了<strong>运行队列、等待队列</strong>：</p><ul><li>运行队列：当调度新的进程在cpu上运行的时候，内核只会从task_running队列上取，内核中建立了多个可运行进程链表（也就是说一个cpu对应了多个链表），每种优先级的进程对应了一个链表，根据进程优先级划分的话，大概可以分为以下三种：<ul><li>实时进程队列（0-99）</li><li>交互进程</li><li>批处理进程（后台进程）</li></ul></li><li>等待队列： 等待队列在内核中有很多的用处，如中断处理、进程同步、定时任务。</li></ul><p>接下来描述以下进程创建的关系，进程创建子进程的时候会出现父子关系，当一个进程创建多个进程的时候，被创建的进程之间就会产生兄弟关系。进程0（内核初始化的时候捏造出来的init_task，名字为swapper）和进程1（通过 kernel_thread创建出，最终会调用exec(/sbin/init)）是内核创建的，其中进程1是所有进程的祖先。</p><p>task_struct中包含的real_parent、parent、children、sibling就是用来描述进程中之间的这种关系，需要说明的是real_parent和parent大部分情况下都是相同的，只有进程在调试的时候parent会指向调试进程的task_struct。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>前面铺垫了这么多就是为了引出进程的创建，一般情况下子进程在创建的时候是会复制父进程的所有的资源的，但是拷贝父进程的整个地址空间其实是一个非常缓慢的过程，因此在实际的情况中存在一些优化技巧：</p><ul><li>写时复制（copy on write）：父子进程共享读的页面，两者中任一进程尝试写一个物理页面的时候，内核就把这个页的内容拷贝到一个新的物理页，并把这个新的页面分配给这个写的进程</li><li>轻量级进程：这种情况允许父子进程共享很多内核数据结构，如页表、打开的文件表等信息</li></ul><p>上面是进程在创建完成之后的一些优化的技巧，不过真正的创建是需要一系列的系统调用完成的，具体过程如下：</p><ul><li>fork： fork其实只是一个统称，作用就是复制父进程的结构，真实的情况包含以下几种：<ul><li>clone：这种情况可以将资源选择性的复制给子进程，而没有复制的数据结构则通过指针的复制让子进程共享，极端情况下会创建出一个<strong>线程</strong>（不复制任何资源只通过指针进行共享）</li><li>fork： 父进程的所有资源都复制给子进程，区别上面的clone，fork是没有参数的，毕竟不给选择复制的机会</li><li>vfork： <del>与fork的作用相同，也是不带参数的。不过vfork不会拷贝父进程的页面表</del>，出task_struct和堆栈之外，均通过指针进行遗传，一次vfork出来的是线程而非进程，这是不传参数的另一种极端</li></ul></li><li>exec： 这个时候子进程会加载真正的程序并运行</li></ul><p>上面提到的fork的主体是copy_process，执行完copy_process之后，子进程开始运行，copy_process对应的功能如下：</p><ul><li>调用dup_task_struct，<strong>创建一个新的内核栈、新进程的thread_info、task_struct结构体，结构体中的成员变量的值和当前进程的相同，此时父子进程的描述符是相同的</strong></li><li>检查子进程是否超过当前用户资源限制</li><li><strong>此时需要将子进程和父进程区别开来，进程描述符成员变量将会被清除，并设置初始值</strong>，此时子进程处于task_uninterruptible，确保子进程不会被立即执行（毕竟还有初始化的工作没有完成）</li><li>调用copy_files来更新task_struct中的flags：pf_forknoexec：表示进程还没有调用exec等</li><li>调用get_pid分配一个pid给子进程</li><li>根据clone的标志，copy_progress共享或者复制打开的文件、文件系统信息、信号处理方式、命名空间以及进程地址空间</li><li>接下来将剩余的时间片在父子进程之间进行平分</li><li>最后copy_progress执行完成之后就将子进程的指针返回给调用者，毕竟父子进程之间是存在一个挂载的关系：也即是父进程中存放了一个指向子进程的指针</li></ul><p>上面就是进程创建的详细流程，在copy_progress成功返回之后，wake_up_new_task会将新创建的进程放到当前cpu的运行队列上面，这样子进程就可以被调度执行了。在子进程创建完成后父进程可以选择退出、分开运行或者等待子进程运行结束在运行。</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><ul><li>进程状态转换的时候：进程进入sleep、exit等函数进行状态转换，这些函数会主动调用调度程序进行进程调度</li><li>当前进程的时间片用完：进程的时间片是由时钟中断来更新的</li><li>进程从中断、异常、系统调用返回到用户态的时候：进程在返回到用户态的时候都会调用ret_from_sys_call，这个函数会主动调用调度程序进行进程的调度，原因是由于状态转换需要花一定的时间，因此，在返回到用户态前可以把内核态该处理的事情处理完</li></ul><p>具体的调度过程就是采用一定的策略从cpu的runqueue中选择一个进程来运行，其中进程调度器会涉及的函数如下：</p><ul><li>scheduler_tick：保持当前进程的time_slice为最新</li><li>try_to_wake_up：唤醒一个睡眠的进程</li><li>recalc_task_prio：更新进程的动态优先级</li><li>schedule：选择一个新的进程来运行</li><li>load_balance：使多处理器系统中的runqueue尽量平衡</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>到此大概完成了进程的基本分析，参考文章： <a href="https://www.cnblogs.com/cuckoo-/p/10966158.html" target="_blank" rel="noopener">https://www.cnblogs.com/cuckoo-/p/10966158.html</a></p><!-- 可以好好看一下内核线程和进程有什么关系，进程是否对应了多个内核线程？？？？？ -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 虚拟文件系统</title>
      <link href="/2020/12/17/linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/12/17/linux-%E8%99%9A%E6%8B%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在linux中，一切皆文件。我们平时见到的各种类型的文件存储诸如ext2、ext3、fat32等等，对于上层的用户进程来说是一种统一的视图，上层应用程序无需关心底层文件系统的具体实现，因为操作系统在内核层面上做了统一：对上层的用户进程提供了统一的接口。类比我们学过的设计模式，这个就有点像是代理了，也即是真正的实现有很多种，不过对外提供统一的接口。而在内核中完成这部分工作的就是虚拟文件系统了。如下图所示，虚拟文件系统在整个系统中的层级：</p><p><img src="//southrivers.github.io/2020/12/17/linux-虚拟文件系统/vfs.png" alt></p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>接下来我们将依次从磁盘存储结构、基本概念、数据结构、以及针对文件的操作入手来详细的了解一下虚拟文件系统，在此之前需要强调一下不管是内存还是磁盘，其均是通过块来划分存储空间的，使用的时候也是以块为基本单位进行使用的。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h3><p>超级块又叫做super block，通常可以称之为<strong>文件卷控制块</strong>，是存储了文件系统控制信息的结构，描述了文件系统的状态、类型、大小、索引节点、区块数、空余块等信息，存放于磁盘特定的扇区。文件卷控制<strong>块</strong>的特点是每个文件系统只有一个。</p><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>索引节点又叫做inode，通常也可以称之为<strong>文件控制块</strong>，其中包含了文件的详细信息，诸如文件的访问权限、拥有者、大小<strong>数据块位置</strong>等信息。对比与超级块，这里的索引节点是每个文件一个。</p><h3 id="目录-amp-amp-文件"><a href="#目录-amp-amp-文件" class="headerlink" title="目录&amp;&amp;文件"></a>目录&amp;&amp;文件</h3><p>文件是一组在逻辑上连续的信息项，包括我们常见的文件、套件字、设备等都是文件的一种，而目录好比一个文件夹，在linux操作系统中，目录是被当作一种特殊的文件的，用于文件的操作同样可以用在目录上，要知道在linux系统中，一切皆文件！</p><h3 id="目录项"><a href="#目录项" class="headerlink" title="目录项"></a>目录项</h3><p>在文件路径中，路径中的每一项都是一个目录项，如我们常见的<strong>/home/xyz/z.txt</strong>中，/、home、xyz、z.txt均由一个目录项来代替，区别于上面的内容，目录项表示的是内存空间中的一种数据结构。</p><h2 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h2><p>上面介绍了一些基本的概念后，我们来看一下这些基本的概念在实际的物理存储设备上的分布及使用情况：</p><p><img src="//southrivers.github.io/2020/12/17/linux-虚拟文件系统/cpjg1.png" alt></p><p>如上图所示，索引块并非只有一个，而是一个数组，数组中的每一项和一个文件是对应起来的（也即是每一个文件对应了一个索引节点，这里的文件包含了真实的文件以及目录），其中记录了文件的访问属性、所有者、创建修改时间以及大小等内容，<strong>但是并不包含文件的名称</strong>。</p><p>数据块中记录了文件的名称和对应的节点号码，当然这里的数据块其实对应了文件、目录。上图中介绍了文件系统中磁盘块的具体结构，接下来通过一个例子来演示一下读取一个文件/etc/a.txt的过程：</p><p><img src="//southrivers.github.io/2020/12/17/linux-虚拟文件系统/wjfw.png" alt></p><p>如上，文件系统中数据块中包含的内容即是表中所示的内容，我们通过索引节点可以查到对应的目录项的（也即是数据节点），接下来通过数据节点中记录的信息，继续递归查找，最终找到文件，并获取文件的内容。可以看到文件系统中大量的使用了这种hashmap的数据结构。</p><h3 id="注册、安装文件系统"><a href="#注册、安装文件系统" class="headerlink" title="注册、安装文件系统"></a>注册、安装文件系统</h3><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>内核中维护了一个file_systems的链表，注册的过程相当于将被注册的文件系统类型进行初始化，并挂载到这个全局的链表中。对应的函数为registre_filesystem（struct file_system_type *fs），这里的file_system_type对应的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct file_system_type &#123;</span><br><span class="line">     //文件系统的名字</span><br><span class="line">     const char *name;</span><br><span class="line">     int fs_flags;//文件系统类型标志的bitmap</span><br><span class="line">     int (*get_sb) (struct file_system_type *, int,</span><br><span class="line">                const char *, void *, struct vfsmount *);//在安装文件时，会调用get_sb()从磁盘中读取超级块。</span><br><span class="line">     void (*kill_sb) (struct super_block *);//卸载文件系统时，会调用此函数做一些清理工作。</span><br><span class="line">     struct module *owner; //指向拥有这个结构的模块，如果一个文件系统被编译进内核，则该字段为NULL</span><br><span class="line">     struct file_system_type * next;//形成文件系统类型链表</span><br><span class="line">     struct list_head fs_supers;//同一种文件类型的超级块形成一个链表，fs_supers是这个链表的头</span><br><span class="line">      //相关锁</span><br><span class="line">     struct lock_class_key s_lock_key;</span><br><span class="line">     struct lock_class_key s_umount_key;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在注册完文件系统之后，file_system链表中就包含了上述的结构体，其中比较重要的应该就是get_sb方法了，这个方法会在接下来的安装的过程中使用，直接从待安装系统中读取超级块，一旦超级块被读入内存，这个文件系统就变的可用了。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>前面我们有提到过，虚拟文件系统提供了代理的作用（或者类似于java里面的SPI的机制），那么如何将真实的文件系统和VFS进行关联呢？这就涉及到文件系统的注册了，具体的过程是：</p><p>用户态的进程调用mount()命令指定<del>安装点（vfsmount）、安装的设备、安装的类型（此处名词不甚理解）</del>，mount系统调用在内核中的实现为sys_mount，该函数真实调用的是do_mount，获取安装点的目录项对象，然后调用do_add_mount方法，该函数首先创建一个新的安装点，如：”/“、”/dev”，最后调用graft_tree的方法将节点作为叶子与根目录树挂载起来，安装点的数据结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">struct vfsmount &#123;</span><br><span class="line">  struct list_head mnt_hash; //内核通过哈希表对vfsmount进行管理</span><br><span class="line">  struct vfsmount *mnt_parent; //指向父文件系统对应的vfsmount</span><br><span class="line">  struct dentry *mnt_mountpoint; //指向该文件系统挂载点对应的目录项对象dentry</span><br><span class="line">  struct dentry *mnt_root; //该文件系统对应的设备根目录dentry</span><br><span class="line">  struct super_block *mnt_sb; //指向该文件系统对应的超级块</span><br><span class="line">  struct list_head mnt_mounts;</span><br><span class="line">  struct list_head mnt_child;  //同一个父文件系统中的所有子文件系统通过该字段链接成双联表</span><br><span class="line">  int mnt_flags;</span><br><span class="line">  /* 4 bytes hole on 64bits arches */</span><br><span class="line">  const char *mnt_devname; /* Name of device e.g. /dev/dsk/hda1 */</span><br><span class="line">  struct list_head mnt_list;  //所有已挂载文件系统的vfsmount结构通过该字段链接在一起</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们以mount一个设/dev/hdb到/home目录为例，其mount的过程可以大致分为两个阶段：</p><ul><li>查找目录：我们会根据要mount的路径的名称，来找到对应的目录项，也即是dentry（或者说mountpoint：挂载点）</li><li>增加vfsmount：该过程首先会根据上面注册进来的file_system对象的get_super来创建该文件系统对应的超级块，接下来就是创建好一个vfsmount对象，并将其和上一步骤中找到的目录项进行关联起来。</li></ul><h4 id="文件类型、挂载点、超级块之间的关系"><a href="#文件类型、挂载点、超级块之间的关系" class="headerlink" title="文件类型、挂载点、超级块之间的关系"></a>文件类型、挂载点、超级块之间的关系</h4><p>前面简要的说明了文件系统的注册及挂载，接下来我们来展示一下上面提到的一些概念及其之间的关系：</p><p><img src="//southrivers.github.io/2020/12/17/linux-虚拟文件系统/gx.png" alt></p><p>如上图所示，在文件系统类型链表中，每一个节点代表一个文件系统类型，是唯一的（这意味着，如果同一种类型的文件系统如果挂载了多个，依然是只会存在一个文件系统类型，毕竟嘛，它是类型的概念而并非实例的概念），节点之间通过next指针相连，而super_block可以理解为文件系统的实例，是用来管理当前注册的文件系统的（这就有点类似于面形对象编程语言中的类和对象的关系了）。同一种类型的多个super_block则是通过s_instance组成了一个双向的链表。</p><p>每mount一个文件系统实例都会有一个mount点和超级块与其对应，mount节点是通过mnt_list链接起来的，超级块是通过super_list链接起来的，mount节点结构中有一个mnt_sb指向该节点上挂载的文件系统的管理对象，也即是超级块。</p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="进程访问文件系统"><a href="#进程访问文件系统" class="headerlink" title="进程访问文件系统"></a>进程访问文件系统</h3><p>提起进程，就不得不提起进程控制块PCB，其中包含了：进程状态，进程调度，进程标识符，进程通信，进程链接，时间和定时器，文件系统，虚拟内存信息以及页面管理信息，对称多处理机信息，上下文信息等，其中包含了一个重要的结构体：task_struct，该结构体中存放了进程的各种属性信息，保存了进程和其打开的文件之间的映射关系：</p><p><img src="//southrivers.github.io/2020/12/17/linux-虚拟文件系统/fw1.png" alt></p><p>当用户进程打开文件的时候，内核将会返回一个fd，用于实际的标示该文件，实际上对应了上图中fd执行的数组的下标，数组中对应的元素存放的是文件对象信息，文件对象中的f_dentry，指向了目录项，目录项中的d_inode则指向了真实的索引节点，索引节点和文件则是一一对应的，最终会指向数据节点，同时inode中也会记录该文件对应的操作函数。</p><h2 id="文件系统类型"><a href="#文件系统类型" class="headerlink" title="文件系统类型"></a>文件系统类型</h2><p>// TODO</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>虚拟文件系统的好处是，统一了用户程序的视图，似的</p><p>// 文件系统和对应的内存管理系统之间的关系</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux 内存管理</title>
      <link href="/2020/11/17/linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
      <url>/2020/11/17/linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>linux内存管理是内核较为复杂的一部分，抽时间看了一下书，查阅了一些资料并整理记录一下。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h2><p>linux内核将虚拟内存空间分为底部的用户空间和顶部的内核空间，对于这些内存的管理是内核中较为复杂的一部分，内核采用了<strong>段页式内存管理</strong>（这里的页其实是页表管理的机制）的机制来管理内存空间，程序在运行的时候读取到的地址是逻辑地址，经过段页式转换将得到线性地址，接着经过页表映射机制最终才会访问到具体的物理地址，如下图所示：</p><p><img src="//southrivers.github.io/2020/11/17/linux-内存管理/mem.png" alt></p><p>说明一下：</p><p>cpu在运行的时候，我们的程序以及运行所需的数据的逻辑地址是采用segment+offset的方式表征逻辑地址的，这里的逻辑地址会经过** GDT（全局描述符）<strong>映射为线性地址。而接下来会通过两张表：</strong>页目录表、页表**来完成物理地址的寻址。这里需要说明的是页目录表的层级并不是固定的。原因的话，我们可以试想一下在32位的操作系统上是否可以管理超过4G的内存空间呢？答案是可以的，不过32位的操作系统最大的物理寻址空间就是4G，如果想要管理更多内存的话，我们可以设置多级页目录表，这样就可以扩大寻址空间。不过这个过程需要借助高端内存来完成，不过当前应该是非主流的东西了（简单点来说可以将操作系统升级位64位并采用AMD64的cpu来硬升级），因此这里也没必要深究了。（需要说明的是linux内核是采用了四级页目录表的方式来管理内存的）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>在上面的流程中我们看到物理内存的寻址是经过了两次的映射，对于真实的linux内核来说，映射的层级可能会更多，至于为什么需要多级页表映射呢？</p><ul><li>对于早期的操作系统以及cpu芯片来说，都是32位的寻址空间，这样的机器可访问的最大的内存空间是4G，如果真实的物理内存大于4G，这样如果采用直接映射的方式就没有办法访问剩余的用户空间了，这时候如果我们在用户空间的特定区域存放一个二级索引（页目录表），这样就可以极大的扩展实际的内存访问空间</li><li>另外一个原因是安全，正如上面所说，操作系统会将内存空间划分成用户空间和内核空间，对于用户的程序来说，其实并不关心真实的物理地址，当我们的程序在运行的时候读到某条指令的时候，如果将逻辑地址空间直接转换成物理地址空间的话，那么我们的程序就可以直接操作真实的物理空间了，这将是一个可怕的问题，因此当前内核会增加一层映射的机制，来将转换得到的线性地址转换成真实的物理地址，从而达到隔离和控制用户进程访问内存物理空间的过程。</li></ul><p>页表映射是进程级的，每一个进程都会有一个独立的页目录表，这样也统一了进程访问物理地址的空间，让所有的进程在他们自身看起来分配得到的都是一个连续的内存空间，哪怕真实分配到的物理内存并不是连续的</p><!-- ## 其他计算机管理内存的方式大概有两种：![](linux-内存管理/uma.png)上面是在物理结构层面上内存管理的分类，不过linux内核已经统一了这两种内存的管理的接口，因此对于开发人员来说并不需要考虑上述两种情况，出于性能考虑，在给进程分配内存的时候，**内核**总是优先分配该内核关联的内存。对于NUMA方式的内存，每一个CPU都有一个独立的内存，并且通过总线串联起来，这样可以支持其他的cpu对本地内存的访问。理解这些对于linux内核访问内存空间将会比较有帮助 --><h2 id="进程虚拟内存"><a href="#进程虚拟内存" class="headerlink" title="进程虚拟内存"></a>进程虚拟内存</h2><p>上面我们知道程序在运行的时候使用的是虚拟内存空间，也说明了虚拟内存空间的必要性和好处。接下来我们来看一下进程虚拟内存空间的管理和使用，先来一睹为快，我本地启动一个centos的docker进程来观察一下终端对应的进程的内存的划分情况，我们知道<strong>linux操作系统中一切皆文件</strong>，因此进程的虚拟内存的也是可以查看的：</p><p><img src="//southrivers.github.io/2020/11/17/linux-内存管理/maps.png" alt></p><p>上面是进程地址空间的布局，通常可以将进程的内存空间分成以下组成部分：</p><ul><li>当前运行代码的二进制代码。该代码通常称之为text，所处的虚拟内存区域称之为text段</li><li>程序使用的动态库的代码。</li><li>存储全局变量和动态产生的数据的堆。</li><li>用于保存局部变量和实现函数/过程调用的栈。</li><li>环境变量和命令行参数的段。</li><li>将文件内容映射到虚拟地址空间中的内存映射</li></ul><p>linux操作系统是文件系统</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>参考视频资料：<a href="https://www.bilibili.com/video/BV1zt4y1U7rq?from=search&amp;seid=1532338745078214906" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1zt4y1U7rq?from=search&amp;seid=1532338745078214906</a>参考书：深入linux内核架构</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库锁的那些事</title>
      <link href="/2020/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2020/09/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>类比JAVA的并发编程，数据库的事务可以认为是java中的线程，线程的逻辑由很多的操作组成，其需要依赖锁来控制一些并发的资源的访问，这里的锁就是数据库里面的锁，对应的资源也可以认为是Java中的临界资源。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>锁的分类，按照模式可以将其分为</p><ul><li>共享锁</li><li>排他锁按照锁的颗粒度，可以将其分为</li><li>表锁、</li><li>页锁、</li><li>行锁<ul><li>记录锁</li><li>gap lock</li><li>next key lock</li></ul></li></ul><p>锁的行为和一下对象有关系</p><ul><li>锁定的对象</li><li>事务的隔离级别？？？？ 要考虑一下是否有关系？？？或者说事务的隔离级别应该是由锁来控制的？或者说事务的隔离级别可以通过锁来控制</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>最近在使用Spring batch的过程中发现了insert的过程中出现了死锁的情况，因此查了一下怎么回事，并在此总结一下数据库锁的分类及用法。</p><p>事务的隔离级别是由锁来进行控制的</p><p><a href="https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.6/en/innodb-locking.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARP小结</title>
      <link href="/2020/08/12/ARP%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/08/12/ARP%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在搞一些网络相关的东西，也有了解到其中的一些协议，因此也抽时间学习总结了一把，就先从ARP协议说起吧。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>ARP协议是用来实现IP到MAC之间的转换的一种机制，是属于网络层的一种协议（需要强调并不是数据链路层的协议），在OSI或者TCP/IP网络模型中，我们可以知道设备在同一个局域网中通信的时候使用的是MAC地址，不过通常情况下我们只知道目的主机的IP地址（_毕竟MAC地址很难记，即便是记住了，后面如果更换网卡的话，mac地址又会发生改变_）。以ping请求为例，在请求之初，由于原主机不知道目的主机的MAC地址，因此这种情况下就需要使用ARP协议来找到相应IP对应的MAC地址，解析出相应的地址之后，就可以封装二层的报文进行请求的发送了。接下来我们来看一下ARP在不同的网络拓扑中的一些情况：</p><h2 id="同网段ARP的实现"><a href="#同网段ARP的实现" class="headerlink" title="同网段ARP的实现"></a>同网段ARP的实现</h2><p>如下图所示，同网段内HostA向HostB发送数据报文为例：</p><p><img src="//southrivers.github.io/2020/08/12/ARP小结/local-arp.jpg" alt></p><ul><li>HostA查看自己的ARP表项发现找不到HostB的Ip和MAC的对应关系，于是HostA对外发送ARP报文，请求HostB的MAC地址，该报文中源IP和MAC为HostA的IP和MAC，不过目的IP和MAC则分别是目的IP和全0的MAC地址，我们知道全0的MAC地址代表的是广播数据。</li><li>DeviceB在收到HostA的数据报文之后，通过解析发现该报文是广播报文，就会在除了入口之外所有的端口广播该报文</li><li>HostB在收到报文之后，首先会更新自己的ARP表项用于记录HostA的IP和MAC的映射关系，同时向HostA发送ARP应答报文，在该应答报文中源IP和源MAC是HostB的IP以及MAC，目的IP和MAC则是HostA的IP和MAC</li><li>DeviceB收到该ARP响应报文之后会将该请求单播给HostA</li><li>HostA接收到ARP响应之后更新自己的ARP表项，接下来如果在有请求从HostA到B的话就会采用单播的方式发送出去了</li></ul><h2 id="不同网段间ARP的实现"><a href="#不同网段间ARP的实现" class="headerlink" title="不同网段间ARP的实现"></a>不同网段间ARP的实现</h2><p>上面我们分析了同网段的ARP协议，如果两台不同网段之间的设备进行通信的时候，发送的一方需要先将请求发送给默认网关，再由默认网关将数据报文转发给接收方主机的操作。因此不同的网段之间的ARP请求可以以网关作为分界线划分成多个相同网段之间的ARP的请求，如下图以HostA向HostC发送数据为例：</p><p><img src="//southrivers.github.io/2020/08/12/ARP小结/remote-arp.png" alt></p><ul><li>HostA查看自己的ARP表项发现没有到达目的主机HostC的默认网管DeviceA对应接口的IP和MAC地址的映射关系，于是HostA对外发送ARP请求报文，这个时候请求的MAC地址是DeviceA的mac地址（并不是HostC的地址）</li><li>DeviceB在收到该报文的时候发现MAC地址是全0，将会在本网络内广播数据接下来的过程就是DeviceA响应HostA的ARP请求并更新各自的ARP表项了，具体的过程和上面同网段ARP的实现一致，因此不再赘述了</li></ul><p>在接下来的请求知道了DeviceA的MAC地址之后，数据报文走到DeviceA的时候会根据内部的路由表将请求从interface2接口转发出去，这种情况下又变成了同一个局域网的ARP请求和响应了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面简要的介绍了一下ARP请求的过程，不过可以看的出来这种模式有一个缺陷，那就是如果网络上存在大量的广播的话会占用极大的贷款以及节点计算资源，后面有时间再补齐这些内容吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>calcite学习总结</title>
      <link href="/2020/08/07/calcite%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2020/08/07/calcite%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>当前的大数据框架中经常避不开的一件事情就是写写SQL，这些SQL有可能是针对hive、sparkSQL、Flink、Druid等，在学习这些框架的时候不由自主的会想到一个问题，SQL是怎么样转换成物理执行计划的呢？查了一下相关的资料可以发现这些服务都是使用一款叫做calcite的框架，工作之余也抽了点时间学习这个框架，更详细的学习可以参考<a href="https://calcite.apache.org/docs/index.html" target="_blank" rel="noopener">官网</a>，本文只是浅尝辄止，希望后面有工作可以使用到这些技能，这样就可以深入的学习一下了。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>calcite省略了数据的存储、元数据的存储以及数据的处理的过程，其主要的工作是完成SQL的解析、校验，查询的优化，执行查询。下图展示calcite的整体架构：</p><p><img src="//southrivers.github.io/2020/08/07/calcite学习总结/calcite-stu.png" alt></p><p>我们从客户端发起的请求看起，客户端发起的请求首先会到达server端，查询解析验证器首先会该查询转换为关系运算符树，由于calcite不含存储层，因此其提供了一种机制来通过适配器定义定义外部的table、schema、view，这样极大的提高了灵活性和扩展性。<del>calcite优化查询的过程依赖于规则、元数据，使用到了关系运算符树作为内部表现形式</del></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>https通信原理</title>
      <link href="/2020/07/24/https%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/"/>
      <url>/2020/07/24/https%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>http协议采用明文进行通信，数据在通信链路上可能被劫持或者篡改，为了解决这个问题，通常采用的手段是对数据进行加密，这也就引入了本文的主要讲解知识。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>所谓的对称加密是指加密和机密使用同一个密钥，这种加解密的操作又可以分为两种情况：</p><ul><li>密钥通过服务端颁发给客户端：这种情况下，我们需要将密钥从服务端传送到客户端，很显然，密钥在传输的过程中必然是以明文的方式进行传输的（如果是密文传输，很明显就是一个逻辑错误），这很明显会引发新的问题，如果密钥被截取了，那这个过程不就又成了明文传输了嘛，毕竟拿到密钥必然是可以对数据进行加解密了。</li><li>密钥以约定的方式分别存储在服务端和客户端：为了解决密钥以明文的方式在网络上传输，我们可以采用的方式就是不在网络上传输密钥，那么这就引出了第二中方案，那就是客户端和服务端约定密钥并分别存放到自己这里，不过很遗憾这样做依然有一个缺陷，那就是通常情况下客户端通常是公开的，比如可能是个浏览器，那么当我们把密钥保存在浏览器的时候，我们并没有办法保证密钥的安全性。</li></ul><p>如下图，演示对称加密的过程：<img src="//southrivers.github.io/2020/07/24/https通信原理/duichen.png" alt></p><p>综上可以知道，通过对称加密的方式没有办法彻底的解决数据被篡改的问题。</p><h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><p>上面我们分析了对称加密的原理以及安全性，对称加密安全性低的主要原因就是密钥的明文传输。为了解决这个问题引入了非对称加密。从名字上较对称加密我们可以猜个大概：加密和解密使用的不是同一个密钥。确实是这样的，加密和解密使用的是一对密钥：保存在服务端的是私钥，发送给客户端的是公钥。使用的过程中我们使用公钥加密，并在服务端通过私钥进行解密。这样操作下来确实可以保证客户端到服务端的请求是安全的，反过来服务端需要发送数据给客户端的时候，则是通过私钥进行加密，然后传送到客户端，客户端会使用公钥进行解密，在这个过程中可以看到的是，服务端传送回去的数据是会被拦截并篡改的，毕竟公钥是透明化的，因此非对称加密只能保证客户端到服务端请求的加密，并没有办法保证服务端到客户端传输的数据不被篡改。</p><p>具体流程如下：<img src="//southrivers.github.io/2020/07/24/https通信原理/feiduichen.png" alt></p><p>相较于对称加密，非对称加解密的流程明显要复杂，因此单纯的从效率的层面上的话，非对称加密是比较低的。</p><h2 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h2><p>通过上面我们可以知道，使用对称加密效率高，非对称加密安全系数高，因此我们是否可以综合二者的优点，这就形成了第三种加解密的方式：<strong>混合加密</strong>。整个加解密的过程分为两个阶段，分别是非对称加解密阶段、对称加解密阶段。简而言之就是：采用非对称加密对对称密钥进行加密传输，完成对称密钥的传输之后，通信双方以对称密钥的方式进行传输数据。以https通信为例（https是在http协议的基础上增加了一层SSL，用于构建加密的传输信道），具体流程如下：<img src="//southrivers.github.io/2020/07/24/https通信原理/hunhe" alt></p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h3 id="信息被篡改"><a href="#信息被篡改" class="headerlink" title="信息被篡改"></a>信息被篡改</h3><p>在上面的几种加密的方式中，我们解决的主要矛盾是，信息在网络上传输的安全性的问题，不过如果有黑客截取了密文，虽然解不出来明文是什么，但是可以胡改一通，这样服务端在收到信息的并进行解密的时候就可能会解密不出来或者解密成错误的body，针对这种情况上面的几种加密方式很明显就没有办法保证了。为了解决这种信息被篡改的问题，一种比较好的方式就是对传送的信息进行签名（简单点可以使用CRC、MD5来进行签名），具体流程如下</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><ul><li>客户端对需要传送的数据进行取hash，得到信息的摘要</li><li>客户端使用密钥加密信息和摘要</li><li>客户端发送加密数据到服务端</li></ul><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><ul><li>使用私钥对接收到的密文进行解密</li><li>通过hash算法hash数据，校验摘要信息是否匹配</li></ul><h3 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h3><p>虽然可以通过签名解决信息被篡改的问题，但是依然没有办法确定客户端就是客户端，毕竟你没有办法证明你就是你啊。那么为了证明我就是我，怎么做呢？通常我们会拿出身份证来证明，在网络中是怎么证明的呢？那就需要三方权威机构给我们提供类似于身份认证的问题，这个机构就是CA，具体流程如下：</p><ul><li>客户端请求CA来申请证书</li><li>CA给客户端办法证书，证明你就是你</li><li>客户端携带证书传送数据到服务端</li><li>服务端就收到客户端信息之后，就去除证书去CA认证你是不是你</li><li>CA机构返回认证信息给服务端，之后服务端响应客户端的请求</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>我们经常见到的事物看似简单，但是仔细分析一下会发现我们可能仅仅会使用这个功能，而至于底层的原理我们不想了解，恰恰这些东西才能真正的提升自身的竞争力吧，毕竟hello world谁都会写。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>linux shell脚本</title>
      <link href="/2020/07/21/linux-shell%E8%84%9A%E6%9C%AC/"/>
      <url>/2020/07/21/linux-shell%E8%84%9A%E6%9C%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>脚本在日常的开发过程中大概也是必须的一个环节了吧，以前总以为我一个写后台的了解脚本作甚，后面渐渐的发现排查一些线网问题或者加一些自定义监控、软件自动部署、日志分析脚本的时候，使用脚本还是很方便的，因此抽时间来学习并总结一下脚本相关的知识。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="常见的shell"><a href="#常见的shell" class="headerlink" title="常见的shell"></a>常见的shell</h2><p>linux shell程序常见最多的应该就是<code>/bin/bash</code>了，不过除了bash外还会有多种其他的shell，这些shell程序一般放在<code>/bin</code>或者<code>/user/bin</code>目录下面，当前linux可用的shell脚本都记录在<code>/etc/shells</code>下面，这是一个文本文件，我们可以直接查看，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# cat /etc/shells</span><br><span class="line">/bin/sh</span><br><span class="line">/bin/bash</span><br><span class="line">/usr/bin/sh</span><br><span class="line">/usr/bin/bash</span><br></pre></td></tr></table></figure><p><strong><code>SHELL</code></strong>是linux系统中的一个环境变量，可以方便我们快速的查看当前系统中使用的是那个shell应用，具体的如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# echo $SHELL</span><br><span class="line">/bin/bash</span><br></pre></td></tr></table></figure><p>上看我们可以看到当前shell应用使用的是/bin/bash这个shell应用。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><hr><p><strong>约束：变量只可以由字母、数字、下划线组成，并且只可以字母下划线开头</strong></p><hr><ul><li>定义变量：在shell脚本中，每一个变量都是一个字符串，无论赋值的时候有没有使用引号，因此这里需要注意的就是，即便声明变量的时候指定的值是数字，在shell中依然会被是为字符串，不过话说回来，到底有没有方法可以指定为整型呢？其实是有的，这就是<code>declare</code>，不过更多的情况下我们真的没有必要去刻意声明变量是整型。通常情况下，如果字符串中包含了空格或者tab，我们需要使用引号将对应的value包括起来。</li><li><ul><li>引号之分：值得一提的是我们在定义变量的时候使用单引号或者双引号的含义在变量包含引用其他类型的变量的时候其执行的结果是不一样的 </li></ul></li><li>使用变量：这里使用变量的时候，我们只需要使用$将变量引起来即可，通常情况下我们可以选择{}来</li><li>修改变量：修改变量的时候我们直接指定变量就可以了</li><li>命令变量：当我们希望将某一个命令的执行结果赋给特定变量的时候，我们可以采用`command`的方式，或者$(command)，这里一定要区别于上面引用变量所采用的${}</li></ul><p>下面通过一个例子来演示一下变量的使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 home]# cat test.sh</span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">a1=&quot;hello&quot;</span><br><span class="line">a2=&quot;$&#123;a1&#125; world&quot;</span><br><span class="line">a3=&apos;$a1&apos;</span><br><span class="line"></span><br><span class="line">echo &quot;a1 is: &quot; $a1</span><br><span class="line">echo &quot;a2 is&quot; $a2</span><br><span class="line">echo &quot;a3 is&quot; $a3</span><br><span class="line"></span><br><span class="line">a1=&apos;world hello&apos;</span><br><span class="line">echo &quot;again a1 is: &quot; $a1</span><br><span class="line"></span><br><span class="line">a1=`echo hahaha`</span><br><span class="line">echo &quot;command &apos;&apos; a1 is: &quot; $a1</span><br><span class="line"></span><br><span class="line">a1=$(echo hahaha)</span><br><span class="line"></span><br><span class="line">echo &apos;command $ a1 is: &apos; $a1</span><br><span class="line">[root@59950cdb5d31 home]# ./test.sh</span><br><span class="line">a1 is:  hello</span><br><span class="line">a2 is hello world</span><br><span class="line">a3 is $a1</span><br><span class="line">again a1 is:  world hello</span><br><span class="line">command &apos;&apos; a1 is:  hahaha</span><br><span class="line">command $ a1 is:  hahaha</span><br></pre></td></tr></table></figure><p>上面的例子中演示了变量最基本的用法，不过还存在一些特殊变量，在工程应用的时候特别有用：</p><ul><li>$ :该特殊变量代表进程的id，我们可以尝试一下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 home]# echo $$</span><br><span class="line">24</span><br><span class="line">[root@59950cdb5d31 home]# ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">   24 pts/0    00:00:00 bash</span><br><span class="line">  214 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure><p>特殊变量|变量|    含义||—|——-||$0    |当前脚本的文件名||$n    |传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。||$#    |传递给脚本或函数的参数个数。||$*    |传递给脚本或函数的所有参数。||$@    |传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，$*被双引号包含的时候，变量会作为一个整体输出，$@则是以空格为分隔符输出所有的参数||$?    |上个命令的退出状态，或函数的返回值。||$$    |当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。|</p><p>值得一提的是$?经常会在判断函数执行结果的时候特别有用，下面仅以一个例子来说明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">随便输入一个错误的命令</span><br><span class="line">[root@59950cdb5d31 home]# prin</span><br><span class="line">bash: prin: command not found</span><br><span class="line">查看上面一个命令的执行结果</span><br><span class="line">[root@59950cdb5d31 home]# echo $?</span><br><span class="line">127</span><br><span class="line">继续查看上面一个命令的执行结果</span><br><span class="line">[root@59950cdb5d31 home]# echo $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>大部分情况下，上面一个命令执行成功并推出会返回0，执行失败会返回1，不过这里明显能够看到执行状态为失败的时候返回的可能不是1</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在看docker相关的东西，偶然了解了一下docker网络相关的知识，因此趁机学习一把linux network namespace相关的知识，后面有时间了会慢慢的补齐。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>linux 网络namespace包含了六种，如下图所示：<img src="//southrivers.github.io/2020/07/21/计算机网络/namespace.png" alt>默认情况下docker使用的是network namespace，我也先从network namespace着手来详细了解相关的知识。network namespace在逻辑上是网络堆栈的一个副本，其有自己的路由、防火墙规则以及相关的网络设备。默认的情况下子进程继承父进程的network namespace，每创建一个network namespace都会生成一个环回地址lo，并且network namespace中的设备也是私有的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>示例中我首先会通过docker启动一个centos的服务器来演示整个过程，毕竟这样可以很方便的还原现场。通过Dockerfile构建一个完备的景象（<strong>说明：如果直接使用仓库中的镜像的话，会有很多功能都被阉割</strong>）</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> fedora:<span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span> /sbin/init</span><br></pre></td></tr></table></figure><p>在编写好上面的文件之后，我们通过命令行来构建即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t os .</span><br><span class="line">docker run -d --privileged --name os os</span><br><span class="line">docker exec -it os bash</span><br></pre></td></tr></table></figure><p>执行完上述代码之后，我们就可以以中断的方式进入centos的系统了。</p><h3 id="创建network-namespace"><a href="#创建network-namespace" class="headerlink" title="创建network namespace"></a>创建network namespace</h3><p>首先我们可以查看当前的network namespace，现实结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@f915072d75e8 /]# ip netns ls</span><br><span class="line">[root@f915072d75e8 /]#</span><br></pre></td></tr></table></figure><p>可以看到当前没有network namespace，接下来我们来创建一个namespace，并查看创建结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip netns add net1</span><br><span class="line">[root@59950cdb5d31 /]# ip netns ls</span><br><span class="line">net1</span><br></pre></td></tr></table></figure><p>接下来我们继续看一下对应的目录下/var/run/netns下面是否新建了对应的namespace：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ls -al /var/run/netns/</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x  2 root root  60 Jul 20 17:10 .</span><br><span class="line">drwxr-xr-x 15 root root 340 Jul 20 17:10 ..</span><br><span class="line">-r--r--r--  1 root root   0 Jul 20 17:10 net1</span><br></pre></td></tr></table></figure><p>接下来我们看一下新建的这个namespace都有什么吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip netns exec net1 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br></pre></td></tr></table></figure><p>如上，我们看到除了lo之外，还有两个网络，那么这两个网络是如何来的呢？<del>应该就是从父进程继承过来的</del>。</p><p>接下来我们看一下两个network namespace之间是如何进行通信的吧。我们只需要按照上面的步骤再添加一个namespace即可，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip netns add net0</span><br><span class="line">[root@59950cdb5d31 /]# ip netns ls</span><br><span class="line">net0</span><br><span class="line">net1</span><br></pre></td></tr></table></figure><p>需要注意的是新创建的namespace默认不能和主机通信，也不能和其他的namespace通信，对于这种情况，linux给我们提供了veth pair来完成通信，如下，显示了两个namespace之间的网络拓扑：</p><p><img src="//southrivers.github.io/2020/07/21/计算机网络/netpair.png" alt></p><p>为了完成上述网络拓扑的定制，我们需要创建一对veth pair（删除一个，另外一个会自动删除，这里是成对出现的），具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip link add type veth</span><br><span class="line">[root@59950cdb5d31 /]# ip link</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">4: veth0@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 3a:60:e7:2a:02:38 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">5: veth1@veth0: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:e0:6a:c6:62:d5 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">14: eth0@if15: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default</span><br><span class="line">    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>完成上述操作后我们可以看到已经成功添加了一堆veth：veth0、veth1，接下来我们将veth分别加入对应的namaspace中，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip link set veth0 netns net0</span><br><span class="line">[root@59950cdb5d31 /]# ip link set veth1 netns net1</span><br><span class="line">[root@59950cdb5d31 /]# ip netns exec net0 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">4: veth0@if5: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 3a:60:e7:2a:02:38 brd ff:ff:ff:ff:ff:ff link-netns net1</span><br><span class="line">[root@59950cdb5d31 /]# ip netns exec net1 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">5: veth1@if4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:e0:6a:c6:62:d5 brd ff:ff:ff:ff:ff:ff link-netns net0</span><br></pre></td></tr></table></figure><p>上面我们看到虽然已经将veth成功的加入对应的namespace中了，但是依然存在一个问题，对应的veth依然是没有ip的情况，因此我们为其指定ip：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip netns exec net0 ip addr add 192.168.1.1/24 dev veth0</span><br><span class="line">[root@59950cdb5d31 /]# ip netns exec net1 ip addr add 192.168.1.1/24 dev veth1</span><br></pre></td></tr></table></figure><p>不过，对应的veth依然是down并且没有对应的ip，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@59950cdb5d31 /]# ip netns exec net1 ip link</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: tunl0@NONE: &lt;NOARP&gt; mtu 1480 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/ipip 0.0.0.0 brd 0.0.0.0</span><br><span class="line">3: ip6tnl0@NONE: &lt;NOARP&gt; mtu 1452 qdisc noop state DOWN mode DEFAULT group default qlen 1</span><br><span class="line">    link/tunnel6 :: brd ::</span><br><span class="line">5: veth1@if4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether 5a:e0:6a:c6:62:d5 brd ff:ff:ff:ff:ff:ff link-netns net0</span><br></pre></td></tr></table></figure><p>最后我们分别启动两个veth，并执行ping操作即可发现两个namespace已经联通了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec net0 ip link set dev veth0 up</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>时间关系，本次小结比较仓促，后面有时间再慢慢研究linux网络相关的知识。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java动态代理</title>
      <link href="/2020/07/02/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/07/02/java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="面向接口的动态代理"><a href="#面向接口的动态代理" class="headerlink" title="面向接口的动态代理"></a>面向接口的动态代理</h3><h3 id="三方库动态代理"><a href="#三方库动态代理" class="headerlink" title="三方库动态代理"></a>三方库动态代理</h3><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java序列化、反序列化</title>
      <link href="/2020/06/30/java%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2020/06/30/java%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在做代码静态检查的时候接触到序列化、反序列化的漏洞，之前也断断续续的使用过序列化、反序列化的知识，一般是通过实现Serializable接口，并提供readObject、writeObject的方法来实现反序列化和序列化，当然序列化的目的则是让java对象脱离jvm而存在，这样就可以在网络上传输数据了，或者持久化到磁盘、数据库中，等到需要的时候再通过反序列化的方式将其转换成java对象。使用过fastjson的人应该差不多都知道，这个小工具确实很好用，也很快，不过网上却爆出各种安全问题，应该也算的上誉满天下、谤满天下了吧。接下来我们就来认识一下序列化、反序列化所带来的问题吧。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="使用场景分析"><a href="#使用场景分析" class="headerlink" title="使用场景分析"></a>使用场景分析</h2><ul><li>平台之间的通信：我们最长使用的序列化、反序列化的场景应该就是在后端了，不过大家可能平时都没有太留意，我们常使用的http请求，前端传的是json，到了后台之后就被反序列化成java bean了，这本质上就是反序列化，前端请求接口，后台返回java bean，数据传到前端的时候已经是json了，那么该过程就是序列化的过程。</li><li>RMI：也即是远程方法调用（remote method invocation），相信接触过分布式的同学应该会对这很熟悉了，这是实现不通操作系统之间程序方法调用的关键，Java RMI 默认的端口是1099</li><li><strong>JMX：JMX是一套标准的代理和服务，主要用于监控业务的实现，有时间需要整理一下这一块的内容</strong></li></ul><h2 id="漏洞原因"><a href="#漏洞原因" class="headerlink" title="漏洞原因"></a>漏洞原因</h2><p>暴露或者间接暴露<strong>反序列化API</strong>，导致用户可以操作传入的数据，用户可以在篡改的数据中随意注入自定义的逻辑，这样系统的一些函数就赤裸裸的暴露在篡改者的面前。</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="序列化、反序列化演示"><a href="#序列化、反序列化演示" class="headerlink" title="序列化、反序列化演示"></a>序列化、反序列化演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MashaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// java 对象</span></span><br><span class="line">        String text = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对象的序列化，写入文件</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"text"</span>));) &#123;</span><br><span class="line">            oos.writeObject(text);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化成java对象</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"text"</span>))) &#123;</span><br><span class="line">            String  res = (String) ois.readObject();</span><br><span class="line">            System.out.println(res);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，我们展示了一个java对象如何序列化成文件，并从文件反序列化成对象的过程，这里需要注意的是待序列化的对象是一个String类型，我们查看一下累的继承关系不难发现，String继承了Serializable接口，这也是在不引入三方库的前提下对象序列化和反序列化必须要具备的条件：<strong>实现Serializable接口</strong></p><h3 id="漏洞演示"><a href="#漏洞演示" class="headerlink" title="漏洞演示"></a>漏洞演示</h3><p>上面我们介绍了序列化和反序列化的基本的知识，接下来我们可以看一下序列化、反序列化如何注入用户自身的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmashaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造对象</span></span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        test.name = <span class="string">"hello wes"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"text"</span>))) &#123;</span><br><span class="line">            oos.writeObject(test);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反序列化，这里可以看到被篡改后的数据会触发什么操作</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"text"</span>))) &#123;</span><br><span class="line">            Test res = (Test) ois.readObject();</span><br><span class="line">            System.out.println(res.name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意这里的方法一定是private类型的</span></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream inputStream)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">            inputStream.defaultReadObject();</span><br><span class="line">            Runtime.getRuntime().exec(<span class="string">"open /Applications/Calculator.app/"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行后会发现该程序会启用计算器的程序，如下：<img src="//southrivers.github.io/2020/06/30/java序列化、反序列化/cacl.png" alt>通过上面程序的演示我们可以看到反序列化中确实存在一些安全隐患。尽管上面的代码能够演示反序列化中存在的一些漏洞，不过看起来还是太demo化了，接下来我们来看一个稍微复杂一点的例子。</p><!--### RMI漏洞演示https://paper.seebug.org/312/### fastjson漏洞演示--><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>常用的用于防范反序列化安全问题的方案有以下两种：</p><ul><li>禁止jvm执行外部命令Runtime.exec方法，具体的可以通过扩展 SecurityManager 可以实现，详细方案后面有时间再补齐</li><li>类的白名单校验：具体的是自定义ObjectInputStream，重载resolveClass方法，对class进行白名单的限制，详细方案后面有时间再补齐</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面简单的对java序列化、反序列化中的使用以及可能存在的漏洞进行了分析，同时也提供了解决这种漏洞的机制，更多扩展知识后面有时间再补齐吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络传输curl vs ping</title>
      <link href="/2020/06/29/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93curl-vs-ping/"/>
      <url>/2020/06/29/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93curl-vs-ping/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在定位网络问题的时候，先是ping了一下目标ip，发现ping不通，然后就以为网络是不通的了。确实，一般情况下我们肯定就认为网络不通了，但是，有个兄弟跟我说服务是可以调用的，然后我就试了一下，通过curl的方式来调用相关的接口，奇迹出现了，居然可以调的通，于是乎开始了各种网络相关知识的搜索，为防止遗忘，特别记录了一下。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="TCP-IP网络分层"><a href="#TCP-IP网络分层" class="headerlink" title="TCP/IP网络分层"></a>TCP/IP网络分层</h2><p>计算机网络分层存在两种模型，一种是标准的OSI七层模型，一种是当前计算机网络中普遍使用的TCP/IP四层网络分层协议。两种协议的划分以及对应关系如下：</p><p><img src="//southrivers.github.io/2020/06/29/网络传输curl-vs-ping/osi&tcp.png" alt></p><p>上图我们可以看到传输层的协议是TCP、UDP，两种协议的区别是是否面向连接；而网络层或者说网际层的协议则有IP、ICMP、ARP、RARP协议，这里说IP协议其实是不准确的，应该说是IP协议族。回归到我们今天的正题，curl和ping的区分，ping应用的全称叫做<strong>Packet InterNet Groper（分组网间探测）</strong>，该协议主要是用于主机或者路由器之间的连通性，应用层直接使用网际层的ICMP协议，中间并没有使用传输层的UDP或者TCP的协议。ICMP的全称为<strong>Internet Control Message Protocol（网际控制报文协议）</strong>。</p><p>我们平时使用curl的时候一般都是用来调用http的接口来获取数据，这里需要说明的是curl支持http、https、ftp等众多的协议，其在请求数据的时候，是会经过中间的传输层，并不是向Ping应用那样直接跳过了传输层。</p><h2 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h2><p>为了更好的理解curl和ping的区分，还是有必要通过packet tracer来仿真演示一下这两个请求的过程的，具体如下：</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>大多数排查网络故障都是从ping开始的，不过ping默认使用的协议是ICMP的协议，这要求源节点和目标节点之间的所有的中间节点都支持ICMP转发的协议，如果中间的某一个节点通过防火墙禁用了ICMP的协议，那么这就会导致节点之间看起来好像是不通的样子。而curl则是使用的TCP的协议，因此当ping的不通的时候，我们仍然是有可能curl通的。当遇到之中情况的时候，可以使用<code>traceroute 目标Ip</code>的方式来查看连路中哪一个节点出现了问题。</p><p>这里稍微提一下traceroute的原理：通过不断的增加ICMP报文的TTL依次将报文发送出去，最终找到目标机器，这样每次TTL为0的时候都会返回给发送发对应网络节点的路由信息。不过值得注意的是linux和windows的tracerouter协议的实现稍有不通，<strong>linux是有使用了传输层，而windows没有使用。</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>spark streaming 小结</title>
      <link href="/2020/06/22/spark-streaming-%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/06/22/spark-streaming-%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在开发的过程中一直有使用spark streaming来处理监控数据，期间也遇到和解决了部分问题，为防止遗忘特别记录了一下</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>在开始介绍之前还是先看一个spark streaming 结合 kafka的例子，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.spark;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kafka.serializer.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.SparkConf;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.Durations;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaPairDStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaStreamingContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka.KafkaUtils;</span><br><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SparkDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SparkConf conf = <span class="keyword">new</span> SparkConf().setAppName(<span class="string">"wes"</span>).setMaster(<span class="string">"local[2]"</span>);</span><br><span class="line"></span><br><span class="line">        JavaStreamingContext jssc = <span class="keyword">new</span> JavaStreamingContext(conf, Durations.seconds(<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">"bootstrap.servers"</span>, <span class="string">"localhost:9092"</span>);</span><br><span class="line">        map.put(<span class="string">"group.id"</span>, <span class="string">"g1"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; topics = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        topics.add(<span class="string">"test"</span>);</span><br><span class="line"></span><br><span class="line">        JavaPairDStream&lt;String, String&gt; dStream = KafkaUtils.createDirectStream(jssc, String<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">String</span>.<span class="title">class</span>, <span class="title">StringDecoder</span>.<span class="title">class</span>, <span class="title">StringDecoder</span>.<span class="title">class</span>, <span class="title">map</span>, <span class="title">topics</span>)</span>;</span><br><span class="line"></span><br><span class="line">        dStream.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;Tuple2&lt;String, String&gt;, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterable&lt;String&gt; <span class="title">call</span><span class="params">(Tuple2&lt;String, String&gt; stringStringTuple2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                res.add(stringStringTuple2._2);</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print();</span><br><span class="line"></span><br><span class="line">        jssc.start();</span><br><span class="line">        jssc.awaitTermination();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成kafka"><a href="#集成kafka" class="headerlink" title="集成kafka"></a>集成kafka</h2><ul><li>kafka 9093问题</li><li>offset手动提交</li></ul><h2 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h2><p>广播变量的定义，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Broadcast&lt;String&gt; name = jssc.sparkContext().broadcast(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>定义完之后我们就可以在程序的任意位置使用该数据了，广播变量不可以更新，因此在使用<code>name.destroy();</code>之后如果再次调用就会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">org.apache.spark.SparkException: Attempted to use Broadcast(0) after it was destroyed (destroy at SparkDemo.java:43) </span><br><span class="line">at org.apache.spark.broadcast.Broadcast.assertValid(Broadcast.scala:144)</span><br><span class="line">at org.apache.spark.broadcast.Broadcast.value(Broadcast.scala:69)</span><br><span class="line">at com.spark.SparkDemo$1.call(SparkDemo.java:44)</span><br><span class="line">at com.spark.SparkDemo$1.call(SparkDemo.java:37)</span><br><span class="line">at org.apache.spark.streaming.api.java.JavaDStreamLike$$anonfun$fn$1$1.apply(JavaDStreamLike.scala:170)</span><br><span class="line">at org.apache.spark.streaming.api.java.JavaDStreamLike$$anonfun$fn$1$1.apply(JavaDStreamLike.scala:170)</span><br><span class="line">at scala.collection.Iterator$$anon$12.hasNext(Iterator.scala:396)</span><br><span class="line">at scala.collection.Iterator$$anon$10.hasNext(Iterator.scala:350)</span><br><span class="line">at scala.collection.Iterator$class.foreach(Iterator.scala:742)</span><br><span class="line">at scala.collection.AbstractIterator.foreach(Iterator.scala:1194)</span><br><span class="line">at scala.collection.generic.Growable$class.$plus$plus$eq(Growable.scala:59)</span><br><span class="line">at scala.collection.mutable.ArrayBuffer.$plus$plus$eq(ArrayBuffer.scala:104)</span><br><span class="line">at scala.collection.mutable.ArrayBuffer.$plus$plus$eq(ArrayBuffer.scala:48)</span><br><span class="line">at scala.collection.TraversableOnce$class.to(TraversableOnce.scala:308)</span><br><span class="line">at scala.collection.AbstractIterator.to(Iterator.scala:1194)</span><br><span class="line">at scala.collection.TraversableOnce$class.toBuffer(TraversableOnce.scala:300)</span><br><span class="line">at scala.collection.AbstractIterator.toBuffer(Iterator.scala:1194)</span><br><span class="line">at scala.collection.TraversableOnce$class.toArray(TraversableOnce.scala:287)</span><br><span class="line">at scala.collection.AbstractIterator.toArray(Iterator.scala:1194)</span><br><span class="line">at org.apache.spark.rdd.RDD$$anonfun$take$1$$anonfun$28.apply(RDD.scala:1328)</span><br><span class="line">at org.apache.spark.rdd.RDD$$anonfun$take$1$$anonfun$28.apply(RDD.scala:1328)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$runJob$5.apply(SparkContext.scala:1858)</span><br><span class="line">at org.apache.spark.SparkContext$$anonfun$runJob$5.apply(SparkContext.scala:1858)</span><br><span class="line">at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:66)</span><br><span class="line">at org.apache.spark.scheduler.Task.run(Task.scala:89)</span><br><span class="line">at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:214)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>正则</title>
      <link href="/2020/05/08/%E6%AD%A3%E5%88%99/"/>
      <url>/2020/05/08/%E6%AD%A3%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>当我们处理一个字符串问题的时候可以尝试一下使用正则，这样代码的可读性将会大大的提高，不过这么做的话，之前的一个问题就变成了两个问题（😄）。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h2><h3 id="简单字符串匹配"><a href="#简单字符串匹配" class="headerlink" title="简单字符串匹配"></a>简单字符串匹配</h3><p>模式是正则表达式最基本的元素，他是一组<strong>描述字符串特征的字符</strong>。最简单的模式就是一个字符串，不包含任何特殊的字符串，比如：<code>hello</code>，这中模式可以匹配任意<strong>包含了<code>hello</code></strong>的字符串，如：<code>aaa hello world ！</code>。<code>^</code>表示以什么开头的字符串，比如<code>^hello</code>表示以<code>hello</code>开头的字符串，这种模式可以匹配任何<strong>以<code>hello</code>开头</strong>的字符串，如：<code>hello word</code>。<code>$</code>表示以什么结尾的字符串，比如<code>hello$</code>表示以<code>hello</code>结尾的字符串，这种模式可以匹配任何<strong>以<code>hello</code>结尾</strong>的字符串，如：<code>world hello</code>。</p><h3 id="转义字符匹配"><a href="#转义字符匹配" class="headerlink" title="转义字符匹配"></a>转义字符匹配</h3><p>在上面的模式匹配中，字符都是代表其本身（这里想表达的是有些字符并不是代表其自身，也即是转义字符，如<code>^\t</code>并不是标记以<code>\t</code>开头的字符串，而是以制表符tab开头的字符串），\r代表回车、\n代表新行、\s代表空格。</p><h2 id="字符簇匹配"><a href="#字符簇匹配" class="headerlink" title="字符簇匹配"></a>字符簇匹配</h2><p>字符簇匹配的意思是匹配一个指定的字符范围，不过这里<strong>仅仅是匹配单个字符</strong>，具体规则如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[a-z] //匹配所有的小写字母 </span><br><span class="line">[A-Z] //匹配所有的大写字母 </span><br><span class="line">[a-zA-Z] //匹配所有的字母 </span><br><span class="line">[0-9] //匹配所有的数字 </span><br><span class="line">[0-9\.\-] //匹配所有的数字，句号和减号 </span><br><span class="line">[ \f\r\t\n] //匹配所有的白字符</span><br></pre></td></tr></table></figure><p>可以举个例子：<code>^[0-9][a-z]$</code>表示匹配一个<strong>长度为2的字符串</strong>，并且字符串的首字符是一个数字，尾字符是一个小写的字母。值得一提的是，如果在方括号中使用<code>^</code>表示取反的意思。如<code>^[^a-z][0-9]$</code>表示长度为2的字符串，不过首字符只要不是小写字母就可以</p><h2 id="重复字符"><a href="#重复字符" class="headerlink" title="重复字符"></a>重复字符</h2><p>对于重复出现的字符，上面的规则显然就不适用了，通常情况下使用<code>{}</code>来表示匹配多个字符，例如我们可以用<code>^[a-z]{1,}</code>来匹配所有的长度大于1的并且是小写字符的字符串。我们也可以指定<code>{}</code>中数字的范围来指定前面的模式出现的次数。这里我们也可以简化一下，用<code>？</code>来表示可选（<code>{0,}</code>），用<code>+</code>表示至少一个(<code>{1,}</code>)。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><p>可以用<code>|</code>代表或的逻辑，其他的待整理。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>最后还是来一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">给定一个单词，你需要判断单词的大写使用是否正确。</span><br><span class="line"></span><br><span class="line">我们定义，在以下情况时，单词的大写用法是正确的：</span><br><span class="line"></span><br><span class="line">全部字母都是大写，比如&quot;USA&quot;。</span><br><span class="line">单词中所有字母都不是大写，比如&quot;leetcode&quot;。</span><br><span class="line">如果单词不只含有一个字母，只有首字母大写， 比如 &quot;Google&quot;。</span><br><span class="line">否则，我们定义这个单词没有正确使用大写字母。</span><br><span class="line"></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">链接：https://leetcode-cn.com/problems/detect-capital</span><br><span class="line">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.Pattern;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">detectCapitalUse</span><span class="params">(String word)</span> </span>&#123;</span><br><span class="line">        String reg = <span class="string">"^([A-Z][a-z]+|[a-z]+|[A-Z]+)$"</span>;</span><br><span class="line">        Pattern p = Pattern.compile(reg);</span><br><span class="line">        <span class="keyword">return</span> p.matcher(word).find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>关于正则的分析就到现在为止吧，有时间再继续整理。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>guice小结</title>
      <link href="/2020/04/18/guice%E5%B0%8F%E7%BB%93/"/>
      <url>/2020/04/18/guice%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相信很多人都用过spring，这也是大部分java从业人员最长使用到的框架，在之前的文章中我也有介绍spring相关的知识。spring的核心是IOC，那么除了spring之外还有没有其他的IOC的框架呢？答案是有的！这就是我们今天要提的guice，一款由google开发的小众、轻量级的IOC框架。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="guice详解"><a href="#guice详解" class="headerlink" title="guice详解"></a>guice详解</h2><p>在详细介绍guice之前，我们还是先来了解一下guice中的一些概念并由浅入深的介绍一下使用中的一些小技巧，最后会尝试使用guice和jetty构建一个mini的web工程。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>在guice中，是使用一个Map&lt;Key<?>、Provider<?>&gt;的结构来存放java bean的（在spring中是用Map&lt;String, Class&gt;来存放的），因此guice使用key来代表一个可以用来完成注入的对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Key&lt;String&gt; databaseKey = Key.get(String<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>上面这种方式就可以用来获取一个String类型的bean，不过正常的应用中可能会包含多个类型相同的对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultilingualGreeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String englishGreeting;</span><br><span class="line">  <span class="keyword">private</span> String spanishGreeting;</span><br><span class="line"></span><br><span class="line">  MultilingualGreeter(String englishGreeting, String spanishGreeting) &#123;</span><br><span class="line">    <span class="keyword">this</span>.englishGreeting = englishGreeting;</span><br><span class="line">    <span class="keyword">this</span>.spanishGreeting = spanishGreeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们看到了MultilingualGreeter依赖于两个String类型的bean，那么我们如何区分这两个string呢？guice给我们提供了注解的方式来解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultilingualGreeter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String englishGreeting;</span><br><span class="line">  <span class="keyword">private</span> String spanishGreeting;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  MultilingualGreeter(</span><br><span class="line">      <span class="meta">@English</span> String englishGreeting, <span class="meta">@Spanish</span> String spanishGreeting) &#123;</span><br><span class="line">    <span class="keyword">this</span>.englishGreeting = englishGreeting;</span><br><span class="line">    <span class="keyword">this</span>.spanishGreeting = spanishGreeting;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用的时候，通过下面的方式就可以获取到相应的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Key&lt;String&gt; englishGreetingKey = Key.get(String<span class="class">.<span class="keyword">class</span>, <span class="title">English</span>.<span class="title">class</span>)</span>;</span><br><span class="line">Key&lt;String&gt; spannishGreetingKey = Key.get(String<span class="class">.<span class="keyword">class</span>, <span class="title">Spanish</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><p>这个时候，当我们想要创建一个MultilingualGreeter对象的时候，就等价于下面这种方式来创建：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String english = injector.getInstance(Key.get(String<span class="class">.<span class="keyword">class</span>, <span class="title">English</span>.<span class="title">class</span>))</span>;</span><br><span class="line">String spanish = injector.getInstance(Key.get(String<span class="class">.<span class="keyword">class</span>, <span class="title">Spanish</span>.<span class="title">class</span>))</span>;</span><br><span class="line">MultilingualGreeter greeter = <span class="keyword">new</span> MultilingualGreeter(english, spanish);</span><br></pre></td></tr></table></figure><p>上面我们简单的演示了一下依赖注入的过程，不过这种方式太硬了，硬的让人没办法接受，谁会在工程实践中这么使用呢？下面用一个例子来说明一下。我们知道依赖注入包含了field注入，setter注入、constructor注入，接下来我们先来看一下guice给我们提供的这些个注入的方式：</p><h4 id="field注入："><a href="#field注入：" class="headerlink" title="field注入："></a>field注入：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信用过spring的人马上就会想到@Autowired这个注解了，这样做本身并没有什么问题，不过这样的话A对象的创建强依赖于框架了（只能通过guice框架完成对象A对象的创建了）。那么很自然我们可能就会想到使用下面这种方式：</p><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> B b;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个样子多了一个构造函数，这样我们既可以通过框架来生成A对象，也可以绕开框架通过构造函数来创建A对象。不过考虑一下我现在如果不用spring框架了，要用其他的IOC框架，是不是要把打开所有的注解都替换一遍？WTF！？大家在Spring的开发中应该从来都没有想过这个问题吧。看一下guice给我们提供了什么样的骚操作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Singleton</span></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function">A <span class="title">provideA</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> A(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们可以看到又引入了两个新的概念：@Provides和Module，guice中使用Provider来代表一个用于生成特定对象的工厂类，下面是Provider接口的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Provider</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过实现该接口来创建T类型的对象，不过更多的时候，我们看到的是会在Module中通过方法注解的方式来描述对象的创建，这样做的好处是将创建对象的任务交给了guice的injector，这里modules的作用更多的是像spring中的beans标签或者springboot中的@confituration注解，而@provider的作用则更多的像是bean标签。上面A对象的创建是不是会发现代码完全是clean的了，对象的装配都整合在一个Module中了，之前的功能bean零注解了！而且仔细想一下通过Provider这种方式来创建对象也更自由了，我们可以创建一个更复杂的bean。</p><p>这里我们还是简单的说一下module吧。Guice的Module可以用来指定接口和其对应的实现的关系，这里我们通常可以重写configure方法，在其中使用bind方法来指定接口和实现。另外，我们也可以使用方法级别的@Provide来指定创建一个对象的方法。</p><h3 id="绑定关系"><a href="#绑定关系" class="headerlink" title="绑定关系"></a>绑定关系</h3><p>guice给我们提供了多种绑定接口和实现之间关系的方法，最常见的就是bind操作了，该操作的主要的目的是构建一个映射关系，如上面所说的那样，我们一般是在module中构建这种关系，<strong>一个module有点类似于一个有向图，我们在创建对象的时候是采用深度遍历的策略去寻找依赖关系，而我们的map则保存了图中每一个节点的信息</strong>。不过bind也包含了很多种情况，接下来我们就一点一点的来看一下：</p><table><thead><tr><th>guice语法</th><th>等价语法</th></tr></thead><tbody><tr><td>bind(key).toInstance(value)(instance binding)</td><td>map.put(key, () -&gt; value)</td></tr><tr><td>bind(key).toProvider(provider)(provider binding)</td><td>map.put(key, provider)</td></tr><tr><td>bind(key).to(anotherKey)(linked binding)</td><td>map.put(key, map.get(anotherKey))</td></tr><tr><td>@Provides Foo provideFoo() {…}(provider method binding)</td><td>map.put(Key.get(Foo.class), module::provideFoo)</td></tr></tbody></table><h4 id="simpleBind"><a href="#simpleBind" class="headerlink" title="simpleBind"></a>simpleBind</h4><p>我们最常见的就是这种类型的bind了，上面使用到的也是这种类型的bind操作。</p><ul><li>linked bind：将类型和实现直接进行绑定，形式如<code>bind(TransactionLogInterface.class).to(DatabaseTransactionLogImpl.class);</code></li><li>bind annotation：使用注解+Type来确定一个实现类，注解是可以使用我们自定义的，也可以使用guice给我们提供的@Name，具体用法<code>bind(CreditCardProcessor.class).annotatedWith(注解.class).to(PayPalCreditCardProcessor.class);</code>、<code>bind(CreditCardProcessor.class).annotatedWith(Names.named(&quot;名称&quot;)).to(CheckoutCreditCardProcessor.class);</code></li><li>instance bind：可以绑定中类型和该类型的一个实例，具体用法为<code>bind(key).toInstance(value)</code>，再加上bind annotation，我们可以更灵活一点：<code>bind(CreditCardProcessor.class).annotatedWith(Names.named(&quot;名称&quot;)).toInstance(&#39;instance&#39;)</code></li><li>@Provides Methods： 这种方式我们在前面也已经见到过了，也是声明关系的一种方式，个人觉得这种是最灵活的实现方式</li><li>Provider：同@Provides类似，当使用@Provides实现过于复杂的时候，我们可以实现Provider接口的方式来完成这种绑定的机制，不过此时要使用<code>bind(key).toProvider(provider)</code>来绑定</li><li>Untargeted Bindings：有时候对于一个具体的实现我们也希望将其注入到容器，这种情况下并没有接口可以绑定，guice给我们提供了方便的实现：<code>bind(MyConcreteClass.class);bind(AnotherConcreteClass.class).in(Singleton.class);</code>，当然我们也可以用上面那种最简单的bind接口到实现的方式，不过这里的接口和实现是同一个类型而已。</li><li>Constructor Bindings：这里的Construct bind并不是前面的构造器注入，而是当我们引用了第三方的库，第三方库的某个类的构造函数没办法使用@Inject来将其注入到容器中，这种情况下我们要将其注入进来应该怎么办呢？就要使用这种方式了：<code>bind(TransactionLog.class).toConstructor(DatabaseTransactionLog.class.getConstructor(DatabaseConnection.class));</code>，另外多说一句，我们要将mybatis整合进来的话就可以使用这种方式。</li></ul><h4 id="mapBind"><a href="#mapBind" class="headerlink" title="mapBind"></a>mapBind</h4><p>上面我们看到的是实现类（被依赖的类）只有一个的情况，那么当一个被依赖的接口有多个实现的时候，我们想要按需来装配一个对象的时候应该怎么搞呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommandExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">exec</span><span class="params">(String commandName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，我们希望按照CommandExecutor传入的参数commandName来决定究竟调用哪一个Commond，按照上面的写法我们可以写成下面这种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"a_result"</span>;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandB</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"b_result"</span>;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Provides</span></span><br><span class="line">   <span class="meta">@Singleton</span></span><br><span class="line">   <span class="function">CommandExecutor <span class="title">provideCommandExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      CommandA ca, </span></span></span><br><span class="line"><span class="function"><span class="params">      CommandB cb)</span> </span>&#123;</span><br><span class="line">   Map&lt;String, Command&gt; commands = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">      commands.put(<span class="string">"a"</span>, ca);</span><br><span class="line">      commands.put(<span class="string">"b"</span>, cb);</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">return</span> commandName -&gt; commands.get(commandName).exec();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看样子功能是开发完了。现在需求有了变更，我们新增了一种commond，也想要加入进来，那么应该怎么办呢？只可以修改MyModule#provideCommandExecutor方法了，这违反了开闭原则（对扩展开放，对修改关闭）。看来我们要完成这种形式的装配还得另求途径了。索性guice给我们提供了一种比较好的方案MapBinder：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReusableModule</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MapBinder&lt;String, Command&gt; <span class="title">contributeCommands</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Binder binder)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> MapBinder.newMapBinder(</span><br><span class="line">         binder, String<span class="class">.<span class="keyword">class</span>, <span class="title">Command</span>.<span class="title">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">      contributeCommands(binder);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="meta">@Provides</span></span><br><span class="line">   <span class="meta">@Singleton</span></span><br><span class="line">   <span class="function">CommandExecutor <span class="title">provideCommandExecutor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Command&gt; commandMap)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name -&gt; commandMap.get(name).exec();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule1</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">      ReusableModule.contributeCommands(binder)</span><br><span class="line">         .addBinding(<span class="string">"a"</span>)</span><br><span class="line">         .to(CommandA<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule2</span> <span class="keyword">implements</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">      ReusableModule.contributeCommands(binder)</span><br><span class="line">         .addBinding(<span class="string">"b"</span>)</span><br><span class="line">         .to(CommandB<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这里我们就可以在不改变原有代码功能之上，随意扩展自己的逻辑了！</p><h4 id="multiBind"><a href="#multiBind" class="headerlink" title="multiBind"></a>multiBind</h4><p>在上面的代码中我们看到了使用MapperBinder来存放map结构的注入对象，接下来我们可以看一下集合式的，可以分为两种情况：</p><ul><li>注入的对象是常量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">   Multibinder.newSetBinder(binder, String<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">addBinding</span>()</span></span><br><span class="line">      .toInstance("value");</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注入的对象是变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">   Multibinder.newSetBinder(binder, MyType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">addBinding</span>()</span></span><br><span class="line"><span class="class">      .<span class="title">to</span>(<span class="title">MySubType</span>.<span class="title">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面两种情况，当我们需要获取对象的时候，可以采用provider的方式来获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="function">MySubType <span class="title">provideMySubtype</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MySubType(<span class="string">"provided_value"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="genericBind"><a href="#genericBind" class="headerlink" title="genericBind"></a>genericBind</h4><p>讨论到这里，其实还有一种情况没有涉及，那就是范型，我们知道java在运行的时候会擦除范型，那么当我们想要获取范型信息的时候该怎么获取呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGenericType</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> T value;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyGenericType</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的范型类，我们可以通过上面的方式获取到MyGenericType这种类型的对象，但是我们如何获取范型上面的类型是什么呢？<strong>最常使用的方式就是创建一个匿名内部类来反应这个范型究竟是那种类型，我们在使用的时候可以将该匿名类作为一个key来绑定到擦除范型之后的类型之上</strong>，guice给我们提供了TypeLiteral来实现这个功能，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span> </span>&#123;</span><br><span class="line">   TypeLiteral&lt;MyGenericType&lt;String&gt;&gt; stringType = </span><br><span class="line">      <span class="keyword">new</span> TypeLiteral&lt;MyGenericType&lt;String&gt;&gt;() &#123;&#125;;</span><br><span class="line">   Multibinder.newSetBinder(binder, MyGenericType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">addBinding</span>()</span></span><br><span class="line"><span class="class">      .<span class="title">to</span>(<span class="title">stringType</span>)</span>;</span><br><span class="line">   TypeLiteral&lt;MyGenericType&lt;Integer&gt;&gt; intType = </span><br><span class="line">      <span class="keyword">new</span> TypeLiteral&lt;MyGenericType&lt;Integer&gt;&gt;() &#123;&#125;;</span><br><span class="line">   Multibinder.newSetBinder(binder, MyGenericType<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">      .<span class="title">addBinding</span>()</span></span><br><span class="line"><span class="class">      .<span class="title">to</span>(<span class="title">intType</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">MyGenericType&lt;Integer&gt; <span class="title">provideIntType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MyGenericType&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="function">MyGenericType&lt;String&gt; <span class="title">provideStringType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MyGenericType&lt;&gt;(<span class="string">"string"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h3><p>上面我们看到了guice中绑定依赖的方式，接下来我们来看一下，在绑定依赖之后，我们如果想要获取一个对象应该怎么办吧。Guice的injector更多的像是一个hashMap，该hashMap是Map&lt;Key<?>、Provider<?>&gt;这种结构，或者我们在spring中常见的ApplicationContext，我们想要获取某一个对象的话，可以直接通过<code>injector.getInstance(class)</code>的方式，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.inject.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoModule</span> <span class="keyword">extends</span> <span class="title">AbstractModule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在重写的方法中指定绑定关系，这里是指定一个字符串bean</span></span><br><span class="line">        bind(Key.get(String.class)).toInstance("wang er shuai");</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Provides</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">age</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// @provide有点类似于spring中的@Bean，用于在方法上注解来获取一个java bean，这里的bean是一个简单的数字9</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务bean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Inject</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hello "</span> + name + <span class="string">", your age is "</span> + age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这一步用于获取Module中的映射关系，</span></span><br><span class="line">        Injector injector = Guice.createInjector(<span class="keyword">new</span> DemoModule());</span><br><span class="line">        <span class="comment">// 通过Guice的DI生成我们所需要的对象，并执行方法进行测试</span></span><br><span class="line">        injector.getInstance(Person<span class="class">.<span class="keyword">class</span>).<span class="title">SayHello</span>()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来看一下Scope的概念及用法吧：在上面的代码中我们并没有看到Scope相关的代码，不过不要紧，这个本身也不难，我们就简单的分析一下吧。我们知道在spring 的 web应用中，我们经常使用的就是单例<code>Singleton</code>，在最上面的代码中我们获取Person类型的对象，如果我们再次调用该方法，尝试获取person对象的话，那么两个对象是否一致呢？答案是否定的！也就是说上面的代码中我们多次获取对象返回的是多个对象，那么有没有什么办法让我们能够复用对象呢？答案就是Scope！<em>这个和spring中的scope也是对应起来的，默认的情况下有5中scope</em></p><p>常见的指定scope的方式如下：</p><ul><li><p>标注在实现类上面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InMemoryTransactionLog</span> <span class="keyword">implements</span> <span class="title">TransactionLog</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* everything here should be threadsafe! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过bind代码实现</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(TransactionLog<span class="class">.<span class="keyword">class</span>).<span class="title">to</span>(<span class="title">InMemoryTransactionLog</span>.<span class="title">class</span>).<span class="title">in</span>(<span class="title">Singleton</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><ul><li>通过注解@Provides声明方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span> <span class="meta">@Singleton</span></span><br><span class="line"> <span class="function">TransactionLog <span class="title">provideTransactionLog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>除了上面的Scope之外还有lazy或者eager的策略供我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind(TransactionLog<span class="class">.<span class="keyword">class</span>).<span class="title">to</span>(<span class="title">InMemoryTransactionLog</span>.<span class="title">class</span>).<span class="title">asEagerSingleton</span>()</span>;</span><br></pre></td></tr></table></figure><h2 id="和Spring对比"><a href="#和Spring对比" class="headerlink" title="和Spring对比"></a>和Spring对比</h2><p>spring声明配置信息的时候，是在一个被@Configuration注解的类中，spring容器将这个类当作一个资源池。被@Configuration注解的类相较于基于xml文件的的spring的话，更多的像是一个<strong>beans</strong>标签，注意并不是bean标签！在装备具备依赖关系的对象的时候，spring同样也提供了@Autowired标签，该标签支持构造器注入、setter方法注入、field注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明javabean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用注解装配依赖关系</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accountService;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定包路径下的被@Component注解了的类扫描到容器中</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.baeldung.di.spring"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringMainConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取context并从容器中获取响应的对象</span></span><br><span class="line">ApplicationContext context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringMainConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">UserService userService = context.getBean(UserService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">assertNotNull(userService.getAccountService());</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Guice的injector更多的像是一个hashMap，该hashMap是Map&lt;Key<?>、Provider<?>&gt;这种结构，或者我们在spring中常见的ApplicationContext。在Module中配置接口和实现之间的关系，@Inject有点类似于@Autowired，不过功能更加强大，因为可以在构造函数上，也可以在字段上指定。Injector则类似于spring中的ApplicationContext，也即是整个容器。还有一点值得注意，我们通常会将bean Module化，这样更方便管理。另外，guice使用Key来表示一个可以被发现的<strong>依赖</strong>，上面Person类的构造函数中注入了两个依赖，这些依赖在Guice中是被当作Key的类型，也就是String 本质上是Key<string>，Integer本质上是Key<integer>。至于guice和spring的对比，详细建议参考这篇文章：<a href="https://www.baeldung.com/guice-spring-dependency-injection" target="_blank" rel="noopener">spring和guice对比</a>，<a href="https://medium.com/@andrus_a/guice-stories-part-1-dc24815db60" target="_blank" rel="noopener">guice stories</a>另外，我自己也基于jetty和guice完成了一款迷你的web框架，具体参考：<a href="https://github.com/southrivers/guice-jetty" target="_blank" rel="noopener">guice-with-jetty</a></integer></string></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java命令行解析库</title>
      <link href="/2020/04/18/java%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%BA%93/"/>
      <url>/2020/04/18/java%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近这一段时间在看apache druid的源码，看的过程中遇到了使用java解析命令行参数的库：airline，因此花了点时间看了一下文档并跟着例子学习了一下，并记录下来。<strong>简要的说明一下，airline是基于注释的java框架，用于在java中构建强大的git风格的CLI</strong>。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>show me the code！我们还是从demo说起吧</p><h2 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.rvesse.airline.SingleCommand;</span><br><span class="line"><span class="keyword">import</span> com.github.rvesse.airline.annotations.Arguments;</span><br><span class="line"><span class="keyword">import</span> com.github.rvesse.airline.annotations.Command;</span><br><span class="line"><span class="keyword">import</span> com.github.rvesse.airline.annotations.Option;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Command</span>(name = <span class="string">"getting-started"</span>, description = <span class="string">"We're just getting started"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GettingStarted</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Option</span>(name = &#123; <span class="string">"-f"</span>, <span class="string">"--flag"</span> &#125;, description = <span class="string">"An option that requires no values"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Arguments</span>(description = <span class="string">"Additional arguments"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; args;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义生成解析器</span></span><br><span class="line">        SingleCommand&lt;GettingStarted&gt; parser = SingleCommand.singleCommand(GettingStarted<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        GettingStarted cmd = parser.parse(args);</span><br><span class="line">        <span class="comment">// 解析阶段</span></span><br><span class="line">        cmd.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>)</span><br><span class="line">            System.out.println(<span class="string">"Arguments were "</span> + StringUtils.join(args, <span class="string">","</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在读懂上面的例子之前，我们还需要介绍一下airline中涉及的术语，不然说起来真的很拗口。</p><ul><li>Command Line Interface (CLI)：CLI是一组命令的集合的入口，这些命令可以是以group形式组织的。举个简单的例子，我们经常使用的git就可以认为是一个cli，git下面可以有很多组命令：git remote、 git add等。</li><li>Command：command是被用户调用的一个工具，简单点来说就是被@Command注解的类，一个Command可以归属于多个组。</li><li>Command Group：group是command的集合，group本身也是可以包含其他group的。</li><li>Option：和我们在命令行中常见的option是一致的</li><li>Arguments：arguments在这里和Option其实很相似，不过两者其实都是Command接收参数的方式，用途不同（但是可以相互实现）！</li></ul><p>介绍了上面的基本术语之后，我们再来看一下一个Command正常的使用流程。</p><ul><li>定义：定义阶段通常使用注解来完成，注解中涉及的概念如上，当然也可以使用builder硬编码的方式来实现，两者均可。我们上面使用的是注解来完成的。</li><li>解析：在定义完成之后，我们需要创建和运行解析器，</li><li>执行：这一步就可以解析从命令行传过来的参数了</li></ul><p>上面的quick start中的解释可以告一段落了，不过总的来说上面还是态弱鸡了，真是的生产环境中一般不会这么使用，接下来我们来看一下高级用法（有点像git风格的）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Cli</span>(name = <span class="string">"basic"</span>, </span><br><span class="line">    description = <span class="string">"Provides a basic example CLI"</span>,</span><br><span class="line">    defaultCommand = GettingStarted<span class="class">.<span class="keyword">class</span>, </span></span><br><span class="line"><span class="class">    <span class="title">commands</span> </span>= &#123; GettingStarted<span class="class">.<span class="keyword">class</span>, <span class="title">Tool</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">BasicCli</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 解析cli</span></span><br><span class="line">        com.github.rvesse.airline.Cli&lt;Runnable&gt; cli = <span class="keyword">new</span> com.github.rvesse.airline.Cli&lt;&gt;(BasicCli<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Runnable cmd = cli.parse(args);</span><br><span class="line">        <span class="comment">// 运行</span></span><br><span class="line">        cmd.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们看到，这里并不再是@Command来注解了，趣儿代之的是使用了@Cli注解，前面我们已经说过了Cli其实是一个命令行的入口，我们通常可以在@Cli中指定一系列的参数：</p><ul><li>name：该Cli的名称</li><li>description： 描述信息</li><li>defaultCommand： 默认的Command（如果用户没有指定要运行的command的话就会选用这个command）</li><li>commands：直属于Cli的command</li><li>group：直属于cli的group或者其他group的group，其中会携带commands信息</li></ul><p>在完成了cli的定义之后，我们需要解析该Cli，并会根据命令行的参数来选择command，最后都通过之后就可以真正的运行了。</p><p>注意分组信息可以在@Cli上指定，也可以在@Command上指定，两者的作用是一致的，@Cli会更灵活一些。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本次分析到此为止，后面如果有需要继续补充。参考链接：<a href="https://rvesse.github.io/airline/" target="_blank" rel="noopener">https://rvesse.github.io/airline/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>flink-demo</title>
      <link href="/2020/04/14/flink-demo/"/>
      <url>/2020/04/14/flink-demo/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>flink 是分布式流、批一体化平台，提供了数据分发、通信、容错的功能，flink的批处理构建在流式处理之上，支持迭代计算、内存管理等功能</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><ul><li>核心依赖：flink本身运行的时候包含的依赖，<strong>不包含连接器</strong></li></ul><p>对应的maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意事项：在idea中建议将scope更改为compile，否则会导致应用运行的时候抛出NoClassDefFountError</p><ul><li>应用依赖：特定的应用程序所需要的依赖，如我们从kafka中消费对应的数据需要<strong>连接器</strong></li></ul><p>maven 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-connector-kafka-0.10_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong><em>推荐添加 Maven Shade Plugin 去构建应用,将应用程序代码及其所有需要的依赖项打包到一个 jar-with-dependencies 的 jar 包中</em></strong>，并且这些第三方的依赖应该设置为compile，具体可以参考官网！</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>Flink是实现了分布式集合转换的标准化平台，<strong>通过addSource来创建集合，并可以应用一系列的转换操作，最终可以将数据通过addSink的方式写入到对应的存储系统</strong>。Flink 的source分为两种：</p><ul><li>有界的：DataSet API，对应的Env为StreamingExecutionEnvironment</li><li>无界的：DataStream API，对应的Env为ExecutionEnvironment</li></ul><p>对于上面的两种类型的数据，均是不可变的数据集合，也正是由于不可变，因此数据在并行、并发的处理的过程中才不需要考虑线程安全带来的问题，至于因此而导致的数据量的问题则是通过<del>data share来缩减的。（待查阅）</del></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><h3 id="batch-data"><a href="#batch-data" class="headerlink" title="batch data"></a>batch data</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.aggregation.Aggregations;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里可以有多种方式来获取Environment，之所以使用getEnvironment来获取，是因为该方法会根据上下文完成正确的</span></span><br><span class="line">        <span class="comment">// 工作，也就是说如果在idea中运行代码的话，会创建本机的环境，而如果通过命令行的方式提交到集群的话则会返回集群</span></span><br><span class="line">        <span class="comment">// 上的执行环境</span></span><br><span class="line">        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.fromElements(<span class="string">"hello world ! ni hao a ! ha ha ha !"</span>, <span class="string">"ni shi shui a ?"</span>)</span><br><span class="line">                .flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">                        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                            collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)<span class="comment">// 按照tuple的第0个字段进行分组并按照第一个字段加和</span></span><br><span class="line">                .groupBy(<span class="number">0</span>).aggregate(Aggregations.SUM, <span class="number">1</span>)</span><br><span class="line">                <span class="comment">// 这里是sink，会自动触发execute，因此此处不需要再用execute</span></span><br><span class="line">                .print();</span><br><span class="line"><span class="comment">//        env.execute("wc");</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="streaming-data"><a href="#streaming-data" class="headerlink" title="streaming data"></a>streaming data</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; windowCounts = env.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9000</span>).flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                    collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).keyBy(<span class="number">0</span>).timeWindow(Time.seconds(<span class="number">10</span>)).sum(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        windowCounts.print();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处不同于batch模式</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们完成整个作业的定义之后，还需要调用environment的execute来运行即可，该方法会返回一个JobExecutionResult的结果，包含了<em>执行耗时和累加器</em>的结果，如果不需要等待作业的执行结束，而仅仅是触发作业，可以使用executeAsync方法，该方法会返回一个JobClient对象，该对象可以和对应的作业进行交互。值得注意的是只有在调用了execute方法之后，作业才真正的执行，其之前的各种操作都是lazy的，主要的作用适用于生成JobGraph（大数据的核心即在于数据不动，程序动，这里的程序也就是我们生成的JobGraph，真正的执行过程就是将程序序列化发送到集群中的机器进行执行）。</p><h3 id="DataStream-API"><a href="#DataStream-API" class="headerlink" title="DataStream API"></a>DataStream API</h3><h4 id="Source"><a href="#Source" class="headerlink" title="Source"></a>Source</h4><p>我们从Source中获取原始数据，我们可以通过StreamExecutionEnvironment.addSource(sourceFunction)来添加一个Source，我们通常可以实现一个SourceFunction接口来串行的处理数据，也可以实现ParallelSourceFunction或者RichParallelSourceFunction接口来并发的处理数据流。当前已经存在一些定义好的source可供我们使用（env#）：</p><ul><li>基于文件：readFile、readTextFile &amp;&amp;</li><li>基于socket：socketTextStream</li><li>基于集合：fromCollection、fromElements、fromParallelCollection、generateSequence（用于生成序列）</li><li>第三方库：可能业务中最常见的数据源就是kafka，flink也为kafka提供了一套sorce：FlinkKafkaConsumer<em>，这里的</em>和kafka版本是对应起来的</li></ul><h4 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h4><h4 id="Sink"><a href="#Sink" class="headerlink" title="Sink"></a>Sink</h4><p>Sink用于消费DataStream中的数据，并将其推送到文件、socket或者打印出来，Flink提供了大量的依托于DataStream的Sink：</p><ul><li>writeAsText</li><li>writeAsCsv</li><li>print</li><li>writeUsingOutputFormat</li><li>writeToSocket</li><li>addSink</li></ul><p><strong>上面的这些算子中，addSink通常可以结合Flink的checkpoint来实现exactly-once的语义来消费数据。而write*多用于调试操作</strong></p><h4 id="Iterators（这里不是太明白）"><a href="#Iterators（这里不是太明白）" class="headerlink" title="Iterators（这里不是太明白）"></a>Iterators（这里不是太明白）</h4><p>flink 实现了迭代式流IterativeStream，由于DataStream可能永远不会完成，因此没有最大的迭代次数。有时候我们需要使用split来指定流的哪一部分反馈给迭代，使用filter指定哪一部分向后输出，要关闭迭代输出的话需要使用IterativeStream的closeWith(feedbackStream)方法，这里定义的feedbackStream将会反馈给迭代头部，使用filter可以定义向下传播的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">DataStream&lt;Long&gt; someIntegers = env.generateSequence(<span class="number">0</span>, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">IterativeStream&lt;Long&gt; iteration = someIntegers.iterate();</span><br><span class="line"></span><br><span class="line">DataStream&lt;Long&gt; minusOne = iteration.map(<span class="keyword">new</span> MapFunction&lt;Long, Long&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">map</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value - <span class="number">1</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Long&gt; stillGreaterThanZero = minusOne.filter(<span class="keyword">new</span> FilterFunction&lt;Long&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &gt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">iteration.closeWith(stillGreaterThanZero);</span><br><span class="line"></span><br><span class="line">DataStream&lt;Long&gt; lessThanZero = minusOne.filter(<span class="keyword">new</span> FilterFunction&lt;Long&gt;() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Long value)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &lt;= <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="运行时参数"><a href="#运行时参数" class="headerlink" title="运行时参数"></a>运行时参数</h4><h5 id="水位线"><a href="#水位线" class="headerlink" title="水位线"></a>水位线</h5><h5 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h5><h5 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h5><p>默认情况下，流中元素的传递并不是一个接一个的传递，而是一批数据传递，这一批数据的大小是可以通过配置文件控制的，不过这样带来的坏处就是会有延时，为了控制延时，我们通常可以使用<code>env.setBufferTimeout(timeoutMillis)</code>的方式，这样当buffer中的数据还没有填满，但是已经超时的情况下，数据就会被强制flush到下游去，默认的超时时间是100ms。<code>setBufferTimeout(-1)</code>可以使得缓冲区不填满就不发送，<code>setBufferTimeout(0)</code>则会使得数据到来之后就发出去，这样就会由批式变成流式，生产环境中应该避免这样。</p><h4 id="调试及运行"><a href="#调试及运行" class="headerlink" title="调试及运行"></a>调试及运行</h4><hr><p>说明：对于上述示例，在windows上可以使用 ncat -lk 9000来打开端口，对于linux平台则可以使用 nc -lk 9000 来完成端口的开启</p><hr><h3 id="处理数据特点（key-based）"><a href="#处理数据特点（key-based）" class="headerlink" title="处理数据特点（key based）"></a>处理数据特点（key based）</h3><p>在flink（其他分布式计算框架也同理）提供的各种转换操作通常都需要依赖于key（主要用来对数据进行分组），对于flink来说，key是有一定的要求的。<del>（flink的数据模型不是键值对？）</del></p><h4 id="Tuple"><a href="#Tuple" class="headerlink" title="Tuple"></a>Tuple</h4><p>Tuple的有效下标从0开始，不过对于多级嵌套的Tuple的话，没办法选到内层的Tuple相关的字段，这种情况下只能使用字段表达式来进行解决。</p><h4 id="字段表达式"><a href="#字段表达式" class="headerlink" title="字段表达式"></a>字段表达式</h4><p>所谓的字段表达式其实就是我们在后台中常说的POJO（通常使用PojoSerializer序列化的协议），具体规则如下：</p><ul><li>根据字段名称选择 POJO 的字段。</li><li>根据字段名称或 0 开始的字段索引选择 Tuple 的字段。例如 “f0” 和 “5” 分别指 Java Tuple 类型的第一个和第六个字段（这里的f是指field）。</li><li>可以选择 POJO 和 Tuple 的嵌套字段。 例如，一个 POJO 类型有一个“user”字段还是一个 POJO 类型，那么 “user.zip” 即指这个“user”字段的“zip”字段。<strong>任意嵌套和混合的 POJO 和 Tuple都是支持的</strong>，例如 “f1.user.zip” 或 “user.f3.1.zip”。</li><li>_可以使用 “*” 通配符表达式选择完整的类型。这也适用于非 Tuple 或 POJO 类型_？？？</li></ul><h4 id="键选择器"><a href="#键选择器" class="headerlink" title="键选择器"></a>键选择器</h4><p>可以通过KeySelector来最大程度的定制化键的选择，该函数将单个上流对象作为输入，并返回按照key算子操作之后的数据。</p><h3 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h3><p>转换函数一般是用户的核心逻辑，当前可以采用的定义转换函数的方式分别是：</p><ul><li>实现接口</li><li>匿名类</li><li>lambda函数</li><li><strong><em>富含数</em></strong>：对应的接口的命名规则是在接口的前面加上RichXXX，富函数为用户定义函数（map、reduce 等）额外提供了 4 个方法： open、close、getRuntimeContext 和 setRuntimeContext。这些方法有助于向函数传参（请参阅 向函数传递参数）、 创建和终止本地状态、访问广播变量（请参阅 广播变量）、访问诸如累加器和计数器等运行时信息（请参阅 累加器和计数器）和迭代信息（请参阅 迭代）。</li></ul><h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>累加器对于快速了解数据非常有用，不过当前累加器只有在job终止的时候才可以获取，因此能力有限，且应该是不能用于stream数据的记录，因为stream是无界的，_不会存在终止，不知道是不是存在其他的方式可以使用起来，待确定！_。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.JobExecutionResult;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.accumulators.IntCounter;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.RichFlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.RichMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.DataSet;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.aggregation.Aggregations;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccumulatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        DataSet&lt;String&gt; line = env.fromCollection(Arrays.asList(<span class="string">"hello world ni hao a !"</span>));</span><br><span class="line">        DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; res =line.map(<span class="keyword">new</span> RichMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> IntCounter counter = <span class="keyword">new</span> IntCounter();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于计数器或者累加器需要在rich对象中进行注册</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                getRuntimeContext().addAccumulator(<span class="string">"total"</span>, <span class="keyword">this</span>.counter);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).flatMap(<span class="keyword">new</span> RichFlatMapFunction&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String s, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] words = s.split(<span class="string">" "</span>);</span><br><span class="line">                <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">                    <span class="comment">// 统计单词的个数</span></span><br><span class="line">                    getRuntimeContext().getAccumulator(<span class="string">"total"</span>).add(<span class="number">1</span>);</span><br><span class="line">                    collector.collect(<span class="keyword">new</span> Tuple2&lt;String, Integer&gt;(word, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).groupBy(<span class="string">"f0"</span>).aggregate(Aggregations.SUM, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        res.writeAsText(<span class="string">"hello.txt"</span>);</span><br><span class="line"></span><br><span class="line">        JobExecutionResult result = env.execute();</span><br><span class="line"></span><br><span class="line">        System.out.println(result.getAccumulatorResult(<span class="string">"total"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Stream-API详解"><a href="#Stream-API详解" class="headerlink" title="Stream API详解"></a>Stream API详解</h2><h3 id="事件时间"><a href="#事件时间" class="headerlink" title="事件时间"></a>事件时间</h3><p>– watermark应该是可以理解为算子时间的</p><p>watermark是flink为了处理Eventtime窗口计算提出的一种机制，本质上也是时间。自定义的watermark会按照定制的策略生成一种系统的event，并会将这种event发送到下游的算子。接收到watermark的算子也因此可以调节自己的EventTime Clock（这里的Event Time可以近似的认为是算子的一种特性）。对于单流来说，WaterMark是单调递增的。</p><p>flink当前支持两种方式来产生watermark：</p><ul><li>Punctuated：数据流中每一个递增的EventTime都会产生一个watermark。这种方式会产生大量的Watermark对应的Event，会对下游的处理造成很大的压力。只有在实时性要求很高的场景才会采用这种方式生成watermark</li><li>Periodic：周期性（按照一定的时间间隔或者数据在达到一定的条数之后）产生一个watermark，生产环境中这种生成watermark的方式要求周期性包含时间和数量两个纬度上来生成。因为极端情况下，比如数据来的很慢，但是时间已经过去很久了，我们其实是很有必要针对这种数据来生成watermark的，来触发窗口操作。</li></ul><p>回过头来我们在看看Watermark机制如何解决上面的问题，上面的问题在于如何将迟来的EventTime 位11的元素正确处理。要解决这个问题我们还需要先了解一下EventTime window是如何触发的？ EventTime window 计算条件是当Window计算的<strong>Timer（在设定slide窗口之后timer会被切分成左闭右开的时间区间）</strong>时间戳 小于等于 当前系统的Watermak的时间戳时候进行计算</p><p>下面来对比一下watermark的作用：</p><h4 id="不使用watermark的window计算"><a href="#不使用watermark的window计算" class="headerlink" title="不使用watermark的window计算"></a>不使用watermark的window计算</h4><p><a href="https://blog.csdn.net/lmalds/article/details/52704170" target="_blank" rel="noopener">https://blog.csdn.net/lmalds/article/details/52704170</a></p><h4 id="使用watermark的window计算"><a href="#使用watermark的window计算" class="headerlink" title="使用watermark的window计算"></a>使用watermark的window计算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.MapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple3;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.TimeCharacteristic;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStreamSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.SingleOutputStreamOperator;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.AssignerWithPeriodicWatermarks;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.windowing.WindowFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.watermark.Watermark;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.assigners.TumblingEventTimeWindows;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.time.Time;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.windowing.windows.TimeWindow;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterMarkDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment executionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        executionEnvironment.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);</span><br><span class="line">        executionEnvironment.getConfig().setAutoWatermarkInterval(<span class="number">50L</span>);</span><br><span class="line">        executionEnvironment.setParallelism(<span class="number">1</span>);</span><br><span class="line">        System.out.println(executionEnvironment.getParallelism());;</span><br><span class="line"></span><br><span class="line">        DataStreamSource&lt;String&gt; stream = executionEnvironment.socketTextStream(<span class="string">"localhost"</span>, <span class="number">9000</span>);</span><br><span class="line"></span><br><span class="line">        SingleOutputStreamOperator&lt;Tuple2&lt;String, Long&gt;&gt; aaa = stream.map(<span class="keyword">new</span> MapFunction&lt;String, Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Long&gt; <span class="title">map</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String[] words = s.split(<span class="string">","</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;String, Long&gt;(words[<span class="number">0</span>], Long.parseLong(words[<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        aaa.assignTimestampsAndWatermarks(<span class="keyword">new</span> AssignerWithPeriodicWatermarks&lt;Tuple2&lt;String, Long&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Long currentTimestamp = Long.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Nullable</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Watermark <span class="title">getCurrentWatermark</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//                System.out.println("current timestamp is: " + currentTimestamp);</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Watermark(currentTimestamp-<span class="number">3000</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">extractTimestamp</span><span class="params">(Tuple2&lt;String, Long&gt; stringLongTuple2, <span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 更新时间</span></span><br><span class="line">                currentTimestamp = stringLongTuple2.f1;</span><br><span class="line">                <span class="keyword">return</span> currentTimestamp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">                .keyBy(e -&gt; e.f0)</span><br><span class="line">                .window(TumblingEventTimeWindows.of(Time.seconds(<span class="number">1L</span>)))</span><br><span class="line">                .apply(<span class="keyword">new</span> WindowFunction&lt;Tuple2&lt;String, Long&gt;, String, String, TimeWindow&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(String s, TimeWindow window, Iterable&lt;Tuple2&lt;String, Long&gt;&gt; input, Collector&lt;String&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                        Iterator&lt;Tuple2&lt;String, Long&gt;&gt; iterator = input.iterator();</span><br><span class="line">                        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">                            out.collect(iterator.next().toString());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).print();</span><br><span class="line"></span><br><span class="line">        executionEnvironment.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述的处理过程中，先是设置了并发度为1，然后通过本地调测发现，流中触发计算的时间点卡在startTime + window+3000s的时间点，这是由于上文设置了eventTime来处理数据，并且watermark设置了延迟的最大时间，因此这几个时间点加在一起就构成了触发的时间，<strong>，还需要更复杂的测试示例来验证更多特性</strong>，例如使用事件事件导致数据丢点的发生，猜测原因可能是一旦事件事件到达了之后，剩下的还没有到达的事件就会被丢弃了，因此，这种情况下应该是可以设置延迟事件来解决的，否则，一旦触发后续的点就会丢掉。另外在测试的过程中，发现如果并发度设置为2，则结果并不会输出，原因未知。</p><p><a href="https://yq.aliyun.com/articles/666056?spm=5176.10695662.1996646101.searchclickresult.1aa346a5kMFGqV" target="_blank" rel="noopener">https://yq.aliyun.com/articles/666056?spm=5176.10695662.1996646101.searchclickresult.1aa346a5kMFGqV</a></p><p><a href="https://blog.csdn.net/lmalds/article/details/52704170" target="_blank" rel="noopener">https://blog.csdn.net/lmalds/article/details/52704170</a></p><h2 id="数据序列化"><a href="#数据序列化" class="headerlink" title="数据序列化"></a>数据序列化</h2><p>flink kafka结合</p><h2 id="执行管理操作"><a href="#执行管理操作" class="headerlink" title="执行管理操作"></a>执行管理操作</h2><h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1><p>最近遇到一个需求，flink需要定时从数据库中读取数据加载到内存中，然后作为一份全局的配置来使用，自然就想起了广播这种模式，之前有接触过spark，因此对于广播有过一些认知，那就是spark中的broadcast是不可变的（不过看stackoverflow上有解决办法）。对应到flink这边，广播则是可以实现配置的动态更新。因此抽时间写了一个demo，以便后面查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.flink;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.MapStateDescriptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.typeinfo.Types;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.BroadcastStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.BroadcastProcessFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.source.RichSourceFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkBroadcast</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        env.setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        MapStateDescriptor&lt;Void, Map&lt;String, String&gt;&gt; stateDescriptor = <span class="keyword">new</span> MapStateDescriptor&lt;Void, Map&lt;String, String&gt;&gt;</span><br><span class="line">                (<span class="string">"test"</span>, Types.VOID, Types.MAP(Types.STRING, Types.STRING));</span><br><span class="line"></span><br><span class="line">        BroadcastStream&lt;Map&lt;String, String&gt;&gt; broadcastStream = env.addSource(<span class="keyword">new</span> RichSourceFunction&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> String[] name = <span class="keyword">new</span> String[]&#123;<span class="string">"wes"</span>, <span class="string">"wq"</span>, <span class="string">"wwl"</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> Integer[] age = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;Map&lt;String, String&gt;&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    Map&lt;String, String&gt; res = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                    res.put(name[i % <span class="number">3</span>], name[i % <span class="number">3</span>] + age[i % <span class="number">3</span>]);</span><br><span class="line">                    i++;</span><br><span class="line">                    sourceContext.collect(res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).broadcast(stateDescriptor);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        DataStream&lt;String&gt; dataStream = env.addSource(<span class="keyword">new</span> RichSourceFunction&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> String[] test = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"!"</span>&#125;;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(SourceContext&lt;String&gt; sourceContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    sourceContext.collect(test[i % <span class="number">3</span>]);</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    System.out.println(<span class="string">"i: "</span> + i);</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        dataStream.connect(broadcastStream).process(<span class="keyword">new</span> BroadcastProcessFunction&lt;String, Map&lt;String, String&gt;, String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            Map&lt;String, String&gt; map = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">(Configuration parameters)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.open(parameters);</span><br><span class="line">                map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">                map.put(<span class="string">"start"</span>, <span class="string">"start num0"</span>);</span><br><span class="line">                System.out.println(<span class="string">"init broadcast connection"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(String s, ReadOnlyContext readOnlyContext, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                collector.collect(<span class="string">"stream record: "</span> + s + <span class="string">", broad value is"</span> + map.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processBroadcastElement</span><span class="params">(Map&lt;String, String&gt; stringStringMap, Context context, Collector&lt;String&gt; collector)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                map = stringStringMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).print();</span><br><span class="line"></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">init broadcast connection</span><br><span class="line">stream record: hello, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">0</span></span><br><span class="line">stream record: world, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">1</span></span><br><span class="line">stream record: !, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">2</span></span><br><span class="line">stream record: hello, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">3</span></span><br><span class="line">stream record: world, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">4</span></span><br><span class="line">stream record: !, broad value is&#123;start=start num0&#125;</span><br><span class="line">i: <span class="number">5</span></span><br><span class="line">stream record: hello, broad value is&#123;wes=wes1&#125;</span><br><span class="line">i: <span class="number">6</span></span><br><span class="line">stream record: world, broad value is&#123;wes=wes1&#125;</span><br><span class="line">i: <span class="number">7</span></span><br><span class="line">stream record: !, broad value is&#123;wes=wes1&#125;</span><br><span class="line">i: <span class="number">8</span></span><br><span class="line">stream record: hello, broad value is&#123;wes=wes1&#125;</span><br><span class="line">i: <span class="number">9</span></span><br><span class="line">stream record: world, broad value is&#123;wes=wes1&#125;</span><br><span class="line">i: <span class="number">10</span></span><br><span class="line">stream record: !, broad value is&#123;wq=wq2&#125;</span><br><span class="line">i: <span class="number">11</span></span><br><span class="line">stream record: hello, broad value is&#123;wq=wq2&#125;</span><br><span class="line">i: <span class="number">12</span></span><br><span class="line">stream record: world, broad value is&#123;wq=wq2&#125;</span><br><span class="line">i: <span class="number">13</span></span><br><span class="line">stream record: !, broad value is&#123;wq=wq2&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>可以看到通过这种方式可以实现广播数据的更新，一般的情况下也是可以满足我们的业务需求了。</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1><p>native stream和mini batch有什么区别？？？</p><p>代码执行参考： <a href="https://riptutorial.com/apache-flink/example/27898/wordcount" target="_blank" rel="noopener">https://riptutorial.com/apache-flink/example/27898/wordcount</a>未完待续。。。。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>protobuf学习笔记</title>
      <link href="/2020/01/22/protobuf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/01/22/protobuf%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>protobuf（也叫做pb）是谷歌开源的一款序列化、反序列化的框架，由于其出色的效率、高效的编码格式使得数据在序列化、反序列化以及传输的过程中有很大的优势，因此在rpc数据交换或者数据存储中有很好的应用。</p><ul><li><p>优点：</p><ul><li>高效：这里的高效是指其在序列化、反序列化的过程中占用的时间特别少，究其原因是因为其只在字节流和对象之间进行转换，相较于其他的序列化、反序列化的框架如json，还要把对象组织称用户易于读懂的格式</li><li>节省带宽：由于其高效的编码方式，使得序列化之后的数据占用的空间特别小</li></ul></li><li><p>缺点：</p><ul><li>不易读懂：鉴于其高效的编码格式，使得数据在序列化或者反序列化之后很难读懂，也正因为如此，我们基本上没有在涉及前段开发的过程中使用pb这种协议来传输数据</li></ul></li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>笔者所用的语言是java，因此演示示例也适用java来演示。官网上有演示如何使用pb来定义java对象以及如何使用，不过很遗憾，这种演示方式在真正构建大型工程的时候很难，因为我们总不能把pb文件一个一个的编译，然后考到指定的目录，这有点不切实际，大型的项目更多的是会使用maven的插件来进行构建整个工程，如下演示如何使用maven插件来构建，工程的整体结构如下图所示：<img src="//southrivers.github.io/2020/01/22/protobuf学习笔记/project.png" alt>如下为maven需要的依赖：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.11&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.4.0&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;extensions&gt;</span><br><span class="line">      &lt;extension&gt;</span><br><span class="line">        &lt;groupId&gt;kr.motd.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;os-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.4.1.Final&lt;/version&gt;</span><br><span class="line">      &lt;/extension&gt;</span><br><span class="line">    &lt;/extensions&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">      &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.xolstice.maven.plugins&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;protobuf-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.5.0&lt;/version&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;protocArtifact&gt;</span><br><span class="line">            com.google.protobuf:protoc:<span class="number">3.1</span><span class="number">.0</span>:exe:$&#123;os.detected.classifier&#125;</span><br><span class="line">          &lt;/protocArtifact&gt;</span><br><span class="line">          &lt;pluginId&gt;grpc-java&lt;/pluginId&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">        &lt;executions&gt;</span><br><span class="line">          &lt;execution&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">              &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">          &lt;/execution&gt;</span><br><span class="line">        &lt;/executions&gt;</span><br><span class="line">      &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">  &lt;/build&gt;</span><br></pre></td></tr></table></figure><p>接下来我们使用protobuf3来编写一个模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>;</span><br><span class="line"></span><br><span class="line">option java_package = <span class="string">"com.h3c"</span>;</span><br><span class="line">option java_outer_classname = <span class="string">"PersonBuilder"</span>;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">     int32 id = <span class="number">1</span>;</span><br><span class="line">     string name = <span class="number">2</span>;</span><br><span class="line">     string email = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们使用pb的插件来生成对应的Java类，生成的java类最终会在target目录下，不过我们的工程是可以引用到的，如下：</p><p><img src="//southrivers.github.io/2020/01/22/protobuf学习笔记/pbfile.png" alt></p><p>这里需要注意，pom文件中的protoc版本最好和本机安装的保持一直，这样可以直接使用mvn clean install命令来生成对应的类，因为我自己在使用的时候发现会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc-gen-grpc-java: program not found or is not executable</span><br></pre></td></tr></table></figure><p>这是因为网上的一些教程通常会指定：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;goal&gt;compile-custom&lt;/goal&gt;</span><br></pre></td></tr></table></figure><p>选项，将这个选项去掉后就可以正常的打包了。最后我们就可以在工程中引用这些类，测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InvalidProtocolBufferException </span>&#123;</span><br><span class="line">        PersonBuilder.Person.Builder builder = PersonBuilder.Person.newBuilder();</span><br><span class="line">        PersonBuilder.Person person = builder.setId(<span class="number">1</span>)</span><br><span class="line">                .setName(<span class="string">"wes"</span>)</span><br><span class="line">                .setEmail(<span class="string">"wes@gmail.com"</span>).build();</span><br><span class="line">        <span class="keyword">byte</span>[] pb = person.toByteArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : pb) &#123;</span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PersonBuilder.Person p1 = PersonBuilder.Person.parseFrom(pb);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的测试结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">119</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="number">26</span></span><br><span class="line"><span class="number">13</span></span><br><span class="line"><span class="number">119</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">115</span></span><br><span class="line"><span class="number">64</span></span><br><span class="line"><span class="number">103</span></span><br><span class="line"><span class="number">109</span></span><br><span class="line"><span class="number">97</span></span><br><span class="line"><span class="number">105</span></span><br><span class="line"><span class="number">108</span></span><br><span class="line"><span class="number">46</span></span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="number">111</span></span><br><span class="line"><span class="number">109</span></span><br><span class="line">id: <span class="number">1</span></span><br><span class="line">name: <span class="string">"wes"</span></span><br><span class="line">email: <span class="string">"wes@gmail.com"</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>相较于json这种序列化仅仅包含字符串和数字类型，pb的类型则要丰富的多（不过pb的模型应该是不具备继承特性的，后续补充），具体可以参考以下文章：</p><p>[pb终极教程] <a href="https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/" target="_blank" rel="noopener">https://colobu.com/2019/10/03/protobuf-ultimate-tutorial-in-go/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hdfs datanode</title>
      <link href="/2020/01/19/hdfs-datanode/"/>
      <url>/2020/01/19/hdfs-datanode/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>hdfs datanode采用块的方式存放hdfs数据，datanode具有以下特点：</p><ul><li>datanode会通过心跳维持和namenode的联系，心跳的响应同样会携带namenode的指令信息。</li><li>客户端在读写数据的时候，会直接和datanode建立连接完成数据块的读写，并在读写完成之后将相信息汇报给namenode</li></ul><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>在介绍datanode详细信息之前，我们有必要对当前的hdfs的整体架构有一个清晰的认识</p><h2 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h2><p>hdfs的架构并不是一成不变的，在2.x的时候hdfs的整体架构就发生了重大的变更，笔者所看的包括业务中使用到的是2.6版本的代码，因此讲解也将会使用2.x的架构来进行讲解，不过在讲解2.x的架构之前，还是有必要对旧的版本的架构有一个清晰的认知，这样才可以更好的理解现有的架构所带来的好处。</p><h3 id="hdfs-2-x之前的架构"><a href="#hdfs-2-x之前的架构" class="headerlink" title="hdfs 2.x之前的架构"></a>hdfs 2.x之前的架构</h3><p><img src="//southrivers.github.io/2020/01/19/hdfs-datanode/hdfs-1.x1.png" alt>如上图所示为hdfs 1.x的逻辑示意图，下面对上面的架构进行简单的描述以下，hdfs从逻辑上可以分为两层（外面大的实线框所示）：</p><ul><li>命名空间管理层：用于管理整个文件系统的命名空间，管控的对象为文件、目录、文件包含的数据块的信息，对外提供常见的文件系统的操作（主要是针对元数据的管理）</li><li>数据块存储管理层：<ul><li>数据块管理：管理数据节点信息和数据块信息，提供<strong>数据块元信息</strong>的操作接口</li><li>存储管理：管理datanode上数据块的物理存储，提供<strong>数据块数据</strong>操作的接口namenode实现了命名空间管理层和数据块管理层，datanode则主要实现了数据块存储管理层中的存储管理层，这样datanode相对来说功能单一，只是提供了数据块数据操作的接口，并通过心跳将数据块上报到namenode，之后继续执行namenode下发的指令。而namenode实现的功能则几种管理元数据（namespace元数据、数据块元数据）。这种架构带来的问题也很明显：</li></ul></li><li>所有的元数据都保存在namenode上，当datanode规模达到一定程度之后，namenode用于管理元数据的内存就会被撑爆</li><li>所有的数据操作基本都需要和namenode进行交互，因此namenode成为性能的瓶颈</li><li>命名空间管理和数据块管理耦合在一起，难以让其他服务单独使用数据块管理的功能（如：hbase）</li></ul><p>一言以蔽之，这种架构耦合度比较高，namenode成为整个系统的瓶颈。</p><h3 id="hdfs-2-x之后的架构"><a href="#hdfs-2-x之后的架构" class="headerlink" title="hdfs 2.x之后的架构"></a>hdfs 2.x之后的架构</h3><p>在前面提到的hdfs的架构中，我们了解到namenode成为整个集群的瓶颈，想要解除这种限制可以的方法就需要能够水平的扩展namenode（有点类似于一致性hash）。hdfs 2.x提供了联邦（federation）的机制，federation架构中的hdfs集群可以定义多个namespace，这些namespace分别存放在不同的namenode上，而namenode之间是相互独立的（这又有点像是分段锁的机制）。<del>书上说datanode会想集群中所有的namenode注册，并周期性的向所有的所有的namenode进行块汇报，此处存疑，如果是这样的话，namenode根本没有水平扩展</del>datanode同样会通过心跳的机制获取并执行namenode下发的指令信息。其整体架构如下图所示：<img src="//southrivers.github.io/2020/01/19/hdfs-datanode/hdfs-2.x.png" alt></p><p>hdfs的联邦机制引入了两个新的概念：</p><ul><li>blockpool(块池)：一个块池由属于同一个命名空间的所有的数据块组成，块池中的数据块可以存放在集群的所有的节点上，因此数据节点上报数据其实是通过datanode上报到所有的namenode，而namenode之间因为是不同的命名空间，因此namenode之间是相互隔离的</li><li>namespacevolume（命名空间卷）：一个namenode管理的命名空间及对应的块池一起被成为命名空间卷</li></ul><p>相对于旧的架构federation 所带来的好处也是显而易见的，那就是支持命名空间的扩展，在安全性上面同样也支持命名空间级别的隔离，后续想要做租户的管理应该也是可以通过这种方式来实现。<strong>（之前一直有一个疑惑，那就是datanode会向所有的namenode进行数据块的汇报，这样不是会导致集群的规模没办法真正的扩大，这种考虑的方向是把数据节点当作一个整体来进行考虑的，不过真实的情况应该是，考虑数据节点上的数据块，也就是将数据块作为基本的单位来进行考虑，一个namenode下所支持的数据块的数量是会受到namenode内存大小的限制）</strong>在介绍了<strong>整体</strong>的架构之后，我们从业务的视角来观察一下<strong>datanode</strong>的结构。</p><h2 id="datanode业务分层"><a href="#datanode业务分层" class="headerlink" title="datanode业务分层"></a>datanode业务分层</h2><p>好的业务一定是分层的，分层是为了更好的解耦和逻辑的复用，我们接下来看一下datanode的业务分层，并快速的过一下每一层锁实现的功能，如下所示：<img src="//southrivers.github.io/2020/01/19/hdfs-datanode/hdfs-logical.png" alt></p><h3 id="datanode数据层"><a href="#datanode数据层" class="headerlink" title="datanode数据层"></a>datanode数据层</h3><p>datanode数据层在我看来和我们后台的持久层并没有什么实质区别，只不过一个是数据库，一个是文件系统而已。数据层又可以分为两个部分：</p><ul><li>data storage（存储管理）：datanode上包含的数据块会通过块池（blockpoolslicestorage）的方式进行组织，存储管理就是通过数据块的管理<strong>实现磁盘的管理</strong></li><li>fsdataset（文件系统数据集）：抽象了datanode上的数据块的管理，要注意datanode上的数据块管理的组织方式和namenode命名空间卷是一致的，datanode会通过fsvolumeimpl来进行管理数据块，而一个fsvolumeimpl就对应了一个命名空间卷。</li></ul><h3 id="datanode逻辑层"><a href="#datanode逻辑层" class="headerlink" title="datanode逻辑层"></a>datanode逻辑层</h3><p>逻辑层是在数据层的基础之上进行的封装，主要的作用是和namenode进行交互，具体的执行逻辑可以分为：</p><ul><li>blockpoolmanager：管理所有块池的接口（块池的信息是存放在namenode中的），blockpoolmanager会持有多个bpofferservice来分别对每一个块池进行管理（块池和命名空间卷一一对应），每一个bpofferservice都会持有两个bpofferserviceactor来分别向每一个命名空间卷的active namenode和standby namenode进行管理</li><li>datablockscanner：周期性的扫描数据块并对数据块进行校验</li><li>directoryscanner：周期性的通过磁盘上的数据更新内存中的元数据</li></ul><h3 id="datanode服务层"><a href="#datanode服务层" class="headerlink" title="datanode服务层"></a>datanode服务层</h3><p>是服务层更多的是datanode对外提供的服务，主要分为以下三块</p><ul><li>httpserver：对外提供http服务用于展示datanode的状态</li><li>ipcserver：rpc服务端，用来响应client、namenode、datanode的请求</li><li>dataxceiverserver： 数据传输服务，用于构建datanode和client以及其他的datanode之间的数据流</li></ul><h1 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h1><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>try with resource</title>
      <link href="/2020/01/16/try-with-resource/"/>
      <url>/2020/01/16/try-with-resource/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>thread group使用</title>
      <link href="/2020/01/16/thread-group%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/01/16/thread-group%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>看源代码中总免不了一些不是太熟悉的知识，本节过一下线程组的相关知识，以便后续快速翻阅。</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>事出必有因，线程组的出现自然也有一定的原因，那就是方便线程的管理，线程组是树状的结构，整体如下：<img src="//southrivers.github.io/2020/01/16/thread-group使用/threadgroup.png" alt>简单说明一下，每一个线程都会隶属于一个线程组，线程组也都会有父线程组，依次向上查找可以找到system线程组。</p><ul><li>jvm创建的system线程组主要是用来管理jvm系统任务的线程组，如垃圾回收。</li><li>system线程组的直属线程组是main线程组，该线程组至少包含一个main线程，用于执行main方法。</li><li>main线程组的子线程组就是应用程序级别的线程组，这些线程组一般是用户创建的。<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1>上面简要的介绍了一下线程组的整体结构，接下来代码演示一下线程组的一些用法</li></ul><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(Thread.currentThread().getThreadGroup(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadGroup</span><span class="params">(ThreadGroup parent, String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(checkParentAccess(parent), parent, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是threadgroup的两个构造函数，由上面的两个构造函数可以看到，我们可以仅指定线程组的名称，这样默许创建的线程组隶属于当前线程所在的线程组。当然我们也可以明确的指定所创建的线程组的父线程组，这样所创建的线程组的父线程组即是我们在构造函数中指定的线程组</p><h2 id="线程组信息查看"><a href="#线程组信息查看" class="headerlink" title="线程组信息查看"></a>线程组信息查看</h2><p>这里主要涉及到线程组相关的API，暂时可以先忽略，待需要的时候查看即可</p><h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><p>下面以终止线程组中所有的线程的个数为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ThreadGroup tg = <span class="keyword">new</span> ThreadGroup(<span class="string">"aaa"</span>);</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Mythread(tg, <span class="string">"t1"</span>);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Mythread(tg, <span class="string">"t2"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        System.out.println(<span class="string">"before interrupt"</span> + tg.activeCount());</span><br><span class="line">        tg.interrupt();</span><br><span class="line">        <span class="comment">// 获取当前线程组至下所有的活动的线程的个数，该方法返回的是大约的数量</span></span><br><span class="line">        System.out.println(<span class="string">"after interrupt"</span> + tg.activeCount());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Mythread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Mythread</span><span class="params">(ThreadGroup tg, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(tg, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="string">"a"</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"group"</span> + Thread.currentThread().getThreadGroup().getName() + <span class="string">",thread "</span> +Thread.currentThread().getName());</span><br><span class="line">                    <span class="string">"a"</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"group"</span> + Thread.currentThread().getThreadGroup().getName() + <span class="string">",thread "</span> +Thread.currentThread().getName() + <span class="string">"terminated!"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的执行结果是，两个线程先后被激活，在等待了10s过后，两个线程又先后被终止</p><p><em>线程、临界资源、cpu调度 有点像是工人、作业、和工作车间的关系</em></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面是java线程组的概要介绍，主要是为了方便后续使用快速查阅，如果在查看源码的过程发现新的用法会持续更新</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hdfs 学习总结</title>
      <link href="/2019/12/29/hdfs-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/12/29/hdfs-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一入hadoop深似海，从此鸡犬不安宁。最近使用容器做算法训练的项目有用到大数据平台，经常会出现容器示例连接hdfs datanode获取数据超时的问题，因此需要了解并修复或者规避这种问题。</p><h1 id="hdfs-基础"><a href="#hdfs-基础" class="headerlink" title="hdfs 基础"></a>hdfs 基础</h1><h1 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hbase 入坑记</title>
      <link href="/2019/12/17/hbase-%E5%85%A5%E5%9D%91%E8%AE%B0/"/>
      <url>/2019/12/17/hbase-%E5%85%A5%E5%9D%91%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h1 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
        <tags>
            
            <tag> hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker二三事</title>
      <link href="/2019/12/17/docker%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2019/12/17/docker%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul><li>copy on write技术</li></ul><p>写时复制技术在linux进程管理中有使用，在docker中也有使用</p><ul><li>镜像 联合文件系统</li></ul><p>镜像和容器的关系类似于程序和进程之间的关系，</p><h1 id="docker架构"><a href="#docker架构" class="headerlink" title="docker架构"></a>docker架构</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h2 id="镜像制作"><a href="#镜像制作" class="headerlink" title="镜像制作"></a>镜像制作</h2><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>http协议详解</title>
      <link href="/2019/12/09/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/12/09/http%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<!-- 项目备份18124720464@2163.gdYHNCKQSG02810086https://github.com/jiankunking/books-recommendation.githttps://github.com/quanke/design-pattern-java.git -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sentry学习总结</title>
      <link href="/2019/11/23/sentry%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/23/sentry%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>sentry是大数据安全组件，用于管控hive、hbase等组件权限的控制，在hadoop3.0之后使用到的安全组件是ranger，sentry已经废弃，不过很多大数据平台版本依然是2.x，而且这种安全组件原理也是相通的，因此有必要研究一下（主要是最近被分到了这个组件，😄），由于在工程实践中我们这里更多的是使用sentry管控hive的权限，因此有必要在介绍sentry之前对hive的体系结构进行说明。</p><h1 id="HIVE概述"><a href="#HIVE概述" class="headerlink" title="HIVE概述"></a>HIVE概述</h1><h2 id="HIVE架构"><a href="#HIVE架构" class="headerlink" title="HIVE架构"></a>HIVE架构</h2><p>如下图所示为hive的架构：<img src="//southrivers.github.io/2019/11/23/sentry学习总结/hive%E6%9E%B6%E6%9E%84.png" alt></p><ul><li>UI：hive的客户端，包含了hiveCli、beeLine，用户通过UI来实现自己的操作，CliDriver是SQL本地直接编译，然后访问metastore，并提交作业，是重客户端，BeeLine会将SQL提交给Hive Server2，由Hive server2编译，然后访问metastore，并提交作业，是轻客户端。（因此在使用sentry来管控权限的时候，通过hiveCli是无法完美的做到权限管控的，通过beeLine来进行操作才是可以，原因见下面hive的扩展机制）</li><li>Driver：接收查询请求，并处理会话</li><li>Complier：解析查询语句，做语义分析，借助于metastore来生成执行计划</li><li>Execution Engine：用来执行生成的执行计划，是Hive和Hadoop的桥梁</li><li>metastore：提供hive元数据相关的服务</li></ul><h2 id="HIVE扩展机制"><a href="#HIVE扩展机制" class="headerlink" title="HIVE扩展机制"></a>HIVE扩展机制</h2><p>下面来看一下HIVE中存在的扩展机制，sentry的权限的控制就是基于这种扩展机制完成的：<img src="//southrivers.github.io/2019/11/23/sentry学习总结/hive%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6.png" alt>在生产环境中，hive通常会对应3个不同的进程，这些进程分别是Hive server、Metastore、RDBMS，其中提供扩展机制的是：</p><ul><li>Metastore的Listener</li><li>hive server的Hook</li></ul><p>测试需要，我本地搭建了一个hive的环境，下面是针对Listener和Hook的测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.MetaStorePreEventListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.api.InvalidOperationException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.api.MetaException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.api.NoSuchObjectException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.events.PreEventContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomListener1</span> <span class="keyword">extends</span> <span class="title">MetaStorePreEventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomListener1</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line">        System.out.println(<span class="string">"初始化 CustomListener1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(PreEventContext preEventContext)</span> <span class="keyword">throws</span> MetaException, NoSuchObjectException, InvalidOperationException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MetaStorePreEventListener"</span> + preEventContext + preEventContext.getEventType());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.conf.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.MetaStoreEventListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.api.MetaException;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.events.CreateTableEvent;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.metastore.events.DropTableEvent;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomListener</span> <span class="keyword">extends</span> <span class="title">MetaStoreEventListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomListener</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(config);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreateTable</span><span class="params">(CreateTableEvent tableEvent)</span> <span class="keyword">throws</span> MetaException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wes create table : "</span> + tableEvent.getTable());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDropTable</span><span class="params">(DropTableEvent tableEvent)</span> <span class="keyword">throws</span> MetaException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"wes drop table : "</span> + tableEvent.getTable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.hooks.ExecuteWithHookContext;</span><br><span class="line"><span class="keyword">import</span> org.apache.hadoop.hive.ql.hooks.HookContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HiveExampleHook</span> <span class="keyword">implements</span> <span class="title">ExecuteWithHookContext</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HookContext hookContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello wes, this is hive hook !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是将这些listener、hook注册到hive之后运行相关的DDL、DML操作的时候触发的事件，如下：<img src="//southrivers.github.io/2019/11/23/sentry学习总结/hive%E6%89%A9%E5%B1%95%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA.png" alt>上面测试的Listener和Hook也是sentry使用到的Listener和Hook，sentry中使用Hook鉴权，使用Listener监听权限及相关的元数据的变更， 并通知到服务端，在sentry的listener中会从生成的事件中获取事件的id，并将事件的id记录到hive的metastore中， 之后hive的hivemetastoreclient定时拉取相关的事件并更新到sentry server端的数据库中， 但是在实际测试的过程中却发现应该存在的事件id真实情况却是null， 线上测试环境中有相关的指标，怀疑和使用的hive版本有关系或并非所有的event都有eventid。 查看hive的metastore所使用到的数据库发现有表专门对notification进行了记录，下面展示了eventid为空的情况：<img src="//southrivers.github.io/2019/11/23/sentry学习总结/id%E4%B8%BA%E7%A9%BA.png" alt>关于hive的相关的知识就到这里，下面我们来看一下sentry的整体架构。</p><h1 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h1><h2 id="ER关系图"><a href="#ER关系图" class="headerlink" title="ER关系图"></a>ER关系图</h2><p>下图展示了sentry的实体关系图（有些表的作用尚不清楚）<img src="//southrivers.github.io/2019/11/23/sentry学习总结/sentryER%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt>上面的关系表可以看到的是权限的控制是通过RBAC的方式，不过这里的角色是和group绑定的，并不是user，可以让用户加入不同的组来完成权限的控制，不过用户和组的绑定关系并没有对应的表，而是复用了hadoop中user和group的关系，这一点不论从当前的表中还是代码中都可以得到印证。</p><h2 id="sentry整体架构"><a href="#sentry整体架构" class="headerlink" title="sentry整体架构"></a>sentry整体架构</h2><p><img src="//southrivers.github.io/2019/11/23/sentry学习总结/sentry%E6%9E%B6%E6%9E%84.png" alt>如上图所示为sentry整体架构图，其中sentry-binding就是利用了Hive上面的扩展机制，分别使用Listener和Hook对数据的DDL、DML操作进行权限的控制，sentry实现的Listener和Hook的主要的作用：</p><ul><li>Listener主要是针对DDL操作发布对应的事件的id，这样sentryServer端会使用HMSFollower从hive的metastore处进行同步相关的数据。</li><li>Hook的话，会截取DML中的信息，并进行鉴权操作，也会截取DDL中的信息进行授权操作，这个具体可以看下面的代码</li></ul><h2 id="权限的grant、revoke以及权限的校验"><a href="#权限的grant、revoke以及权限的校验" class="headerlink" title="权限的grant、revoke以及权限的校验"></a>权限的grant、revoke以及权限的校验</h2><p>在hive-binding模块的HiveAuthzBindingHook的postAnalyze中会将task转换成SentryGrantRevokeTask，SentryGrantRevokeTask中重写的execute方法中通过RPC请求执行了权限的grant、revoke操作。HiveAuthzBindingHook 继承了AbstractSemanticAnalyzerHook，重写的两个重要的方法分别是preAnalyze、postAnalyze两个方法，我们来看一下这两个方法所做的操作：</p><h3 id="client端鉴权操作（sentry-binding模块）"><a href="#client端鉴权操作（sentry-binding模块）" class="headerlink" title="client端鉴权操作（sentry-binding模块）"></a>client端鉴权操作（sentry-binding模块）</h3><h4 id="preAnalyze"><a href="#preAnalyze" class="headerlink" title="preAnalyze"></a>preAnalyze</h4><p>下面是preAnalyze方法，我们可以看到preAnalyze所做的操作仅仅是提取hiveSQL语句中的分区、库、表等信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ASTNode <span class="title">preAnalyze</span><span class="params">(HiveSemanticAnalyzerHookContext context, ASTNode ast)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (ast.getToken().getType()) &#123;</span><br><span class="line">  <span class="comment">// Hive parser doesn't capture the database name in output entity, so we store it here for now</span></span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_CREATEDATABASE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERDATABASE_PROPERTIES:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DROPDATABASE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SWITCHDATABASE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DESCDATABASE:</span><br><span class="line">      <span class="comment">// 针对库的操作，只需要提取对应的数据库即可</span></span><br><span class="line">      currDB = <span class="keyword">new</span> Database(BaseSemanticAnalyzer.unescapeIdentifier(ast.getChild(<span class="number">0</span>).getText()));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_CREATETABLE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_CREATEVIEW:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Compiler doesn't create read/write entities for create table.</span></span><br><span class="line"><span class="comment">       * Hence we need extract dbname from db.tab format, if applicable</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      currDB = extractDatabase((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DROPTABLE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DROPVIEW:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SHOW_CREATETABLE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_SERIALIZER:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERVIEW_ADDPARTS:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERVIEW_DROPPARTS:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERVIEW_PROPERTIES:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERVIEW_RENAME:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERVIEW:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DROPINDEX:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_LOCKTABLE:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_UNLOCKTABLE:</span><br><span class="line">      currTab = extractTable((ASTNode)ast.getFirstChildWithType(HiveParser.TOK_TABNAME));</span><br><span class="line">      currDB = extractDatabase((ASTNode) ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_CREATEINDEX:</span><br><span class="line">      currTab = extractTable((ASTNode)ast.getFirstChildWithType(HiveParser.TOK_TABNAME));</span><br><span class="line">      currDB = extractDatabase((ASTNode) ast.getChild(<span class="number">0</span>));</span><br><span class="line">      indexURI = extractTableLocation(ast);<span class="comment">//As index location is captured using token HiveParser.TOK_TABLELOCATION</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERINDEX_REBUILD:</span><br><span class="line">      currTab = extractTable((ASTNode)ast.getChild(<span class="number">0</span>)); <span class="comment">//type is not TOK_TABNAME</span></span><br><span class="line">      currDB = extractDatabase((ASTNode) ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SHOW_TABLESTATUS:</span><br><span class="line">      currDB = extractDatabase((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">int</span> children = ast.getChildCount();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; children; i++) &#123;</span><br><span class="line">        ASTNode child = (ASTNode) ast.getChild(i);</span><br><span class="line">        <span class="keyword">if</span> (child.getToken().getType() == HiveParser.Identifier) &#123;</span><br><span class="line">          currDB = <span class="keyword">new</span> Database(child.getText());</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//loosing the requested privileges for possible wildcard tables, since</span></span><br><span class="line">      <span class="comment">//further authorization will be done at the filter step and those unwanted will</span></span><br><span class="line">      <span class="comment">//eventually be filtered out from the output</span></span><br><span class="line">      currTab = Table.ALL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_RENAME:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_PROPERTIES:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_DROPPARTS:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_RENAMECOL:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_ADDCOLS:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_REPLACECOLS:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SHOW_TBLPROPERTIES:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SHOWINDEXES:</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_SHOWPARTITIONS:</span><br><span class="line">      <span class="comment">//token name TOK_TABNAME is not properly set in this case</span></span><br><span class="line">      currTab = extractTable((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      currDB = extractDatabase((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_MSCK:</span><br><span class="line">      extractDbTableNameFromTOKTABLE((ASTNode) ast.getChild(<span class="number">1</span>));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE_ADDPARTS:</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * Compiler doesn't create read/write entities for create table.</span></span><br><span class="line"><span class="comment">       * Hence we need extract dbname from db.tab format, if applicable</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      currTab = extractTable((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      currDB = extractDatabase((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">      <span class="comment">// 解析sql中的分区</span></span><br><span class="line">      partitionURI = extractPartition(ast);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_CREATEFUNCTION:</span><br><span class="line">      String udfClassName = BaseSemanticAnalyzer.unescapeSQLString(ast.getChild(<span class="number">1</span>).getText());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        CodeSource udfSrc =</span><br><span class="line">            Class.forName(udfClassName, <span class="keyword">true</span>, Utilities.getSessionSpecifiedClassLoader())</span><br><span class="line">                .getProtectionDomain().getCodeSource();</span><br><span class="line">        <span class="keyword">if</span> (udfSrc == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(<span class="string">"Could not resolve the jar for UDF class "</span> + udfClassName);</span><br><span class="line">        &#125;</span><br><span class="line">        String udfJar = udfSrc.getLocation().getPath();</span><br><span class="line">        <span class="keyword">if</span> (udfJar == <span class="keyword">null</span> || udfJar.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(<span class="string">"Could not find the jar for UDF class "</span> + udfClassName +</span><br><span class="line">              <span class="string">"to validate privileges"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        udfURIs.add(parseURI(udfSrc.getLocation().toString(), <span class="keyword">true</span>));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        List&lt;String&gt; functionJars = getFunctionJars(ast);</span><br><span class="line">        <span class="keyword">if</span> (functionJars.isEmpty()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(<span class="string">"Error retrieving udf class:"</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Add the jars from the command "Create function using jar" to the access list</span></span><br><span class="line">          <span class="comment">// Defer to hive to check if the class is in the jars</span></span><br><span class="line">          <span class="keyword">for</span>(String jar : functionJars) &#123;</span><br><span class="line">            udfURIs.add(parseURI(jar, <span class="keyword">false</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// create/drop function is allowed with any database</span></span><br><span class="line">      currDB = Database.ALL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DROPFUNCTION:</span><br><span class="line">      <span class="comment">// create/drop function is allowed with any database</span></span><br><span class="line">      currDB = Database.ALL;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_LOAD:</span><br><span class="line">      String dbName = BaseSemanticAnalyzer.unescapeIdentifier(ast.getChild(<span class="number">1</span>).getChild(<span class="number">0</span>).getChild(<span class="number">0</span>).getText());</span><br><span class="line">      currDB = <span class="keyword">new</span> Database(dbName);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_DESCTABLE:</span><br><span class="line">      currDB = getCanonicalDb();</span><br><span class="line">      <span class="comment">// For DESCRIBE FORMATTED/EXTENDED ast will have an additional child node with value</span></span><br><span class="line">      <span class="comment">// "FORMATTED/EXTENDED".</span></span><br><span class="line">      isDescTableBasic = (ast.getChildCount() == <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> HiveParser.TOK_TRUNCATETABLE:</span><br><span class="line">      <span class="comment">// SENTRY-826:</span></span><br><span class="line">      <span class="comment">// Truncate empty partitioned table should throw SemanticException only if the</span></span><br><span class="line">      <span class="comment">// user does not have permission.</span></span><br><span class="line">      <span class="comment">// In postAnalyze, currOutDB and currOutTbl will be added into outputHierarchy</span></span><br><span class="line">      <span class="comment">// which will be validated in the hiveAuthzBinding.authorize method.</span></span><br><span class="line">      Preconditions.checkArgument(ast.getChildCount() == <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// childcount is 1 for table without partition, 2 for table with partitions</span></span><br><span class="line">      Preconditions.checkArgument(ast.getChild(<span class="number">0</span>).getChildCount() &gt;= <span class="number">1</span>);</span><br><span class="line">      ASTNode tableTok = (ASTNode) ast.getChild(<span class="number">0</span>).getChild(<span class="number">0</span>);</span><br><span class="line">      Preconditions.checkArgument(tableTok.getChildCount() &gt;= <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">if</span> (tableTok.getChildCount() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// If tableTok chilcount is 1, tableTok does not has database information, use current working DB</span></span><br><span class="line">        currOutDB = extractDatabase((ASTNode) ast.getChild(<span class="number">0</span>));</span><br><span class="line">        currOutTab = extractTable((ASTNode) tableTok.getChild(<span class="number">0</span>));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If tableTok has fully-qualified name(childcount is 2),</span></span><br><span class="line">        <span class="comment">// get the db and table information from tableTok.</span></span><br><span class="line">        extractDbTableNameFromTOKTABLE(tableTok);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> HiveParser.TOK_ALTERTABLE:</span><br><span class="line">    currDB = getCanonicalDb();</span><br><span class="line">    <span class="keyword">for</span> (Node childNode : ast.getChildren()) &#123;</span><br><span class="line">      ASTNode childASTNode = (ASTNode) childNode;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"TOK_ALTERTABLE_SERIALIZER"</span>.equals(childASTNode.getText())) &#123;</span><br><span class="line">        ASTNode serdeNode = (ASTNode) childASTNode.getChild(<span class="number">0</span>);</span><br><span class="line">        String serdeClassName = BaseSemanticAnalyzer.unescapeSQLString(serdeNode.getText());</span><br><span class="line">        setSerdeURI(serdeClassName);</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"TOK_ALTERTABLE_RENAME"</span>.equals(childASTNode.getText())) &#123;</span><br><span class="line">        currDB = extractDatabase((ASTNode)ast.getChild(<span class="number">0</span>));</span><br><span class="line">        ASTNode newTableNode = (ASTNode)childASTNode.getChild(<span class="number">0</span>);</span><br><span class="line">        currOutDB = extractDatabase(newTableNode);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    currDB = getCanonicalDb();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ast;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="postAnalyze"><a href="#postAnalyze" class="headerlink" title="postAnalyze"></a>postAnalyze</h4><p>下面是postAnalyze方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postAnalyze</span><span class="params">(HiveSemanticAnalyzerHookContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    List&lt;Task&lt;? extends Serializable&gt;&gt; rootTasks)</span> <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取stmt的操作类型</span></span><br><span class="line">  HiveOperation stmtOperation = getCurrentHiveStmtOp();</span><br><span class="line">  <span class="comment">// inputPrivileges（操作对应的输入路径）, outputPrivileges（操作对应的输出路径）, operationType（DDL、DML、QUERY等操作的类型）, operationScope（库、表、列、函数等）</span></span><br><span class="line">  HiveAuthzPrivileges stmtAuthObject;</span><br><span class="line">  <span class="comment">// 根据操作的类型获取当前这种操作必须要具备的权限，这并不需要RPC调用来获取用户的权限，而仅仅是获取这种操作需要具备的权限，主题是操作而不是用户</span></span><br><span class="line">  stmtAuthObject = HiveAuthzPrivilegesMap.getHiveAuthzPrivileges(stmtOperation);</span><br><span class="line">  <span class="comment">// must occur above the null check on stmtAuthObject</span></span><br><span class="line">  <span class="comment">// TODO 授权、取消并不是在binding模块中认证的？？？？ since GRANT/REVOKE/etc are not authorized by binding layer at present</span></span><br><span class="line">  <span class="comment">// subject包装用户信息</span></span><br><span class="line">  Subject subject = getCurrentSubject(context);</span><br><span class="line">  <span class="comment">// 直接从配置文件中获取用户所属的组的信息，因此可以猜测用户和组的映射的关系并不是在sentry的表中的，而是存在于配置文件中（查看表信息确实如此）</span></span><br><span class="line">  Set&lt;String&gt; subjectGroups = hiveAuthzBinding.getGroups(subject);</span><br><span class="line">  <span class="keyword">for</span> (Task&lt;? extends Serializable&gt; task : rootTasks) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> SentryGrantRevokeTask) &#123;</span><br><span class="line">      <span class="comment">// 应该是将原来的无权限的task包装成新的task，该task内部执行授权、取消授权的操作</span></span><br><span class="line">      SentryGrantRevokeTask sentryTask = (SentryGrantRevokeTask)task;</span><br><span class="line">      sentryTask.setHiveAuthzBinding(hiveAuthzBinding);</span><br><span class="line">      sentryTask.setAuthzConf(authzConf);</span><br><span class="line">      sentryTask.setSubject(subject);</span><br><span class="line">      sentryTask.setSubjectGroups(subjectGroups);</span><br><span class="line">      sentryTask.setIpAddress(context.getIpAddress());</span><br><span class="line">      sentryTask.setOperation(stmtOperation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (stmtAuthObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// We don't handle authorizing this statement</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replace DDLTask using the SentryFilterDDLTask for protection,</span></span><br><span class="line"><span class="comment">     * such as "show column" only allow show some column that user can access to.</span></span><br><span class="line"><span class="comment">     * SENTRY-847</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rootTasks.size(); i++) &#123;</span><br><span class="line">      Task&lt;? extends Serializable&gt; task = rootTasks.get(i);</span><br><span class="line">      <span class="keyword">if</span> (task <span class="keyword">instanceof</span> DDLTask) &#123;</span><br><span class="line">        ShowColumnsDesc showCols = ((DDLTask) task).getWork().getShowColumnsDesc();</span><br><span class="line">        <span class="keyword">if</span> (showCols != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 针对DDL操作，这里是只展示用于具备权限的列</span></span><br><span class="line">          SentryFilterDDLTask filterTask =</span><br><span class="line">                  <span class="keyword">new</span> SentryFilterDDLTask(hiveAuthzBinding, subject, stmtOperation);</span><br><span class="line">          filterTask.copyDDLTask((DDLTask) task);</span><br><span class="line">          rootTasks.set(i, filterTask);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后进行鉴权，此处会远程调用来获取用户的权限</span></span><br><span class="line">    authorizeWithHiveBindings(context, stmtAuthObject, stmtOperation);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (AuthorizationException e) &#123;</span><br><span class="line">    executeOnFailureHooks(context, stmtOperation, e);</span><br><span class="line">    String permsRequired = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span> (String perm : hiveAuthzBinding.getLastQueryPrivilegeErrors()) &#123;</span><br><span class="line">      permsRequired += perm + <span class="string">";"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SessionState.get().getConf().set(HiveAuthzConf.HIVE_SENTRY_AUTH_ERRORS, permsRequired);</span><br><span class="line">    String msgForLog = HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE</span><br><span class="line">        + <span class="string">"\n Required privileges for this query: "</span></span><br><span class="line">        + permsRequired;</span><br><span class="line">    String msgForConsole = HiveAuthzConf.HIVE_SENTRY_PRIVILEGE_ERROR_MESSAGE + <span class="string">"\n "</span></span><br><span class="line">        + e.getMessage()+ <span class="string">"\n The required privileges: "</span> + permsRequired;</span><br><span class="line">    <span class="comment">// AuthorizationException is not a real exception, use the info level to record this.</span></span><br><span class="line">    LOG.info(msgForLog);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(msgForConsole, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    hiveAuthzBinding.close();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(context.getConf().</span><br><span class="line">      get(HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION))) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(HiveAuthzConf.HIVE_SENTRY_MOCK_ERROR + <span class="string">" Mock query compilation aborted. Set "</span> +</span><br><span class="line">        HiveAuthzConf.HIVE_SENTRY_MOCK_COMPILATION + <span class="string">" to 'false' for normal query processing"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面最后调用了authorizeWithHiveBindings方法，这里才是权限校验的地方，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">authorizeWithHiveBindings</span><span class="params">(HiveSemanticAnalyzerHookContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">    HiveAuthzPrivileges stmtAuthObject, HiveOperation stmtOperation)</span> <span class="keyword">throws</span>  AuthorizationException </span>&#123;</span><br><span class="line">  <span class="comment">// 获取当前操作输入、输出相关的信息</span></span><br><span class="line">  Set&lt;ReadEntity&gt; inputs = context.getInputs();</span><br><span class="line">  Set&lt;WriteEntity&gt; outputs = context.getOutputs();</span><br><span class="line">  List&lt;List&lt;DBModelAuthorizable&gt;&gt; inputHierarchy = <span class="keyword">new</span> ArrayList&lt;List&lt;DBModelAuthorizable&gt;&gt;();</span><br><span class="line">  List&lt;List&lt;DBModelAuthorizable&gt;&gt; outputHierarchy = <span class="keyword">new</span> ArrayList&lt;List&lt;DBModelAuthorizable&gt;&gt;();</span><br><span class="line">  <span class="keyword">if</span>(LOG.isDebugEnabled()) &#123;</span><br><span class="line">    LOG.debug(<span class="string">"stmtAuthObject.getOperationScope() = "</span> + stmtAuthObject.getOperationScope());</span><br><span class="line">    LOG.debug(<span class="string">"context.getInputs() = "</span> + context.getInputs());</span><br><span class="line">    LOG.debug(<span class="string">"context.getOutputs() = "</span> + context.getOutputs());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Workaround to allow DESCRIBE &lt;table&gt; to be executed with only column-level privileges, while</span></span><br><span class="line">  <span class="comment">// still authorizing DESCRIBE [EXTENDED|FORMATTED] as table-level.</span></span><br><span class="line">  <span class="comment">// This is done by treating DESCRIBE &lt;table&gt; the same as SHOW COLUMNS, which only requires column</span></span><br><span class="line">  <span class="comment">// level privs.</span></span><br><span class="line">  <span class="keyword">if</span> (isDescTableBasic) &#123;</span><br><span class="line">    stmtAuthObject = HiveAuthzPrivilegesMap.getHiveAuthzPrivileges(HiveOperation.SHOWCOLUMNS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 根据操作的对象提取对象的信息，分别存放到输入、输出的认证模型中</span></span><br><span class="line">  <span class="keyword">switch</span> (stmtAuthObject.getOperationScope()) &#123;</span><br><span class="line">  <span class="keyword">case</span> SERVER :</span><br><span class="line">    <span class="comment">// validate server level privileges if applicable. Eg create UDF,register jar etc ..</span></span><br><span class="line">    List&lt;DBModelAuthorizable&gt; serverHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">    serverHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">    inputHierarchy.add(serverHierarchy);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> DATABASE:</span><br><span class="line">    <span class="comment">// workaround for database scope statements (create/alter/drop db)</span></span><br><span class="line">    List&lt;DBModelAuthorizable&gt; dbHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">    dbHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">    dbHierarchy.add(currDB);</span><br><span class="line">    inputHierarchy.add(dbHierarchy);</span><br><span class="line">    <span class="keyword">if</span> (currOutDB != <span class="keyword">null</span>) &#123;</span><br><span class="line">      List&lt;DBModelAuthorizable&gt; outputDbHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">      outputDbHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">      outputDbHierarchy.add(currOutDB);</span><br><span class="line">      outputHierarchy.add(outputDbHierarchy);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      outputHierarchy.add(dbHierarchy);</span><br><span class="line">    &#125;</span><br><span class="line">    getInputHierarchyFromInputs(inputHierarchy, inputs);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> TABLE:</span><br><span class="line">    <span class="comment">// workaround for add partitions</span></span><br><span class="line">    <span class="keyword">if</span>(partitionURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">      inputHierarchy.add(ImmutableList.of(hiveAuthzBinding.getAuthServer(), partitionURI));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(indexURI != <span class="keyword">null</span>) &#123;</span><br><span class="line">      outputHierarchy.add(ImmutableList.of(hiveAuthzBinding.getAuthServer(), indexURI));</span><br><span class="line">    &#125;</span><br><span class="line">    getInputHierarchyFromInputs(inputHierarchy, inputs);</span><br><span class="line">    <span class="keyword">for</span> (WriteEntity writeEntity: outputs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (filterWriteEntity(writeEntity)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      List&lt;DBModelAuthorizable&gt; entityHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">      entityHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">      entityHierarchy.addAll(getAuthzHierarchyFromEntity(writeEntity));</span><br><span class="line">      outputHierarchy.add(entityHierarchy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// workaround for metadata queries.</span></span><br><span class="line">    <span class="comment">// Capture the table name in pre-analyze and include that in the input entity list</span></span><br><span class="line">    <span class="keyword">if</span> (currTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      List&lt;DBModelAuthorizable&gt; externalAuthorizableHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">      externalAuthorizableHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">      externalAuthorizableHierarchy.add(currDB);</span><br><span class="line">      externalAuthorizableHierarchy.add(currTab);</span><br><span class="line">      inputHierarchy.add(externalAuthorizableHierarchy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// workaround for DDL statements</span></span><br><span class="line">    <span class="comment">// Capture the table name in pre-analyze and include that in the output entity list</span></span><br><span class="line">    <span class="keyword">if</span> (currOutTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">      List&lt;DBModelAuthorizable&gt; externalAuthorizableHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">      externalAuthorizableHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">      externalAuthorizableHierarchy.add(currOutDB);</span><br><span class="line">      externalAuthorizableHierarchy.add(currOutTab);</span><br><span class="line">      outputHierarchy.add(externalAuthorizableHierarchy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> FUNCTION:</span><br><span class="line">    <span class="comment">/* The 'FUNCTION' privilege scope currently used for</span></span><br><span class="line"><span class="comment">     *  - CREATE TEMP FUNCTION</span></span><br><span class="line"><span class="comment">     *  - DROP TEMP FUNCTION.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!udfURIs.isEmpty()) &#123;</span><br><span class="line">      List&lt;DBModelAuthorizable&gt; udfUriHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">      udfUriHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">      udfUriHierarchy.addAll(udfURIs);</span><br><span class="line">      inputHierarchy.add(udfUriHierarchy);</span><br><span class="line">      <span class="keyword">for</span> (WriteEntity writeEntity : outputs) &#123;</span><br><span class="line">        List&lt;DBModelAuthorizable&gt; entityHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">        entityHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">        entityHierarchy.addAll(getAuthzHierarchyFromEntity(writeEntity));</span><br><span class="line">        outputHierarchy.add(entityHierarchy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> CONNECT:</span><br><span class="line">    <span class="comment">/* The 'CONNECT' is an implicit privilege scope currently used for</span></span><br><span class="line"><span class="comment">     *  - USE &lt;db&gt;</span></span><br><span class="line"><span class="comment">     *  It's allowed when the user has any privilege on the current database. For application</span></span><br><span class="line"><span class="comment">     *  backward compatibility, we allow (optional) implicit connect permission on 'default' db.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;DBModelAuthorizable&gt; connectHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">    connectHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">    <span class="comment">// by default allow connect access to default db</span></span><br><span class="line">    Table currTbl = Table.ALL;</span><br><span class="line">    Column currCol = Column.ALL;</span><br><span class="line">    <span class="keyword">if</span> ((DEFAULT_DATABASE_NAME.equalsIgnoreCase(currDB.getName()) &amp;&amp;</span><br><span class="line">        <span class="string">"false"</span>.equalsIgnoreCase(authzConf.</span><br><span class="line">            get(HiveAuthzConf.AuthzConfVars.AUTHZ_RESTRICT_DEFAULT_DB.getVar(), <span class="string">"false"</span>)))) &#123;</span><br><span class="line">      currDB = Database.ALL;</span><br><span class="line">      currTbl = Table.SOME;</span><br><span class="line">    &#125;</span><br><span class="line">    connectHierarchy.add(currDB);</span><br><span class="line">    connectHierarchy.add(currTbl);</span><br><span class="line">    connectHierarchy.add(currCol);</span><br><span class="line">    inputHierarchy.add(connectHierarchy);</span><br><span class="line">    outputHierarchy.add(connectHierarchy);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> COLUMN:</span><br><span class="line">    <span class="keyword">for</span> (ReadEntity readEntity: inputs) &#123;</span><br><span class="line">      <span class="keyword">if</span> (readEntity.getAccessedColumns() != <span class="keyword">null</span> &amp;&amp; !readEntity.getAccessedColumns().isEmpty()) &#123;</span><br><span class="line">        addColumnHierarchy(inputHierarchy, readEntity);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        List&lt;DBModelAuthorizable&gt; entityHierarchy = <span class="keyword">new</span> ArrayList&lt;DBModelAuthorizable&gt;();</span><br><span class="line">        entityHierarchy.add(hiveAuthzBinding.getAuthServer());</span><br><span class="line">        entityHierarchy.addAll(getAuthzHierarchyFromEntity(readEntity));</span><br><span class="line">        entityHierarchy.add(Column.ALL);</span><br><span class="line">        inputHierarchy.add(entityHierarchy);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException(<span class="string">"Unknown operation scope type "</span> +</span><br><span class="line">        stmtAuthObject.getOperationScope().toString());</span><br><span class="line">  &#125;</span><br><span class="line">  HiveAuthzBinding binding = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 这里比较关键，是通过远程调用获取用户的权限</span></span><br><span class="line">    binding = getHiveBindingWithPrivilegeCache(hiveAuthzBinding, context.getUserName());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SemanticException e) &#123;</span><br><span class="line">    <span class="comment">// Will use the original hiveAuthzBinding</span></span><br><span class="line">    binding = hiveAuthzBinding;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// validate permission</span></span><br><span class="line">  <span class="comment">// 最后一步验证权限</span></span><br><span class="line">  binding.authorize(stmtOperation, stmtAuthObject, getCurrentSubject(context), inputHierarchy,</span><br><span class="line">      outputHierarchy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于获取binding的会通过远程调用获取权限，因此有必要看一下这一步的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> HiveAuthzBinding <span class="title">getHiveBindingWithPrivilegeCache</span><span class="params">(HiveAuthzBinding hiveAuthzBinding,</span></span></span><br><span class="line"><span class="function"><span class="params">    String userName)</span> <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">  <span class="comment">// get the original HiveAuthzBinding, and get the user's privileges by AuthorizationProvider</span></span><br><span class="line">  AuthorizationProvider authProvider = hiveAuthzBinding.getCurrentAuthProvider();</span><br><span class="line">  <span class="comment">// 这一步很关键，查看可以知道这一步会通过远程调用获取用户的权限</span></span><br><span class="line">  Set&lt;String&gt; userPrivileges = authProvider.getPolicyEngine().getPrivileges(</span><br><span class="line">          authProvider.getGroupMapping().getGroups(userName), hiveAuthzBinding.getActiveRoleSet(),</span><br><span class="line">          hiveAuthzBinding.getAuthServer());</span><br><span class="line">  <span class="comment">// create PrivilegeCache using user's privileges</span></span><br><span class="line">  <span class="comment">// 这一步主要是将之前获取到的权限数据缓存，便于在同一次会话中使用</span></span><br><span class="line">  PrivilegeCache privilegeCache = <span class="keyword">new</span> SimplePrivilegeCache(userPrivileges);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// create new instance of HiveAuthzBinding whose backend provider should be SimpleCacheProviderBackend</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HiveAuthzBinding(HiveAuthzBinding.HiveHook.HiveServer2, hiveAuthzBinding.getHiveConf(),</span><br><span class="line">            hiveAuthzBinding.getAuthzConf(), privilegeCache);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    LOG.error(<span class="string">"Can not create HiveAuthzBinding with privilege cache."</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于最后一步权限的校验逻辑就不再赘述了，具体可以查看相应的代码。由上面的代码分析可以知道，Hook这里实现了授权（SentryGrantRevokeTask）、鉴权（#getHiveBindingWithPrivilegeCache），也即是用户的所有的请求都会被这一层拦截，并针对对象的类型执行相关的操作。client端的鉴权操作到此可以告一段落</p><h3 id="服务端鉴权操作"><a href="#服务端鉴权操作" class="headerlink" title="服务端鉴权操作"></a>服务端鉴权操作</h3><p>在client端鉴权操作的过程中我们看到了客户端会通过远程调用执行授权操作，也会通过远程调用执行鉴权操作，这个调用的过程是通过RPC调用来实现的，接下来我们看一下服务端的的操作，服务端的操作不止包含了鉴权和授权的操作，还包含了其他的操作，因此我们有必要先概要的介绍一下服务端的操作，然后详细的介绍一下鉴权和授权的操作。通过上面的整体架构图我们可以知道，服务端的入口在sentryService这个类中，主要的组成部分如上图所示其中包含的模块和每一个模块的重要作用如下：</p><ul><li>thrift server：针对hook、listener发送过来的事件做相应的处理操作，处理的逻辑在sentryPolicyStoreProcessor</li><li>sentryWebServer：sentryService内置的一个基于jetty的webserver，有对应的界面：http://${sentry.server.url}:29000，查看了一下主要是一些配置信息和一些监控数据</li><li>sentryStore：（是一个单例）sentryStore在SentryService的构造函数中初始化的，初始化的时候有针对是否开启HDFS同步做检测。</li><li>leadMonitor：sentry开启高可用之后，用来监听leader变更的组件</li><li>HMSFollower：封装了hivemetastoreclient，用于从hivemetastore中同步hive相关的元数据</li></ul><p>接下来看一下sentryService的入口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  SentryKerberosContext kerberosContext = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    status = Status.STARTED;</span><br><span class="line">    <span class="keyword">if</span> (kerberos) &#123;</span><br><span class="line">      kerberosContext = <span class="keyword">new</span> SentryKerberosContext(principal, keytab, <span class="keyword">true</span>);</span><br><span class="line">      Subject.doAs(kerberosContext.getSubject(), <span class="keyword">new</span> PrivilegedExceptionAction&lt;Void&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          runServer();</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runServer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception t) &#123;</span><br><span class="line">    LOGGER.error(<span class="string">"Error starting server"</span>, t);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error starting server"</span>, t);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (kerberosContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">      kerberosContext.shutDown();</span><br><span class="line">    &#125;</span><br><span class="line">    status = Status.NOT_STARTED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到call方法内仅仅是针对是否开启kerberos进行判断，最终入口都会调用runServer方法，跟进runServer方法来看一下：</p><p>1、首先会启动一些清理工作</p><p>2、接下来会启动HMSFollower，首先会获取metastore的thrifturi，然后会以500ms的周期定时调度，在hmsfollower构造函数中，会分别实例化NotificationProcessor：用于处理notification，主要是针对DDL操作通过sentrystore持久化变更（这里会判断是否开启HDFS同步）。SentryHMSClient：会首先获取sentryStore的notification的id，获取所有的库表信息（没有持久化），接下来再次获取notification的id，如果两次获取到的id相同，说明在同步库表信息的过程中并没有新的DDL操作，这就表示已经完成同步操作。如果两次notification的id不同，说明同步库表信息的时候有DDL操作，这个时候只需要继续同步即可。HiveNotificationFetcher：会使用sentryHMSClient获取notification</p><p>3、接下来会构建thrift server，thrift server包含了processor逻辑（用于处理RPC请求，这里主要是权限的一些校验）和sentrystore（持久化）的逻辑，之后启动sentryService的服务端来处理客户端的请求</p><p>4、然后启动sentryWebServer，这里主要是一些配置信息的查看和内置的一些监控数据<img src="//southrivers.github.io/2019/11/23/sentry学习总结/webserver.png" alt>上面的鉴权、授权的主要的业务逻辑是在thriftserver的processor中，对应的实现类为：SentryPolicyStoreProcessor，我们可以具体查看一下相关的逻辑，下面是该类中包含的方法：<img src="//southrivers.github.io/2019/11/23/sentry学习总结/thriftserver.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TCreateSentryRoleResponse <span class="title">create_sentry_role</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  TCreateSentryRoleRequest request)</span> <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Timer.Context timerContext = sentryMetrics.createRoleTimer.time();</span><br><span class="line">  TCreateSentryRoleResponse response = <span class="keyword">new</span> TCreateSentryRoleResponse();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    validateClientVersion(request.getProtocol_version());</span><br><span class="line">    <span class="comment">// 校验当前用户的权限，创建角色是特殊的权限，需要用户所在的group和admin所在的group存在交集，如果不满足要求会抛出异常</span></span><br><span class="line">    authorize(request.getRequestorUserName(),</span><br><span class="line">        getRequestorGroups(request.getRequestorUserName()));</span><br><span class="line">    <span class="comment">// 将对应的角色持久化到sentry的数据库中</span></span><br><span class="line">    sentryStore.createSentryRole(request.getRoleName());</span><br><span class="line">    response.setStatus(Status.OK());</span><br><span class="line">    <span class="comment">// 责任链模式的业务，功能未知</span></span><br><span class="line">    notificationHandlerInvoker.create_sentry_role(request, response);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SentryAlreadyExistsException e) &#123;</span><br><span class="line">    String msg = <span class="string">"Role: "</span> + request + <span class="string">" already exists."</span>;</span><br><span class="line">    LOGGER.error(msg, e);</span><br><span class="line">    response.setStatus(Status.AlreadyExists(e.getMessage(), e));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SentryAccessDeniedException e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    response.setStatus(Status.AccessDenied(e.getMessage(), e));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SentryThriftAPIMismatchException e) &#123;</span><br><span class="line">    LOGGER.error(e.getMessage(), e);</span><br><span class="line">    response.setStatus(Status.THRIFT_VERSION_MISMATCH(e.getMessage(), e));</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    String msg = <span class="string">"Unknown error for request: "</span> + request + <span class="string">", message: "</span> + e.getMessage();</span><br><span class="line">    LOGGER.error(msg, e);</span><br><span class="line">    response.setStatus(Status.RuntimeError(msg, e));</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    timerContext.stop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    AUDIT_LOGGER.info(JsonLogEntityFactory.getInstance()</span><br><span class="line">        .createJsonLogEntity(request, response, conf).toJsonFormatLog());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// if any exception, log the exception.</span></span><br><span class="line">    String msg = <span class="string">"Error creating audit log for create role: "</span> + e.getMessage();</span><br><span class="line">    LOGGER.error(msg, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码核心代码只有三行，我们已经对其进行标注，其他的业务处理流程类似，具体可以查看相关的代码，这里不再赘述。</p><h2 id="表变更事件同步"><a href="#表变更事件同步" class="headerlink" title="表变更事件同步"></a>表变更事件同步</h2><p>client端触发notification的地方是SentrySyncHMSNotificationsPostEventListener这个类，如下：上面这些方法在监听到特定的事件的时候会触发notification，查看hive的metastore对应的数据库发现有针对notification的记录，如下为监听到特定事件之后的client的触发机制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">syncNotificationEvents</span><span class="params">(ListenerEvent event, String eventName)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Do not sync notifications if the event has failed.</span></span><br><span class="line">  <span class="keyword">if</span> (failedEvent(event, eventName)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Map&lt;String, String&gt; eventParameters = event.getParameters();</span><br><span class="line">  <span class="keyword">if</span> (!eventParameters.containsKey(MetaStoreEventListenerConstants.DB_NOTIFICATION_EVENT_ID_KEY_NAME)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* If the HMS is running in an active transaction, then we do not want to sync with Sentry</span></span><br><span class="line"><span class="comment">   * because the desired eventId is not available for Sentry yet, and Sentry may block the HMS</span></span><br><span class="line"><span class="comment">   * forever or until a read time-out happens. */</span></span><br><span class="line">  <span class="keyword">if</span> (isMetastoreTransactionActive(eventParameters)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">long</span> eventId =</span><br><span class="line">      Long.parseLong(eventParameters.get(MetaStoreEventListenerConstants.DB_NOTIFICATION_EVENT_ID_KEY_NAME));</span><br><span class="line">  <span class="comment">// This check is only for performance reasons to avoid calling the sync thrift call if the Sentry server</span></span><br><span class="line">  <span class="comment">// already processed the requested eventId.</span></span><br><span class="line">  <span class="keyword">if</span> (eventId &lt;= latestProcessedId.get()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 上面是对event的合法性做的校验，可以不用关心</span></span><br><span class="line">  <span class="keyword">try</span>(SentryPolicyServiceClient sentryClient = <span class="keyword">this</span>.getSentryServiceClient()) &#123;</span><br><span class="line">    LOGGER.debug(<span class="string">"Starting Sentry/HMS notifications sync for &#123;&#125; (id: &#123;&#125;)"</span>, eventName, eventId);</span><br><span class="line">        <span class="comment">// 将最新的notificationId通知到服务端</span></span><br><span class="line">    <span class="keyword">long</span> sentryLatestProcessedId = sentryClient.syncNotifications(eventId);</span><br><span class="line">    LOGGER.debug(<span class="string">"Finishedd Sentry/HMS notifications sync for &#123;&#125; (id: &#123;&#125;)"</span>, eventName, eventId);</span><br><span class="line">    LOGGER.debug(<span class="string">"Latest processed event ID returned by the Sentry server: &#123;&#125;"</span>, sentryLatestProcessedId);</span><br><span class="line">        <span class="comment">// 更新本地的latestProcessedId，默认的情况下，在client启动的时候latestProcessedId是0</span></span><br><span class="line">    updateProcessedId(sentryLatestProcessedId);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// This error is only logged. There is no need to throw an error to Hive because HMS sync is called</span></span><br><span class="line">    <span class="comment">// after the notification is already generated by Hive (as post-event).</span></span><br><span class="line">    LOGGER.error(<span class="string">"Failed to sync requested HMS notifications up to the event ID: "</span> + eventId, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下，还是在SentryPolicyStoreProcessor这个类中，服务端会对客户端发过来的消息进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TSentrySyncIDResponse <span class="title">sentry_sync_notifications</span><span class="params">(TSentrySyncIDRequest request)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TException </span>&#123;</span><br><span class="line">  TSentrySyncIDResponse response = <span class="keyword">new</span> TSentrySyncIDResponse();</span><br><span class="line">  <span class="keyword">try</span> (Timer.Context timerContext = hmsWaitTimer.time()) &#123;</span><br><span class="line">    <span class="comment">// Wait until Sentry Server processes specified HMS Notification ID.</span></span><br><span class="line">        <span class="comment">// 阻塞服务端，直至处理完该notification</span></span><br><span class="line">    response.setId(sentryStore.getCounterWait().waitFor(request.getId()));</span><br><span class="line">    response.setStatus(Status.OK());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    String msg = String.format(<span class="string">"wait request for id %d is interrupted"</span>,</span><br><span class="line">            request.getId());</span><br><span class="line">    LOGGER.error(msg, e);</span><br><span class="line">    response.setId(<span class="number">0</span>);</span><br><span class="line">    response.setStatus(Status.RuntimeError(msg, e));</span><br><span class="line">    Thread.currentThread().interrupt();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">    String msg = String.format(<span class="string">"timed out wait request for id %d"</span>, request.getId());</span><br><span class="line">    LOGGER.warn(msg, e);</span><br><span class="line">    response.setId(<span class="number">0</span>);</span><br><span class="line">    response.setStatus(Status.RuntimeError(msg, e));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心代码只有一行，我们看到在sentryStore中包含了一个counterWaiter，该变量会用在thriftserver和hmsfollower同步notification，存放在sentryStore并不合适，只不过sentryStore是thriftserver和hmsfollower唯一的纽带，后面可能会调整。在上面的代码中，通过counterWaiter实现了notification的发布机制，真正的处理逻辑在hmsfollower中，因此我们接下来看一下hmsfollower是怎么处理这些事件的。Hmsfollower的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HMSFollower</span><span class="params">(Configuration conf, SentryStore store, LeaderStatusMonitor leaderMonitor,</span></span></span><br><span class="line"><span class="function"><span class="params">            HiveConnectionFactory hiveConnectionFactory, String authServerName)</span> </span>&#123;</span><br><span class="line">  LOGGER.info(<span class="string">"HMSFollower is being initialized"</span>);</span><br><span class="line">  readyToServe = <span class="keyword">false</span>;</span><br><span class="line">  authzConf = conf;</span><br><span class="line">  <span class="keyword">this</span>.leaderMonitor = leaderMonitor;</span><br><span class="line">  sentryStore = store;</span><br><span class="line">  <span class="keyword">if</span> (authServerName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    authServerName = conf.get(AUTHZ_SERVER_NAME.getVar(),</span><br><span class="line">      conf.get(AUTHZ_SERVER_NAME_DEPRECATED.getVar(), AUTHZ_SERVER_NAME_DEPRECATED.getDefault()));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于处理从hive metastore接收到的数据</span></span><br><span class="line">  notificationProcessor = <span class="keyword">new</span> NotificationProcessor(sentryStore, authServerName, authzConf);</span><br><span class="line">  <span class="comment">// 包装了hiveMetaStore的客户端，用于从hive元数据仓库获取相应的数据</span></span><br><span class="line">  client = <span class="keyword">new</span> SentryHMSClient(authzConf, hiveConnectionFactory);</span><br><span class="line">  hdfsSyncEnabled = SentryServiceUtil.isHDFSSyncEnabledNoCache(authzConf); <span class="comment">// no cache to test different settings for hdfs sync</span></span><br><span class="line">  <span class="comment">// 使用封装的client获取相应的数据</span></span><br><span class="line">  notificationFetcher = <span class="keyword">new</span> HiveNotificationFetcher(sentryStore, hiveConnectionFactory);</span><br><span class="line">  <span class="comment">// subscribe to full update notification</span></span><br><span class="line">  <span class="keyword">if</span> (conf.getBoolean(ServerConfig.SENTRY_SERVICE_FULL_UPDATE_PUBSUB, <span class="keyword">false</span>)) &#123;</span><br><span class="line">    LOGGER.info(FULL_UPDATE_TRIGGER + <span class="string">"subscribing to topic "</span> + PubSub.Topic.HDFS_SYNC_HMS.getName());</span><br><span class="line">    PubSub.getInstance().subscribe(PubSub.Topic.HDFS_SYNC_HMS, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较重要的地方都已经用中文注释，从名字可以大致看出来notificationFetcher是用来从hive的metastore中拉取notification的，notificationProcessor是用来处理获取到的notification的。 由于hms是定时调度的，因此我们可以通过定时调度的方法作为入口来分析hmsfollower，对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 用于发布HMSFollower的状态</span></span><br><span class="line">  SentryStateBank.enableState(HMSFollowerState.COMPONENT,HMSFollowerState.STARTED);</span><br><span class="line">  <span class="keyword">long</span> lastProcessedNotificationId;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Initializing lastProcessedNotificationId based on the latest persisted notification ID.</span></span><br><span class="line">      lastProcessedNotificationId = sentryStore.getLastProcessedNotificationID();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      LOGGER.error(<span class="string">"Failed to get the last processed notification id from sentry store, "</span></span><br><span class="line">          + <span class="string">"Skipping the processing"</span>, e);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Wake any clients connected to this service waiting for HMS already processed notifications.</span></span><br><span class="line">        <span class="comment">// 唤醒所有在lastProcessedNotificationId上等待的client，这里的client对应的是从hivemetastore同步数据的client（猜测）</span></span><br><span class="line">    wakeUpWaitingClientsForSync(lastProcessedNotificationId);</span><br><span class="line">    <span class="comment">// Only the leader should listen to HMS updates</span></span><br><span class="line">    <span class="keyword">if</span> (!isLeader()) &#123;</span><br><span class="line">      <span class="comment">// Close any outstanding connections to HMS</span></span><br><span class="line">      close();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理新到达的notifications</span></span><br><span class="line">    syncupWithHms(lastProcessedNotificationId);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 重置状态</span></span><br><span class="line">    SentryStateBank.disableState(HMSFollowerState.COMPONENT,HMSFollowerState.STARTED);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心的代码在syncupWithHms中，最终方法会调度到notificationProcessor.processNotificationEvent(event)，进入该方法发现会针对特定的事件执行权限的变更操作，具体的代码如下： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Context ignored = timer.time()) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">      <span class="keyword">case</span> CREATE_DATABASE:</span><br><span class="line">        <span class="keyword">return</span> processCreateDatabase(event);</span><br><span class="line">      <span class="keyword">case</span> DROP_DATABASE:</span><br><span class="line">        <span class="keyword">return</span> processDropDatabase(event);</span><br><span class="line">      <span class="keyword">case</span> CREATE_TABLE:</span><br><span class="line">        <span class="keyword">return</span> processCreateTable(event);</span><br><span class="line">      <span class="keyword">case</span> DROP_TABLE:</span><br><span class="line">        <span class="keyword">return</span> processDropTable(event);</span><br><span class="line">      <span class="keyword">case</span> ALTER_TABLE:</span><br><span class="line">        <span class="keyword">return</span> processAlterTable(event);</span><br><span class="line">      <span class="keyword">case</span> ADD_PARTITION:</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;       <span class="comment">// return processAddPartition(event);</span></span><br><span class="line">      <span class="keyword">case</span> DROP_PARTITION:</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;       <span class="comment">// return processDropPartition(event);</span></span><br><span class="line">      <span class="keyword">case</span> ALTER_PARTITION:</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;       <span class="comment">//return processAlterPartition(event);</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        LOGGER.error(<span class="string">"Notification with ID:&#123;&#125; has invalid event type: &#123;&#125;"</span>, event.getEventId(),</span><br><span class="line">            event.getEventType());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入到对应的方法查看，发现根据具体的事件同步的变更权限，如：删除数据库会把数据库相关的权限的数据都删除。在完成同步操作之后会记录到数据库中本次metastore的变更。</p><h2 id="Hdfs-namenode鉴权"><a href="#Hdfs-namenode鉴权" class="headerlink" title="Hdfs namenode鉴权"></a>Hdfs namenode鉴权</h2><h3 id="元数据同步"><a href="#元数据同步" class="headerlink" title="元数据同步"></a>元数据同步</h3><p>hdfs namenode会定期从sentry server中同步权限以及hive的元数据，程序的入口在SentryAuthorizationProvider，最终会通过SentryAuthorizationInfo定时更新authzPaths和authzPermissions，核心代码在类SentryAuthorizationInfo中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//Looks like getting same updates multiple times</span></span><br><span class="line">  SentryAuthzUpdate updates = updater.getUpdates();</span><br><span class="line">  <span class="comment">// Updates can be null if Sentry Service is un-reachable</span></span><br><span class="line">  <span class="keyword">if</span> (updates != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (updates.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// no updates is a norm, it's still success</span></span><br><span class="line">    &#125;</span><br><span class="line">    UpdateableAuthzPaths newAuthzPaths = processUpdates(</span><br><span class="line">        updates.getPathUpdates(), authzPaths);</span><br><span class="line">    UpdateableAuthzPermissions newAuthzPerms = processUpdates(</span><br><span class="line">        updates.getPermUpdates(), authzPermissions);</span><br><span class="line">    <span class="comment">// processUpdates() should return different newAuthzPaths and newAuthzPerms object references</span></span><br><span class="line">    <span class="comment">// if FULL updates were fetched from the Sentry server, otherwise, the same authzPaths and authzPermissions</span></span><br><span class="line">    <span class="comment">// objects will be returned.</span></span><br><span class="line">    <span class="keyword">if</span> (newAuthzPaths != authzPaths || newAuthzPerms != authzPermissions) &#123;</span><br><span class="line">      lock.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">          LOG.debug(updates.dumpContent());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newAuthzPaths != authzPaths) &#123;</span><br><span class="line">          LOG.info(String.format(<span class="string">"FULL Updated paths seq Num [old=%d], [new=%d]"</span>,</span><br><span class="line">            authzPaths.getLastUpdatedSeqNum(), newAuthzPaths.getLastUpdatedSeqNum()));</span><br><span class="line">          authzPaths = newAuthzPaths;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(authzPaths.dumpContent());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newAuthzPerms != authzPermissions) &#123;</span><br><span class="line">          LOG.info(String.format(<span class="string">"FULL Updated perms seq Num [old=%d], [new=%d]"</span>,</span><br><span class="line">            authzPermissions.getLastUpdatedSeqNum(), newAuthzPerms.getLastUpdatedSeqNum()));</span><br><span class="line">          authzPermissions = newAuthzPerms;</span><br><span class="line">          <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(authzPermissions.dumpContent());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.writeLock().unlock();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">        lock.writeLock().lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          LOG.debug(updates.dumpContent());</span><br><span class="line">          <span class="keyword">if</span> (LOG.isTraceEnabled()) &#123;</span><br><span class="line">            LOG.trace(newAuthzPaths.dumpContent());</span><br><span class="line">            LOG.trace(newAuthzPerms.dumpContent());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          lock.writeLock().unlock();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，更新权限或者hive元数据的时候，会使用一个readwritelock来实现线程之间的同步，这一块应该是考虑让两个变量的同步更新。这一个锁在更新数据的时候会让其他的读操作阻塞，因此可能会产生性能瓶颈。</p><h3 id="鉴权操作"><a href="#鉴权操作" class="headerlink" title="鉴权操作"></a>鉴权操作</h3><p>hdfs鉴权操作在类SentryAuthorizationProvider中，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(String user, Set&lt;String&gt; groups,</span></span></span><br><span class="line"><span class="function"><span class="params">     INodeAuthorizationInfo[] inodes, <span class="keyword">int</span> snapshotId,</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">boolean</span> doCheckOwner, FsAction ancestorAccess, FsAction parentAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">     FsAction access, FsAction subAccess, <span class="keyword">boolean</span> ignoreEmptyDir)</span></span></span><br><span class="line"><span class="function">     <span class="keyword">throws</span> AccessControlException, UnresolvedLinkException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">     <span class="comment">// Note: Arrays.asList() returns "[null]" string for null argument</span></span><br><span class="line">     LOG.debug(<span class="string">"### checkPermission(): "</span> +</span><br><span class="line">               <span class="string">"User &#123;&#125;, Groups &#123;&#125;, Nodes &#123;&#125;, snapshotId &#123;&#125;, "</span> +</span><br><span class="line">               <span class="string">"doCheckOwner &#123;&#125;, ancestorAccess &#123;&#125;, parentAccess &#123;&#125;, "</span> +</span><br><span class="line">               <span class="string">"access &#123;&#125;, subAccess &#123;&#125;, ignoreEmptyDir &#123;&#125;"</span>,</span><br><span class="line">       user, groups, Arrays.asList(inodes), snapshotId,</span><br><span class="line">       doCheckOwner, ancestorAccess, parentAccess,</span><br><span class="line">       access, subAccess, ignoreEmptyDir);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">   <span class="comment">//绕过原生NN鉴权过程对x权限的判断，DefaultAuthorizationProvider.checkPermission从跟节点逐级判断x权限</span></span><br><span class="line">   <span class="comment">//直接return表示鉴权成功，鉴权失败时会抛异常</span></span><br><span class="line">   <span class="comment">//http://km.vivo.xyz/pages/viewpage.action?pageId=85251073</span></span><br><span class="line">   <span class="keyword">if</span> (!doCheckOwner &amp;&amp; ancestorAccess == <span class="keyword">null</span> &amp;&amp; parentAccess == <span class="keyword">null</span> &amp;&amp; </span><br><span class="line">          access == <span class="keyword">null</span> &amp;&amp; subAccess == <span class="keyword">null</span> &amp;&amp; !ignoreEmptyDir) &#123;</span><br><span class="line">  <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">    LOG.debug(<span class="string">"### checkPermission() return: "</span> +</span><br><span class="line">              <span class="string">"User &#123;&#125;, Groups &#123;&#125;, Nodes &#123;&#125;, snapshotId &#123;&#125;, "</span> +</span><br><span class="line">              <span class="string">"doCheckOwner &#123;&#125;, ancestorAccess &#123;&#125;, parentAccess &#123;&#125;, "</span> +</span><br><span class="line">              <span class="string">"access &#123;&#125;, subAccess &#123;&#125;, ignoreEmptyDir &#123;&#125;"</span>,</span><br><span class="line">      user, groups, Arrays.asList(inodes), snapshotId,</span><br><span class="line">      doCheckOwner, ancestorAccess, parentAccess,</span><br><span class="line">      access, subAccess, ignoreEmptyDir);</span><br><span class="line">  &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//filter to check</span></span><br><span class="line">   <span class="comment">//过滤hive执行mr和spark任务产生的临时文件的鉴权</span></span><br><span class="line">   <span class="keyword">if</span> (isFilter(inodes, <span class="string">"checkPermission()"</span>)) &#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//只进行一次鉴权</span></span><br><span class="line">  inodes = truncate(inodes, doCheckOwner, ancestorAccess, parentAccess);</span><br><span class="line">     <span class="keyword">if</span> (inodes.length == <span class="number">1</span> &amp;&amp; access == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (subAccess != <span class="keyword">null</span>) &#123;</span><br><span class="line">         access = subAccess;</span><br><span class="line">         subAccess = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ancestorAccess != <span class="keyword">null</span>) &#123;</span><br><span class="line">         access = ancestorAccess;</span><br><span class="line">         ancestorAccess = <span class="keyword">null</span>;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parentAccess != <span class="keyword">null</span>) &#123;</span><br><span class="line">         access = parentAccess;</span><br><span class="line">         parentAccess = <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">  LOG.warn(<span class="string">"### truncate Exception. "</span> +</span><br><span class="line">         <span class="string">"User &#123;"</span> + user + <span class="string">"&#125;, Groups &#123;"</span> + groups + <span class="string">"&#125;, Nodes &#123;"</span> + Arrays.asList(inodes) + <span class="string">"&#125;, snapshotId &#123;"</span> + snapshotId + <span class="string">"&#125;, "</span> + </span><br><span class="line">     <span class="string">"doCheckOwner &#123;"</span> + doCheckOwner + <span class="string">"&#125;, ancestorAccess &#123;"</span> + ancestorAccess + <span class="string">"&#125;, parentAccess &#123;"</span> + parentAccess + <span class="string">"&#125;, "</span> + </span><br><span class="line">         <span class="string">"access &#123;"</span> + access + <span class="string">"&#125;, subAccess &#123;"</span> + subAccess + <span class="string">"&#125;, ignoreEmptyDir &#123;"</span> + ignoreEmptyDir + <span class="string">"&#125;, FullPath &#123;"</span> + </span><br><span class="line">     (inodes[<span class="number">0</span>] == <span class="keyword">null</span> ? <span class="string">"null"</span> : inodes[<span class="number">0</span>].getFullPathName()) + <span class="string">"&#125; taken &#123;"</span> + (System.currentTimeMillis() - start) + <span class="string">"&#125;."</span>, e);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">long</span> truncateTime = System.currentTimeMillis() - start;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     defaultAuthzProvider.checkPermission(user, groups, inodes, snapshotId,</span><br><span class="line">       doCheckOwner, ancestorAccess, parentAccess, access, subAccess,</span><br><span class="line">       ignoreEmptyDir);</span><br><span class="line">     <span class="keyword">if</span> (LOG.isDebugEnabled()) &#123;</span><br><span class="line">       LOG.debug(<span class="string">"### checkPermission(): "</span> +</span><br><span class="line">                 <span class="string">"User &#123;&#125;, Groups &#123;&#125;, Nodes &#123;&#125;, snapshotId &#123;&#125;, "</span> + </span><br><span class="line">                <span class="string">"doCheckOwner &#123;&#125;, ancestorAccess &#123;&#125;, parentAccess &#123;&#125;, "</span> + </span><br><span class="line">                 <span class="string">"access &#123;&#125;, subAccess &#123;&#125;, ignoreEmptyDir &#123;&#125;, FullPath &#123;&#125; taken &#123;&#125;, truncateTime &#123;&#125;"</span>,</span><br><span class="line">         user, groups, Arrays.asList(inodes), snapshotId,</span><br><span class="line">         doCheckOwner, ancestorAccess, parentAccess,</span><br><span class="line">         access, subAccess, ignoreEmptyDir, inodes[<span class="number">0</span>] == <span class="keyword">null</span> ? <span class="string">"null"</span> : inodes[<span class="number">0</span>].getFullPathName(), </span><br><span class="line">                (System.currentTimeMillis() - start), truncateTime);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (AccessControlException e) &#123;</span><br><span class="line">     LOG.debug(<span class="string">"### AccessControlException"</span>, e);</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (UnresolvedLinkException e) &#123;</span><br><span class="line">     LOG.debug(<span class="string">"### UnresolvedLinkException"</span>, e);</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">     LOG.error(<span class="string">"### Unexpected Exception"</span>, e);</span><br><span class="line">     <span class="keyword">throw</span> e;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中我们可以看到，最终是由于defaultAuthzProvider来进行权限的校验的，因此SentryAuthorizationProvider更多的像是一个门面。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>sentry权限的管控用到了hive的hook、listener机制，本质上就是一个切面操作，这里比较重要的，我个人认为应当是DDL、DML操作数据的提取，这样如果在定制化权限控制的时候才可以做到较快的响应</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>thrift初窥</title>
      <link href="/2019/11/22/thrift%E5%88%9D%E7%AA%A5/"/>
      <url>/2019/11/22/thrift%E5%88%9D%E7%AA%A5/</url>
      
        <content type="html"><![CDATA[<p>最近转到了大数据项目组，在研究sentry组件，其中client和server的通信大量使用到了thrift，因此花了点时间研究一下thrift相关的东西。现整理内容如下。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Thrift 是一种接口描述语言，主要用于实现异构服务的调用，底层的数据传输采用二进制的方式，相较于传统的json或者XML，体积更小、效率更高，thrift是RPC的一种实现。</p><h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h1><p><img src="//southrivers.github.io/2019/11/22/thrift初窥/%E6%9E%B6%E6%9E%84" alt>Thrift 包含了一个完整的堆栈结构来实现客户端和服务端的交互，如下图所示：<img src="//southrivers.github.io/2019/11/22/thrift初窥/%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B" alt></p><h1 id="流程演示"><a href="#流程演示" class="headerlink" title="流程演示"></a>流程演示</h1><p>使用thrift约定的规范编写一个thrift的脚本文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace java com.h3c</span><br><span class="line">service Hello&#123;</span><br><span class="line"> string helloString(1:string para)</span><br><span class="line"> i32 helloInt(1:i32 para)</span><br><span class="line"> bool helloBoolean(1:bool para)</span><br><span class="line"> void helloVoid()</span><br><span class="line"> string helloNull()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来使用thrift的编译器生成对应语言的对应文件，该文件包含了对应的接口，以java为例：class.Iface、class.Client（客户端调用逻辑）、class.Processor（服务端处理逻辑），我们只需要实现对应的接口即可：下图依次为thrift生成的接口文件、接口文件的实现类、服务端及客户端</p><p><img src="//southrivers.github.io/2019/11/22/thrift初窥/%E5%B1%82%E6%AC%A1" alt></p><p><img src="//southrivers.github.io/2019/11/22/thrift初窥/%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" alt></p><p><img src="//southrivers.github.io/2019/11/22/thrift初窥/%E5%AE%A2%E6%88%B7%E4%BB%A3%E7%A0%81%E5%B1%95%E7%A4%BA" alt>除此之外还可以构建其他的服务类型。</p><h1 id="RPC和动态代理"><a href="#RPC和动态代理" class="headerlink" title="RPC和动态代理"></a>RPC和动态代理</h1><p>上面的客户端代码和服务端代码通过接口的方式做了解耦合，也即是客户端调用的是接口中的方法，最终执行的是我们自己服务端实现的业务逻辑，因此大致可以猜测应该是使用了动态代理的技术完成的，事实上，一般的RPC也基本上都是通过动态代理机制来完成的。未完待续。。。。。</p><!-- 好奇心驱使之下，我搜了一下网上的一些实现，然后根据理解自己实现了一下。代码如下：-->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java 类加载机制</title>
      <link href="/2019/11/10/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/11/10/Java-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>最近在看druid的源代码，在加载资源的时候，有看到下面的代码：<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-11-10%2015.22.31.png" alt>在加载类的时候使用两种机制来加载，之前有了解过JVM加载类是通过双亲委托的方式来完成的，但是一致没有深究这个问题，今天抽时间看了一下并总结成文案加强一下记忆。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JVM的类加载机制就是将字节码加载到堆内存中，并为之生成一个Class的对象。JVM 将类的加载操作剥离了 JVM，这样做的好处就是使得类的加载更加的灵活，用户可以实现自定义的类加载器完成类的加载操作。</p><h1 id="类的加载流程"><a href="#类的加载流程" class="headerlink" title="类的加载流程"></a>类的加载流程</h1><p>在说类的加载流程之前，我们先想一下类加载的目的，这样接下来的分析或许才记得更清楚（这里说的加载并不是整个流程的加载阶段，而是整个初始化的过程）。类加载的目的是为后续生成类对应的对象做铺垫，待加载的类中可能会引用其他的类（继承、组合），也有可能会包含静态字段（类级别的）、静态代码块。因此整个加载的流程就需要正对上述的情况做处理。<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/%E5%8A%A0%E8%BD%BD.png" alt>如上图所示，整个加载流程可以分为：加载 -&gt; 连接 -&gt; 初始化</p><h2 id="类初始化的条件"><a href="#类初始化的条件" class="headerlink" title="类初始化的条件"></a>类初始化的条件</h2><ul><li>当遇到new（生成一个新的对象）、 getstatic、putstatic（上面两条指令是操作静态字段）、invokestatic（操作静态方法）这4个字节码的时候</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候</li><li>初始化一个类的时候，如果发现父类还没有初始化，会优先初始化父类</li><li>MethodHandle实例最后的解析结果为static的引用的情况下（没有使用过这种方法）</li><li>虚拟机启动的时候指定的主类（一般是包含了Main函数的类）</li></ul><p>总结一下，创建对象、调用静态的方法或者字段、通过反射的方式创建对象会导致类及父类的初始化。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>类加载阶段是通过的<strong>类的全限定名加载类的二进制字节流</strong>，并在堆内存<strong>生成相应的class对象</strong>，该class对象将代码中定义的字段转化成class中对应的数据，这个class对象将作为方法区中相应字段的访问的入口，这里是访问的类的数据，并不是类生成的对象的数据。</p><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>连接的整个过程又可以细分为以下步骤</p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证的主要目的是验证字节码符合JVM规范</p><ul><li>文件格式校验：魔数、版本号的验证，确保字节流能够正确的解析并存在于方法区中</li><li>元数据校验：主要是语义校验，如final类型的变量是否被继承</li><li>字节码校验：方法体的校验，通过数据流和控制流分析程序的语义是正确的</li><li>符号引用的校验：将符号引用转化成直接引用（内存中的偏移量），并确定直接引用是否有足够的权限</li></ul><p>总结一下：由表及里、由内而外的校验</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>为类变量分配方法区中的内存并初始化<strong>类变量</strong>，这里是初始化类字段为对应类型的0值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>在准备阶段并不会将x初始化为1，而是初始化成int对应的零值：0。上述操作会存放于<strong>类构造器</strong><clinit>()中，也即是classinit中</clinit></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段将符号引用替换成直接引用：使用内存中的偏移量替换掉类中的符号。这里待替换的符号为</p><ul><li>类或接口</li><li>类、接口中的字段、方法</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>初始化阶段是执行<strong>类构造器</strong><clinit>()的过程，也是真正开始执行类中定义的java程序代码。<clinit>()是由编译器自动收集的类变量的赋值、静态语句块 static {} 组成的，编译器收集的顺序是语句在原文件中出现的顺序决定的，因此定义在上面的变量不可以对定义在其后的变量引用，但是可以赋值，复制也会被下面的内容给覆盖掉。</clinit></clinit></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">0</span>;</span><br><span class="line">    println(i);<span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>上面的操作中引用是非法的，但是赋值操作i=0是正常的，只不过i最终的值为1（由于执行的顺序是从上至下），虚拟机会保证在子类的<clinit>初始化之前，父类的<clinit>已经执行完毕。</clinit></clinit></p><p>上面概要的说明了类初始化的整个流程，接下来看一下类加载相关的知识点。</p><h1 id="双亲委托模型"><a href="#双亲委托模型" class="headerlink" title="双亲委托模型"></a>双亲委托模型</h1><p>JVM将类的加载放到虚拟机之外实现，这样做的好处是足够的灵活，我们完全可以按照自己的需要从外部读取字节码。JVM推荐的类加载的方式是双亲委托的方式<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/parent.png" alt>在收到加载类的请求的时候，当前的类加载器会将该请求委托给父类来加载，这样递归到BootstrapClassLoader，只有父类在确定无法完成该类的加载的时候，才会将该请求传递给子ClassLoader，完成类的加载，对应的代码如下：<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/%E5%8F%8C%E4%BA%B2.png" alt>在遵循双亲委托的前提下，通常我们只需要实现ClassLoader的findClass()方法来定制类加载器即可（这样上面的双亲委托并没有被破坏），不推荐覆盖loadClass方法，这样很可能在不知情的情况下破坏双亲委托的模式。启用双亲委托的方式来加载类的好处是java类随着类加载器具备了优先级的层次关系，这样如果使用者写了一个和java类库中同路径、同名的类的时候，尽管编译成字节码没有问题，但是在运行的时候会报错。</p><p>双亲委托模型是推荐的类加载机制，但是有时候却不一定合适，由于本人做的比较多的是web开发，因此通过一个web应用来描述一下双亲委托的缺陷。<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/tomcat.png" alt>通常情况下，一个tomcat是可以部署多个web应用的，假设两个不同的web应用同时依赖两个不同版本的java类库，如果采用双亲委托的方式，这些类库的载入必然使用到同样的类加载器，由于所加载的类仅仅只是版本有所不同，类的全路径是完全相同的，因此必然有一个类库无法加载成功。这样我们势必要破坏这种双亲委托：由子类加载器完成类的加载，不再委托父类完成类的加载（重写类加载器的loadClass方法，在类加载的时候不去寻找parent的类加载器即可）。上述实现思路可行，但是我们总要找到一种设置我们自定义类加载器的方式，这种方式就是<strong>线程上下文类加载器</strong>，也即是Thread的setContextClassLoader、getContextClassLoader。通过线程上下文类加载器，我们就完成了子类加载器的委托。</p><p>发散思维：假设存在一种情况，接口的类加载器和实现的类加载器不一致，如下<img src="//southrivers.github.io/2019/11/10/Java-类加载机制/diff.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HelloService helloService = (HelloService)<span class="keyword">new</span> HelloServiceImpl()</span><br></pre></td></tr></table></figure><p>上述代码会报ClassNotFoundException，这是因为JVM是通过类的全限定名和类加载器来确定一个类的，因此尽管实现了接口，但类加载器不同，因此没有办法相互转换，如果要解决这种问题可以通过JDK动态代理来实现（有指定对应的classLoader）</p><!--  https://www.wisedream.net/2017/01/17/programming/type-cast-across-classloader/ -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JMX详细解读</title>
      <link href="/2019/11/09/JMX%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/11/09/JMX%E8%AF%A6%E7%BB%86%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<p>最近在看druid的源码，发现里面大量使用了MBean，由于之前没有过多的了解过这是什么机制，以及有什么用，因此特地到网上查了一下，内容补充如下：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一致性hash</title>
      <link href="/2019/10/29/%E4%B8%80%E8%87%B4%E6%80%A7hash/"/>
      <url>/2019/10/29/%E4%B8%80%E8%87%B4%E6%80%A7hash/</url>
      
        <content type="html"><![CDATA[<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>我们的业务通常会使用缓存来提高系统的吞吐，不过单节点缓存存在明显的缺陷：单节点的缓存大小有明显的限制，当业务体量达到一定的规模时候，无法通过增加机器的数量来解除这种限制。</p><p>为了解决上面这种问题，我们可以增加节点并将缓存在这些节点上均匀的打散，一般的，均匀的打散的方式可以采用hash(key) % n，这里的key为对应的缓存的key，n为缓存节点的数量。不过这种方案也存在明显的缺陷：<strong>如果缓存节点掉电或者由于业务的扩展需要增加新的缓存节点，这种情况下将会使得已有的缓存的数据重新hash找到新的存放的节点，这将会使得缓存失效</strong>，缓存的失效会使得大量的请求直奔数据库而去，最终可能会压垮数据库，导致整个服务不可用。</p><p>为了解决由于缓存服务器数量的改变导致缓存数据重新分配的问题，歪果仁发明了一种神奇的算法：一致性hash。提到一致性hash通常都会提到hash环，听着名字很拽的样子，简单点来说就是一个环状的hash空间，之所以是环状的，和其缓存对象寻找缓存节点的策略是相关的；一般hash环大小为2^32，之所以是这个值而不是其他的值，猜测应该是IP4的空间相关的，环中一个槽位代表一个缓存节点。</p><h1 id="一致性hash流程"><a href="#一致性hash流程" class="headerlink" title="一致性hash流程"></a>一致性hash流程</h1><h2 id="构建hash环"><a href="#构建hash环" class="headerlink" title="构建hash环"></a>构建hash环</h2><p>构建一个大小为2^32的数组，并将该数组当作一个环来对待</p><h2 id="缓存对象映射"><a href="#缓存对象映射" class="headerlink" title="缓存对象映射"></a>缓存对象映射</h2><p>把需要映射的缓存对象通过hash函数将其映射到hash环之上</p><h2 id="缓存节点映射"><a href="#缓存节点映射" class="headerlink" title="缓存节点映射"></a>缓存节点映射</h2><p>选取缓存节点的IP或者机器名称通过同一个hash函数将其映射到hash环之上</p><h2 id="缓存对象绑定缓存节点"><a href="#缓存对象绑定缓存节点" class="headerlink" title="缓存对象绑定缓存节点"></a>缓存对象绑定缓存节点</h2><p>经过以上步骤，缓存对象和缓存节点都已经使用同一个hash函数映射到了同一个hash环上了，接下来选定缓存对象，沿着该hash环顺时针方向寻找缓存节点，找到的第一个缓存节点就是该缓存对象的存放节点,上述流程如下图所示：<img src="//southrivers.github.io/2019/10/29/一致性hash/hash1.png" alt></p><p>下面来看一下缓存节点的变动对已经分配的缓存带来的影响：假设D2所在的服务器挂掉了，那么D2所在节点的缓存将会失效，D2将会顺时针寻找下一个缓存节点来进行存放缓存数据，这样旧的缓存数据都还继续对外提供服务，如下图所示：<img src="//southrivers.github.io/2019/10/29/一致性hash/hash.png" alt></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上述hash过程解决了缓存节点变更导致的缓存大批量失效的问题，但是这种方案仍然有不完美的地方:</p><ul><li>hash冲突可能会导致某一台缓存节点负载过重</li><li>hash的查找效率退化成了链表的查找效率</li></ul><p>为了解决第一个问题，引入了虚拟节点，虚拟节点可以认为是实际节点的一个镜像，这样可以将hash环划分的更均匀、随机，缓存也就分布的更均匀。</p><p>第二个问题是由于分布式缓存中不同的缓存节点对其他缓存节点的信息一无所知（没有一个controller的角色存在），这样查找的过程就成了链表的查找。为了解决第二个问题，给每一个缓存节点增加一个跳转链表，该跳转表记录的是距离该缓存节点1、2、4距离的数字存放的节点，这样不论查询落到哪一个查询节点都可以在log(k)的时间复杂度内确定缓存所在的桶。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合类之HashSet</title>
      <link href="/2019/10/23/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BHashSet/"/>
      <url>/2019/10/23/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BHashSet/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工作的过程中有用过HashSet，由于之前对这一块并没有深入到源码研究，因此对于内部的构造一直是不清楚，趁着研究Java其他的集合类型，我也顺便翻了一下HashSet的源码，结果发现真是魔幻啊，HashSet底层居然是HashMap实现的，以前还真没有留意。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>首先还是来看一下HashSet对应的类图：</p><p><img src="//southrivers.github.io/2019/10/23/java集合类之HashSet/hashset.png" alt></p><p>如上为对应的HashSet的类图，同LinkedList以及hashMap类似，其也是大量使用了模板的模式：</p><ul><li>接口定义方法</li><li>抽象类定义公共实现</li><li>具体的类来定义特性的实现</li></ul><p>HashMap的精髓并不在于源码的分析，而在于底层的实现，具体点就是底层采用了HashMap做了相关的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>如上所见，HashSet中定义了一个HashMap，我们使用的是HashMap的key来存放我们需要存放到HashMap中的元素，而对应的value其实是<code>PRESENT</code>。至于HashSet如何解决Hash冲突，如何维护底层的元素，则可以通过之前的HashMap的分析来了解，这里就不再赘述了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>apache druid 源码走读</title>
      <link href="/2019/10/19/apache-druid-%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/"/>
      <url>/2019/10/19/apache-druid-%E6%BA%90%E7%A0%81%E8%B5%B0%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>监控也做了一段时间了，短短续续接触过一系列的存储与计算相关的组件，机缘巧合接触到了druid（并不是阿里的数据库连接池工具），这是一款用于OLAP的存储组件，鉴于其高效的查询效率，在初步了解、使用以及弄清楚整体的架构之后，也对其源码产生了较大的兴趣，由于官网上对其使用、介绍也是比较全面的，因此在此略讲这些东西，看后面有时间再补齐。</p><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>下图是druid数据流图</p><p><img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/structure1.png" alt></p><p>对于上图简要的介绍一下：</p><ul><li>router是用来分发请求的</li><li>broker是用来将查询结果合并的，通常建议可以和router合并在一起</li><li>middlemanager和historical是用来存放未发布的和已经发布的数据的</li><li>overlaod是用来保障高可用的</li><li>coordinator是用来管理segment（数据）的，包括了数据的发布、均衡等操作</li></ul><p>官方推荐的部署架构如下图所示：</p><p><img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/bushu1.png" alt></p><h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>在深入了解每一个模块之前，我们有必要对整个工程的启动、运行流程有一定的了解，不然就是老虎吃天，无从下口。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>万物皆有入口，哈哈哈！那么druid的入口在哪里呢？查看启动的脚本就会发现，入口就在Main类的main方法，多么自然，在程序中万物的运行始于main函数。从代码开始看起吧！为了方便理解，我是将代码分成多段进行讲解了，具体的的步骤：</p><h3 id="构建builder对象"><a href="#构建builder对象" class="headerlink" title="构建builder对象"></a>构建builder对象</h3><p>构建builder对象，该对象是管理我们在工程中使用到的命令行的工具箱，我们可以将其想像成一个箱子。通俗点来讲，我假设大家都是用过git工具的，这个builder对象就有点类似于<code>git</code>命令，<code>git</code>包含<code>git remote 、git add</code>等工具，因此也可以将<code>git</code>看作一个箱子，这个箱子里面包含了各种各样的工具可以让我们使用，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Cli.CliBuilder&lt;Runnable&gt; builder = Cli.builder(<span class="string">"druid"</span>);</span><br><span class="line">    builder.withDescription(<span class="string">"Druid command-line runner."</span>)</span><br><span class="line">           .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">withCommands</span>(<span class="title">Help</span>.<span class="title">class</span>, <span class="title">Version</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="添加分组"><a href="#添加分组" class="headerlink" title="添加分组"></a>添加分组</h3><p>给我们的builder对象添加各种命令，在直接添加命令之前，这里先对其做了分组的工作，还是以git为例，<code>git remote</code>的<code>remote</code>其实就是一个分组的作用，其下面包含的有<code>git remote add、git remote update</code>等命令，正如我们在上面的代码中看到的那样，druid也对命令做了多个分组： <code>server、tools、index、internal</code>，也就是说我们要使用调用server下的某一个process的时候，需要加上server组名才可以调通。那么server能调用的命令包含那些呢？要知道分组下的命令可以直接到对应的类上面看其<code>@Command</code>注解即可，我们还是以middleManager为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Command</span>(</span><br><span class="line">    name = <span class="string">"middleManager"</span>,</span><br><span class="line">    description = <span class="string">"Runs a Middle Manager, this is a \"task\" node used as part of the remote indexing service, see https://druid.apache.org/docs/latest/design/middlemanager.html for a description"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CliMiddleManager</span> <span class="keyword">extends</span> <span class="title">ServerRunnable</span></span></span><br></pre></td></tr></table></figure><p>这也就是说，当我们想要运行middleManager的时候，向main函数传递的参数应该是 <code>main server middleManager</code>，类比其他的process我们也就很好理解了，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&lt;? extends Runnable&gt;&gt; serverCommands = Arrays.asList(</span><br><span class="line">    CliCoordinator<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliHistorical</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliBroker</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliOverlord</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliIndexer</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliMiddleManager</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliRouter</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line"><span class="comment">// group可以认为是命令行的前缀</span></span><br><span class="line">builder.withGroup(<span class="string">"server"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Run one of the Druid server types."</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">serverCommands</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Class&lt;? extends Runnable&gt;&gt; toolCommands = Arrays.asList(</span><br><span class="line">    DruidJsonValidator<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">PullDependencies</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CreateTables</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">DumpSegment</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ResetCluster</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ValidateSegments</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ExportMetadata</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">builder.withGroup(<span class="string">"tools"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Various tools for working with Druid"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">toolCommands</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.withGroup(<span class="string">"index"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Run indexing for druid"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">CliHadoopIndexer</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.withGroup(<span class="string">"internal"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Processes that Druid runs \"internally\", you should rarely use these directly"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">CliPeon</span>.<span class="title">class</span>, <span class="title">CliInternalHadoopIndexer</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="构建工厂"><a href="#构建工厂" class="headerlink" title="构建工厂"></a>构建工厂</h3><p>构建一个Injector，这里使用到了guice这款谷歌开源的IOC框架，相信用过spring的人都知道或者了解IOC的机制了，这里就不对IOC讨论了。简单的类比一下guice中的概念和spring中的概念，injector可以类比为spring中的ApplicationContext，在spring中我们可以使用context来获取某一个对象，那么injector也必然是可以用来获取某一个对象了！是的。injector的主要作用就是存放各种java bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Injector injector = GuiceInjectors.makeStartupInjector();</span><br></pre></td></tr></table></figure><h3 id="获取扩展配置信息"><a href="#获取扩展配置信息" class="headerlink" title="获取扩展配置信息"></a>获取扩展配置信息</h3><p>获取ExtensionsConfig对象，这里是druid给我们提供的扩展机制，在main函数中，该类主要适用于命令行工具的扩展，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ExtensionsConfig config = injector.getInstance(ExtensionsConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 加载CliCommandCreator对应的实现类，默认情况下应该是没有的，这里加载也是采用了SPI的机制</span></span><br><span class="line"><span class="keyword">final</span> Collection&lt;CliCommandCreator&gt; extensionCommands = Initialization.getFromExtensions(</span><br><span class="line">    config,</span><br><span class="line">    CliCommandCreator<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line"><span class="keyword">for</span> (CliCommandCreator creator : extensionCommands) &#123;</span><br><span class="line">  creator.addCommands(builder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Cli&lt;Runnable&gt; cli = builder.build();</span><br></pre></td></tr></table></figure><p>我们进CliCommandCreator看一下会发现是一个接口，并且没有任何实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CliCommandCreator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCommands</span><span class="params">(Cli.CliBuilder builder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那为什么还要循环遍历这个集合呢？看的一脸懵逼吧，这里是java里面给我们提供的SPI机制来扩展命令行的，不过默认并没有任何实现，因此该段代码可以略过。</p><h3 id="解析命令并执行process"><a href="#解析命令并执行process" class="headerlink" title="解析命令并执行process"></a>解析命令并执行process</h3><p>解析命令并运行相关的process，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Runnable command = cli.parse(args);</span><br><span class="line"><span class="keyword">if</span> (!(command <span class="keyword">instanceof</span> Help)) &#123; <span class="comment">// Hack to work around Help not liking being injected</span></span><br><span class="line"><span class="comment">// 这里会将command对应的对象进行注入进来</span></span><br><span class="line">injector.injectMembers(command);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里最终是会调用对应的组件，如middlemanager的run方法的</span></span><br><span class="line">command.run();</span><br></pre></td></tr></table></figure><p>到此位置我们将main函数的主要流程分析清楚了，接下来我们就从server组里的middlemanager这个command来看一下吧。在main方法的最后，我们看到了<code>command.run()</code>这个方法的调用，那么这个方法最终会在哪里触发执行呢？这就和我们在使用命令行的时候server后面跟的参数有关系了。还是以middlemanager为例来分析吧（其他的都一样）。</p><h2 id="执行process"><a href="#执行process" class="headerlink" title="执行process"></a>执行process</h2><p>在讲解代码流程之前，我们先看一下该process对应的类图：<img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/middlemanager-structure1.png" alt>可以看到<code>command.run()</code>方法最终应该是会触发serverRunnable处的run方法的执行，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构建本实例所需要的工厂对象，用于后面生成对象</span></span><br><span class="line"><span class="keyword">final</span> Injector injector = makeInjector();</span><br><span class="line"><span class="keyword">final</span> Lifecycle lifecycle = initLifecycle(injector);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lifecycle.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码可以分为3步：</p><ul><li>构建当前process需要的injetor对象，可能有的人会比较疑惑，前面构建了一个injector，这里又构建了一个，那么这两个injector有没有必要合并成一个，这样两个injector中的java bean共享一个上下文，这里完全没必要担心，跟进代码你会发现，这里生成的injector就是使用上面生成的baseInjector来生成的，这也就是说，上文中构建的injector缺少特定的process所需要的java bean，这里就是在原来的injector基础之上又装配了当前这个process所需要的java bean。</li><li>初始化injector的生命周期，这里的作用是实例化injector中非lazy类型的java bean，启动整个工程（可以认为是一个核心了）</li><li>等待程序运行结束</li></ul><p>接下来我们还是继续分析<code>makeInjector()</code>具体执行了什么操作吧，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Injector <span class="title">makeInjector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Initialization.makeInjectorWithModules(baseInjector, getModules());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上面的方法就是给baseInjector注入process所需要的功能java bean。这里的baseInjector是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Injector injector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.baseInjector = injector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里的baseInjector是使用guice的注解装配进来的injector，也就是我们最早定义的injector。点进去<code>getModules()</code>可以发现这是一个接口，嗯，没错这里是使用到了模板模式！真正的实现放到了对应的process中去了。进入makeInjectorWithModules方法可以看到使用了<code>Guice.createInjector(Modules.override(oldmodules).with(newmodules))</code>这种方式来获取新的injector。在将特定process的java bean装配到injector之后，接下来就是要执行程序的初始化了，也就是该创建的对象创建，该开启的端口开启就完事了，我们来看一下具体的代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">initLifecycle</span><span class="params">(Injector injector)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取lifecycle实例，该实例会初始化工程所必须的对象</span></span><br><span class="line">      <span class="keyword">final</span> Lifecycle lifecycle = injector.getInstance(Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">final</span> StartupLoggingConfig startupLoggingConfig = injector.getInstance(StartupLoggingConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">      Long directSizeBytes = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        directSizeBytes = JvmUtils.getRuntimeInfo().getDirectMemorySizeBytes();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (UnsupportedOperationException ignore) &#123;</span><br><span class="line">        <span class="comment">// querying direct memory is not supported</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.info(</span><br><span class="line">          <span class="string">"Starting up with processors[%,d], memory[%,d], maxMemory[%,d]%s. Properties follow."</span>,</span><br><span class="line">          JvmUtils.getRuntimeInfo().getAvailableProcessors(),</span><br><span class="line">          JvmUtils.getRuntimeInfo().getTotalHeapSizeBytes(),</span><br><span class="line">          JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes(),</span><br><span class="line">          directSizeBytes != <span class="keyword">null</span> ? StringUtils.format(<span class="string">", directMemory[%,d]"</span>, directSizeBytes) : <span class="string">""</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (startupLoggingConfig.isLogProperties()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; maskProperties = Sets.newHashSet(startupLoggingConfig.getMaskProperties());</span><br><span class="line">        <span class="keyword">final</span> Properties props = injector.getInstance(Properties<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String propertyName : Ordering.natural().sortedCopy(props.stringPropertyNames())) &#123;</span><br><span class="line">          String property = props.getProperty(propertyName);</span><br><span class="line">          <span class="keyword">for</span> (String masked : maskProperties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propertyName.contains(masked)) &#123;</span><br><span class="line">              property = <span class="string">"&lt;masked&gt;"</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">"* %s: %s"</span>, propertyName, property);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lifecycle.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(t, <span class="string">"Error when starting up.  Failing."</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面的代码比较长，不过总的来说只有两行有效代码：<code>final Lifecycle lifecycle = injector.getInstance(Lifecycle.class)</code>和<code>lifecycle.start()</code>这两行代码分别是从injector中获取lifecycle对象，调用lifecycle对象的start方法，这里我们点进去LifeCycle的类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  ........</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    startStopLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.get().equals(State.NOT_STARTED)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ISE(<span class="string">"Already started"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!state.compareAndSet(State.NOT_STARTED, State.RUNNING)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ISE(<span class="string">"stop() is called concurrently with start()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Stage, ? extends List&lt;Handler&gt;&gt; e : handlers.entrySet()) &#123;</span><br><span class="line">        currStage = e.getKey();</span><br><span class="line">        log.info(<span class="string">"Starting lifecycle [%s] stage [%s]"</span>, name, currStage.name());</span><br><span class="line">        <span class="keyword">for</span> (Handler handler : e.getValue()) &#123;</span><br><span class="line">          handler.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">"Successfully started lifecycle [%s]"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      startStopLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure><p>如果你是看到了上面的代码，那么恭喜你，你找错方向了！仔细看上面，我们是调用了<code>injector.getInstance(Lifecycle.class)</code>来获取lifecycle对象，也就你要从工厂中获取该对象，很明显上面的这个类并没有使用guice提供的注解来将其装配到injector中，因此这里并不是我们想要的代码。那么真正的实现在哪里呢？在LifeCycleModule类中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @provides注解是用来生成java bean的一种方式，这里也就是生成整个工程所需要的lifecycle对象</span></span><br><span class="line"><span class="meta">@Provides</span> <span class="meta">@LazySingleton</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">(<span class="keyword">final</span> Injector injector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">final</span> Key&lt;Set&lt;KeyHolder&gt;&gt; keyHolderKey = Key.get(<span class="keyword">new</span> TypeLiteral&lt;Set&lt;KeyHolder&gt;&gt;()&#123;&#125;, Names.named(<span class="string">"lifecycle"</span>));</span><br><span class="line"><span class="keyword">final</span> Set&lt;KeyHolder&gt; eagerClasses = injector.getInstance(keyHolderKey);</span><br><span class="line"></span><br><span class="line">Lifecycle lifecycle = <span class="keyword">new</span> Lifecycle(<span class="string">"module"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">// 这里是所有的组件最终的入口，可以看到调用了lifecycle的start方法之后该实例化的对象都实例化了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (KeyHolder&lt;?&gt; holder : eagerClasses) &#123;</span><br><span class="line">      <span class="comment">// 初始化工厂中的对象</span></span><br><span class="line">      injector.getInstance(holder.getKey()); <span class="comment">// Pull the key so as to "eagerly" load up the class.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是继续装配lifecycle对象</span></span><br><span class="line">initScope.setLifecycle(lifecycle);</span><br><span class="line">normalScope.setLifecycle(lifecycle);</span><br><span class="line">serverScope.setLifecycle(lifecycle);</span><br><span class="line">annoucementsScope.setLifecycle(lifecycle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lifecycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面才是lifecycle.start方法执行的操作，这一步我们看到是有一个for循环的操作，该操作就是实例化我们当前process需要的对象了，最终会调用join方法等待当前的process退出。这里首先是使用<code>Key.get(new TypeLiteral&lt;Set&lt;KeyHolder&gt;&gt;(){}, Names.named(&quot;lifecycle&quot;))</code>来获取一系列的Key值，这些Key值是<code>Set&lt;KeyHolder&gt;</code>类型的，并且被<code>@Names(&quot;lifecycle&quot;)</code>注解了的，guice中的Key值是什么概念呢？可以认为是spring中的beanName，在spring中我们是可以通过beanName的方式来直接从容器中获取bean的，因此这里也是为了下面获取bean的而做的准备。不过我们可能会很好奇，这些个被<code>@Names(&quot;lifecycle&quot;)</code>标注的过程是在哪里呢？这个就要返回到上面<code>makeInjector</code>方法了，在创建injector的时候，我们有提到过<code>getModules</code>方法，不过是一笔略过的，现在就看一下这些个依赖是如何在启动的过程中被加进来的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;? extends Module&gt; getModules()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Server.class和SelfDiscoveryResource.class注册到了生命周期的管理，会在项目启动的时候就实例化对应的对象</span></span><br><span class="line"><span class="keyword">return</span> ImmutableList.of(</span><br><span class="line">    <span class="keyword">new</span> Module()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        LifecycleModule.register(binder, Server<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">        LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>这里我们看到对于CliMiddleManager这个process来说，在装配自定义的Module的时候，是注册了两个类的，我们来看一下这个注册的过程是什么样子的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerKey</span><span class="params">(Binder binder, Key&lt;?&gt; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">getEagerBinder(binder).addBinding().toInstance(<span class="keyword">new</span> KeyHolder&lt;Object&gt;(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Multibinder&lt;KeyHolder&gt; <span class="title">getEagerBinder</span><span class="params">(Binder binder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">return Multibinder.newSetBinder(binder, KeyHolder.class, Names.named("lifecycle"));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是注册过程中调用的方法链了，这里还是来解释一下：<code>Multibinder.newSetBinder(binder, KeyHolder.class, Names.named(&quot;lifecycle&quot;)).addBinding().toInstance(new KeyHolder&lt;Object&gt;(key))</code>，整个方法的调用的话就如同上面这个样子，这里的含义是会将多个类都存放到Set<keyholder>中来，每调用一次注册的方法，就会生成一个<code>new KeyHolder&lt;Object&gt;(key)</code>来持有我们希望在process初始化的过程中实例化的对象。</keyholder></p><p>我们现在再回到上文看一下就不难发现<code>Set&lt;KeyHolder&gt; eagerClasses = injector.getInstance(keyHolderKey)</code>获取到的就是上面我们注册类进来的时候生成的集合，不过这个集合现在持有的并不是实例化之后的对象，而是<code>Set&lt;KeyHolder&gt;</code>，这里的<code>KeyHolder</code>是会持有一个Class的，我们通过遍历这个集合类就可以完成当前process在启动之处就需要实例化的类了。</p><p>在<code>geModules</code>方法中我们看到，当前的process注册的类中有一个Server类，这个类必然会在lifecycle的start方法中被实例化，不过实例化的类在哪里呢？在JettyServerModule这个类中提供了具体的实现，我们来看一下实例化一个Server对象的时候究竟发生了什么吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@LazySingleton</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">getServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Self <span class="keyword">final</span> DruidNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ServerConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TLSServerConfig TLSServerConfig</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeAndInitializeServer(</span><br><span class="line">      injector,</span><br><span class="line">      lifecycle,</span><br><span class="line">      node,</span><br><span class="line">      config,</span><br><span class="line">      TLSServerConfig,</span><br><span class="line">      injector.getExistingBinding(Key.get(SslContextFactory<span class="class">.<span class="keyword">class</span>)),</span></span><br><span class="line"><span class="class">      <span class="title">injector</span>.<span class="title">getInstance</span>(<span class="title">TLSCertificateChecker</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">  )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们看到Server的创建依赖其他的五个对象，这些类在前面的module中都是已经被注入到injector中了，因此当我们获取Server对象的时候，这些对象也就会通过深度遍历的方式给依次注入进来，这里我们也不做过多的讨论了，就看一下创建Server的过程吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Server <span class="title">makeAndInitializeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">    Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">    DruidNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">    ServerConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">    TLSServerConfig tlsServerConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    Binding&lt;SslContextFactory&gt; sslContextFactoryBinding,</span></span></span><br><span class="line"><span class="function"><span class="params">    TLSCertificateChecker certificateChecker</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// adjusting to make config.getNumThreads() mean, "number of threads</span></span><br><span class="line">  <span class="comment">// that concurrently handle the requests".</span></span><br><span class="line">  <span class="keyword">int</span> numServerThreads = config.getNumThreads() + getMaxJettyAcceptorsSelectorsNum(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> QueuedThreadPool threadPool;</span><br><span class="line">  <span class="keyword">if</span> (config.getQueueSize() == Integer.MAX_VALUE) &#123;</span><br><span class="line">    threadPool = <span class="keyword">new</span> QueuedThreadPool();</span><br><span class="line">    threadPool.setMinThreads(numServerThreads);</span><br><span class="line">    threadPool.setMaxThreads(numServerThreads);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    threadPool = <span class="keyword">new</span> QueuedThreadPool(</span><br><span class="line">        numServerThreads,</span><br><span class="line">        numServerThreads,</span><br><span class="line">        <span class="number">60000</span>, <span class="comment">// same default is used in other case when threadPool = new QueuedThreadPool()</span></span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(config.getQueueSize())</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadPool.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Server server = <span class="keyword">new</span> Server(threadPool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Without this bean set, the default ScheduledExecutorScheduler runs as non-daemon, causing lifecycle hooks to fail</span></span><br><span class="line">  <span class="comment">// to fire on main exit. Related bug: https://github.com/apache/druid/pull/1627</span></span><br><span class="line">  server.addBean(<span class="keyword">new</span> ScheduledExecutorScheduler(<span class="string">"JettyScheduler"</span>, <span class="keyword">true</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;ServerConnector&gt; serverConnectors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.isEnablePlaintextPort()) &#123;</span><br><span class="line">    log.info(<span class="string">"Creating http connector with port [%d]"</span>, node.getPlaintextPort());</span><br><span class="line">    HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (config.isEnableForwardedRequestCustomizer()) &#123;</span><br><span class="line">      httpConfiguration.addCustomizer(<span class="keyword">new</span> ForwardedRequestCustomizer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpConfiguration.setRequestHeaderSize(config.getMaxRequestHeaderSize());</span><br><span class="line">    <span class="keyword">final</span> ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, <span class="keyword">new</span> HttpConnectionFactory(httpConfiguration));</span><br><span class="line">    <span class="keyword">if</span> (node.isBindOnHost()) &#123;</span><br><span class="line">      connector.setHost(node.getHost());</span><br><span class="line">    &#125;</span><br><span class="line">    connector.setPort(node.getPlaintextPort());</span><br><span class="line">    serverConnectors.add(connector);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ServerConnector[] connectors = <span class="keyword">new</span> ServerConnector[serverConnectors.size()];</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ServerConnector connector : serverConnectors) &#123;</span><br><span class="line">    connectors[index++] = connector;</span><br><span class="line">    connector.setIdleTimeout(Ints.checkedCast(config.getMaxIdleTime().toStandardDuration().getMillis()));</span><br><span class="line">    <span class="comment">// workaround suggested in -</span></span><br><span class="line">    <span class="comment">// https://bugs.eclipse.org/bugs/show_bug.cgi?id=435322#c66 for jetty half open connection issues during failovers</span></span><br><span class="line">    connector.setAcceptorPriorityDelta(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;ConnectionFactory&gt; monitoredConnFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ConnectionFactory cf : connector.getConnectionFactories()) &#123;</span><br><span class="line">      <span class="comment">// we only want to monitor the first connection factory, since it will pass the connection to subsequent</span></span><br><span class="line">      <span class="comment">// connection factories (in this case HTTP/1.1 after the connection is unencrypted for SSL)</span></span><br><span class="line">      <span class="keyword">if</span> (cf.getProtocol().equals(connector.getDefaultProtocol())) &#123;</span><br><span class="line">        monitoredConnFactories.add(<span class="keyword">new</span> JettyMonitoringConnectionFactory(cf, ACTIVE_CONNECTIONS));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        monitoredConnFactories.add(cf);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    connector.setConnectionFactories(monitoredConnFactories);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server.setConnectors(connectors);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> gracefulStop = config.getGracefulShutdownTimeout().toStandardDuration().getMillis();</span><br><span class="line">  <span class="keyword">if</span> (gracefulStop &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    server.setStopTimeout(gracefulStop);</span><br><span class="line">  &#125;</span><br><span class="line">  server.addLifeCycleListener(<span class="keyword">new</span> LifeCycle.Listener()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStarting</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle starting [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStarted</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifeycle started [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleFailure</span><span class="params">(LifeCycle event, Throwable cause)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.error(cause, <span class="string">"Jetty lifecycle event failed [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStopping</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle stopping [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStopped</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle stopped [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize server</span></span><br><span class="line">  JettyServerInitializer initializer = injector.getInstance(JettyServerInitializer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initializer.initialize(server, injector);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RE(e, <span class="string">"server initialization exception"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle.addHandler(</span><br><span class="line">      <span class="keyword">new</span> Lifecycle.Handler()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          log.debug(<span class="string">"Starting Jetty Server..."</span>);</span><br><span class="line">          server.start();</span><br><span class="line">          <span class="keyword">if</span> (node.isEnableTlsPort()) &#123;</span><br><span class="line">            <span class="comment">// Perform validation</span></span><br><span class="line">            Preconditions.checkNotNull(sslContextFactory);</span><br><span class="line">            <span class="keyword">final</span> SSLEngine sslEngine = sslContextFactory.newSSLEngine();</span><br><span class="line">            <span class="keyword">if</span> (sslEngine.getEnabledCipherSuites() == <span class="keyword">null</span> || sslEngine.getEnabledCipherSuites().length == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ISE(</span><br><span class="line">                  <span class="string">"No supported cipher suites found, supported suites [%s], configured suites include list: [%s] exclude list: [%s]"</span>,</span><br><span class="line">                  Arrays.toString(sslEngine.getSupportedCipherSuites()),</span><br><span class="line">                  tlsServerConfig.getIncludeCipherSuites(),</span><br><span class="line">                  tlsServerConfig.getExcludeCipherSuites()</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sslEngine.getEnabledProtocols() == <span class="keyword">null</span> || sslEngine.getEnabledProtocols().length == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ISE(</span><br><span class="line">                  <span class="string">"No supported protocols found, supported protocols [%s], configured protocols include list: [%s] exclude list: [%s]"</span>,</span><br><span class="line">                  Arrays.toString(sslEngine.getSupportedProtocols()),</span><br><span class="line">                  tlsServerConfig.getIncludeProtocols(),</span><br><span class="line">                  tlsServerConfig.getExcludeProtocols()</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> unannounceDelay = config.getUnannouncePropagationDelay().toStandardDuration().getMillis();</span><br><span class="line">            <span class="keyword">if</span> (unannounceDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              log.info(<span class="string">"Sleeping %s ms for unannouncement to propagate."</span>, unannounceDelay);</span><br><span class="line">              Thread.sleep(unannounceDelay);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.debug(<span class="string">"Skipping unannounce wait."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"Stopping Jetty Server..."</span>);</span><br><span class="line">            server.stop();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RE(e, <span class="string">"Interrupted waiting for jetty shutdown."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(e, <span class="string">"Unable to stop Jetty server."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      Lifecycle.Stage.SERVER</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较长，不过总结下来也就分以下三个步骤：</p><ul><li>创建web server：包含了配置server处理请求所需的线程池，server处理请求的逻辑connector，server在整个生命周期中需要的一些个listener（这个在tomcat中是比较常见的），以及会在<code>initializer.initialize(server, injector);</code>方法中初始化server拦截的请求、需要的filter等。</li><li>添加handler到lifecycle的handlers中去，这一步的作用是一个hook的作用，也就是说把server的start方法挂到了lifecycle的start方法中了，这样当我们调用lifecycle的start方法启动整个应用之后，自然而然我们的server也就启动了，我们在添加的handler中也可以看到<code>server.start();</code>方法的调用</li><li>返回server实例</li></ul><p>到此为止，我们看到了lifecycle的start方法，带动了server的创建，其中server的创建又配置了handler，这些个handler的一次调用是在哪里呢？是在parent的lifecycle中，如下：</p><p><em>说明一下，在整个process启动的过程中并不是只添加了一个server的handler，还有CuratorFramework，也就是负责和zookeeper保持通信的客户端，如果想要知道全部的handler，可以直接搜<code>lifecycle.addHandler</code>就可以了</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  startStopLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Stage, ? extends List&lt;Handler&gt;&gt; e : handlers.entrySet()) &#123;</span><br><span class="line">      currStage = e.getKey();</span><br><span class="line">      log.info(<span class="string">"Starting lifecycle [%s] stage [%s]"</span>, name, currStage.name());</span><br><span class="line">      <span class="keyword">for</span> (Handler handler : e.getValue()) &#123;</span><br><span class="line">        handler.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"Successfully started lifecycle [%s]"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    startStopLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析到这里我们就看到了完整的process的启动，带动了web server的启动。不过我们好像并没有看到这个web server可以处理的请求是怎么样给加进来的（虽然我们在上面看到了配置web server拦截所有的请求，不过这只是默认的servlet而已，并不是我们在应用中自定义的resource）。添加自定义resource是在<code>JettyServerModule#configureServlets</code>方法中加进来的，我们具体看一下这个过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureServlets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Binder binder = binder();</span><br><span class="line">  .....</span><br><span class="line">  binder.bind(GuiceContainer<span class="class">.<span class="keyword">class</span>).<span class="title">to</span>(<span class="title">DruidGuiceContainer</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  binder.bind(DruidGuiceContainer<span class="class">.<span class="keyword">class</span>).<span class="title">in</span>(<span class="title">Scopes</span>.<span class="title">SINGLETON</span>)</span>;</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  serve(<span class="string">"/*"</span>).with(DruidGuiceContainer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  Jerseys.addResource(binder, StatusResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  binder.bind(StatusResource<span class="class">.<span class="keyword">class</span>).<span class="title">in</span>(<span class="title">LazySingleton</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我么看到<code>serve(&quot;/*&quot;).with(DruidGuiceContainer.class)</code>这么一行代码，查看<code>DruidGuiceContainer</code>的类图:<img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/servlet.png" alt>可以发现该类本身就是一个servlet，不过这里还是先想一下<code>DruidGuiceContainer</code>对象从何而来？如果你认为是通过无参的构造函数反射获得的话，那么很明显又跑题了，要知道我们整个应用都是基于guice来完成的，因此，理所当然的，我们的<code>DruidGuiceContainer</code>也必然是通过容器获取到的，证明就在上面两行代码，现在我们进到这个类里面来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidGuiceContainer</span> <span class="keyword">extends</span> <span class="title">GuiceContainer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; resources;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DruidGuiceContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">      @JSR311Resource Set&lt;Class&lt;?&gt;&gt; resources</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(injector);</span><br><span class="line">    <span class="keyword">this</span>.resources = resources;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ResourceConfig <span class="title">getDefaultResourceConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Object&gt; props, WebConfig webConfig</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceConfig(resources);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，可以看到构造函数上用<code>@Inject</code>来标注了，说明是采用构造器注入的方式来创建该对象的，构造器包含了两个参数，很明显第一个参数就是我们在main函数中生成的injector，这个injector在整个工程中传来传去，目的就是构造一个统一的上下文。<strong>而第二个参数就比较关键了，也是扩展web工程的关键，其所代表的含义是，<code>DruidGuiceContainer</code>需要一组使用了<code>@JSR311Resource</code>标注的类的集合来创建，这也标志着我们可以将某些类以<code>@JSR311Resource</code>的方式注入到injector中，这些被注解标注了的并且注入到injector里面的类最终将会作为<code>DruidGuiceContainer</code>这个servlet的初始化参数，servlet在拦截到请求之后会根据请求的参数路由到对应的<code>resources</code>进行处理。</strong></p><p>接下来我们就来随便找一个例子来看一下这些个resource是怎么样装配到servlet上来的吧，我们在process的代码中基本上是随处可见这样的代码：<code>Jerseys.addResource(binder, ShuffleResource.class);</code>，我们继续跟下去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addResource</span><span class="params">(Binder binder, Class&lt;?&gt; resourceClazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LOG.debug(<span class="string">"Adding Jersey resource: "</span> + resourceClazz.getName());</span><br><span class="line">Multibinder.newSetBinder(binder, <span class="keyword">new</span> TypeLiteral&lt;Class&lt;?&gt;&gt;() &#123;&#125;, JSR311Resource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">addBinding</span>()</span></span><br><span class="line"><span class="class">           .<span class="title">toInstance</span>(<span class="title">resourceClazz</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，可以看到这里是将我们指定的resourceClazz通过Multibinder注入到了injector中，而且在注入的过程中添加了<code>JSR311Resource.class</code>的注解，那么根据上面的分析可以知道，这个resourceClazz将会作为一个resource，最终通过servlet的路由匹配到响应的请求。</p><p>至此，关于整个process启动的过程中web相关的模块我们已经基本理清了。接下来我们就来通过process所支持的功能来具体的分析一下process的具体实现吧。</p><h2 id="overlord源码走读"><a href="#overlord源码走读" class="headerlink" title="overlord源码走读"></a>overlord源码走读</h2><p>overlord控制着摄入任务的分配工作，这个分配工作是在提交摄入规则的时候触发的。</p><p>Overlord的故事从什么地方说起呢？前面我们看到了MiddleManager模块的web工程启动的过程，这一块的逻辑是通用的，因此就不再赘述了，不过可以看到Lifecycle在工程中的作用，那就是一个钩子，在Overlord中也有类似的模块，在程序启动的时候会触发执行，不过在Overlord的modules中是使用注解来hook的，下面是SupervisorManager中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LifecycleStart</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 从数据库中加载对应的数据完成supervisor的启动</span></span><br><span class="line">  Preconditions.checkState(!started, <span class="string">"SupervisorManager already started"</span>);</span><br><span class="line">  log.info(<span class="string">"Loading stored supervisors from database"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    Map&lt;String, SupervisorSpec&gt; supervisors = metadataSupervisorManager.getLatest();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, SupervisorSpec&gt; supervisor : supervisors.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> SupervisorSpec spec = supervisor.getValue();</span><br><span class="line">      <span class="keyword">if</span> (!(spec <span class="keyword">instanceof</span> NoopSupervisorSpec)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          createAndStartSupervisorInternal(spec, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          log.error(ex, <span class="string">"Failed to start supervisor: [%s]"</span>, spec.getId());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码逻辑分成两块：</p><ul><li>获取数据库中存放的摄入规则</li><li>根据获取到的摄入规则创建supervisor</li></ul><p>这里我们还是按照之前的策略来纵深穿插看一下这一块的逻辑吧,获取摄入规则是使用<code>metadataSupervisorManager</code>这个对象获取的，这个对象是在构造函数中通过guice装配进来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SupervisorManager</span><span class="params">(MetadataSupervisorManager metadataSupervisorManager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.metadataSupervisorManager = metadataSupervisorManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多插一句，这里<code>MetadataSupervisorManager</code>注入到injector的方式并不是通过前面看到的bind注入进来的，而是通过SPI的机制注入进来的，具体的代码可以跟进一下在Initialization#makeInjectorWithModules方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ExtensionsConfig config = baseInjector.getInstance(ExtensionsConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (DruidModule <span class="keyword">module</span> : Initialization.getFromExtensions(config, DruidModule<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">  extensionModules.addModule(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路已经提供了，这一块的逻辑如果有时间的话后面会补齐，不过也已经很简单明了了。</p><p>我们继续看一下<code>metadataSupervisorManager.getLatest()</code>执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handle.createQuery(</span><br><span class="line">    StringUtils.format(</span><br><span class="line">        <span class="string">"SELECT r.spec_id, r.payload "</span></span><br><span class="line">        + <span class="string">"FROM %1$s r "</span></span><br><span class="line">        + <span class="string">"INNER JOIN(SELECT spec_id, max(id) as id FROM %1$s GROUP BY spec_id) latest "</span></span><br><span class="line">        + <span class="string">"ON r.id = latest.id"</span>,</span><br><span class="line">        getSupervisorsTable()</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>如上所示，分析这条sql语句可以看的出来，这里是将最新的摄入规则给取出来了，这里的摄入规则就是我们提交任务之前的json体。接下来就是supervisor的创建了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createAndStartSupervisorInternal</span><span class="params">(SupervisorSpec spec, <span class="keyword">boolean</span> persistSpec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String id = spec.getId();</span><br><span class="line">  <span class="keyword">if</span> (supervisors.containsKey(id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (persistSpec) &#123;</span><br><span class="line">    <span class="comment">// 保存摄入规则的元数据</span></span><br><span class="line">    metadataSupervisorManager.insert(id, spec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Supervisor supervisor;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建supervisor对象</span></span><br><span class="line">    supervisor = spec.createSupervisor();</span><br><span class="line">    supervisor.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// Supervisor creation or start failed write tombstone only when trying to start a new supervisor</span></span><br><span class="line">    <span class="keyword">if</span> (persistSpec) &#123;</span><br><span class="line">      metadataSupervisorManager.insert(id, <span class="keyword">new</span> NoopSupervisorSpec(<span class="keyword">null</span>, spec.getDataSources()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  supervisors.put(id, Pair.of(supervisor, spec));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面也分成了几个过程：</p><ul><li>获取该摄入规则的id（<code>摄入规则的id是用datasource来区分的</code>）</li><li>根据是否需要持久化摄入规则来确定将这些摄入规则持久化（很明显我们刚刚从数据库中取出来，肯定是不需要持久化的）</li><li>创建并启动<code>Supervisor</code>，这里会根据摄入规则数据源类型的不同来创建不同类型的supervisor，并将supervisor相关的信息保存在内存中</li></ul><p>我们接下来看一下<code>start</code>方法的调用过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateChangeLock) &#123;</span><br><span class="line">      Preconditions.checkState(!lifecycleStarted, <span class="string">"already started"</span>);</span><br><span class="line">      Preconditions.checkState(!exec.isShutdown(), <span class="string">"already stopped"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try normal initialization first, if that fails then schedule periodic initialization retries</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        tryInit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">          log.warn(</span><br><span class="line">              <span class="string">"First initialization attempt failed for SeekableStreamSupervisor[%s], starting retries..."</span>,</span><br><span class="line">              dataSource</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          exec.submit(</span><br><span class="line">              () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  RetryUtils.retry(</span><br><span class="line">                      () -&gt; &#123;</span><br><span class="line">                        tryInit();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      (throwable) -&gt; !started,</span><br><span class="line">                      <span class="number">0</span>,</span><br><span class="line">                      MAX_INITIALIZATION_RETRIES,</span><br><span class="line">                      <span class="keyword">null</span>,</span><br><span class="line">                      <span class="keyword">null</span></span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                  log.makeAlert(</span><br><span class="line">                      <span class="string">"Failed to initialize after %s retries, aborting. Please resubmit the supervisor spec to restart this supervisor [%s]"</span>,</span><br><span class="line">                      MAX_INITIALIZATION_RETRIES,</span><br><span class="line">                      supervisorId</span><br><span class="line">                  ).emit();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e2);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lifecycleStarted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面这一坨代码其实就做了一件事，那就是调用<code>tryInit()</code>方法，只不过在调用抛出异常的时候增加了失败重试的机制。我们来看一下<code>tryInit()</code>做了什么操作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (stateChangeLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      log.warn(<span class="string">"Supervisor was already started, skipping init"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stopped) &#123;</span><br><span class="line">      log.warn(<span class="string">"Supervisor was already stopped, skipping init."</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      recordSupplier = setupRecordSupplier();</span><br><span class="line"></span><br><span class="line">      exec.submit(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">long</span> pollTimeout = Math.max(ioConfig.getPeriod().getMillis(), MAX_RUN_FREQUENCY_MILLIS);</span><br><span class="line">              <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !stopped) &#123;</span><br><span class="line">                <span class="keyword">final</span> Notice notice = notices.poll(pollTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (notice == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 这一步才是真正的触发任务执行的调用</span></span><br><span class="line">                    notice.handle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  stateManager.recordThrowableEvent(e);</span><br><span class="line">                  log.makeAlert(e, <span class="string">"SeekableStreamSupervisor[%s] failed to handle notice"</span>, dataSource)</span><br><span class="line">                     .addData(<span class="string">"noticeClass"</span>, notice.getClass().getSimpleName())</span><br><span class="line">                     .emit();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              stateManager.recordThrowableEvent(e);</span><br><span class="line">              log.info(<span class="string">"SeekableStreamSupervisor[%s] interrupted, exiting"</span>, dataSource);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line">      firstRunTime = DateTimes.nowUtc().plus(ioConfig.getStartDelay());</span><br><span class="line">      scheduledExec.scheduleAtFixedRate(</span><br><span class="line">          buildRunTask(),</span><br><span class="line">          ioConfig.getStartDelay().getMillis(),</span><br><span class="line">          Math.max(ioConfig.getPeriod().getMillis(), MAX_RUN_FREQUENCY_MILLIS),</span><br><span class="line">          TimeUnit.MILLISECONDS</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      scheduleReporting(reportingExec);</span><br><span class="line"></span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      .........</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的过程依次是：</p><ul><li>检查supervisor状态的合法性</li><li>配置消费数据的客户端的属性（对于kafka类型的摄入规则来说，这一步就是创建consumer，我们接下来会具体分析一下）</li><li>构建运行的任务并提交运行，接着使用摄入规则中定义的周期周期性的定时调度来构建运行的任务</li></ul><p>这里我们看到有创建<code>recordSupplier = setupRecordSupplier();</code>，不过这也是一个模板方法，真正的实现我们就挑一个kafka的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RecordSupplier&lt;Integer, Long&gt; <span class="title">setupRecordSupplier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> KafkaRecordSupplier(spec.getIoConfig().getConsumerProperties(), sortingMapper);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaRecordSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; consumerProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectMapper sortingMapper</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(getKafkaConsumer(sortingMapper, consumerProperties));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaRecordSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    KafkaConsumer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; consumer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.consumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，recordSupplier里面是封装了一个kafkaConsumer，到此为止，我们也就不再过多的深究了。</p><p>接下来我们看一下构建的任务吧，具体入口就是上面的notice.handle()，跟进下来代码最终会走到下面这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">buildRunTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> () -&gt; notices.add(<span class="keyword">new</span> RunNotice());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runInternal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    possiblyRegisterListener();</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.CONNECTING_TO_STREAM);</span><br><span class="line">    <span class="comment">// TODO 这里猜测应该就是低版本的kafka连接不上存在问题的原因</span></span><br><span class="line">    <span class="keyword">if</span> (!updatePartitionDataFromStream() &amp;&amp; !stateManager.isAtLeastOneSuccessfulRun()) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// if we can't connect to the stream and this is the first run, stop and wait to retry the connection</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.DISCOVERING_INITIAL_TASKS);</span><br><span class="line">    discoverTasks();</span><br><span class="line"></span><br><span class="line">    updateTaskStatus();</span><br><span class="line"></span><br><span class="line">    checkTaskDuration();</span><br><span class="line"></span><br><span class="line">  checkPendingCompletionTasks();</span><br><span class="line"></span><br><span class="line">  checkCurrentTaskState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if supervisor is not suspended, ensure required tasks are running</span></span><br><span class="line">  <span class="comment">// if suspended, ensure tasks have been requested to gracefully stop</span></span><br><span class="line">  <span class="keyword">if</span> (!spec.isSuspended()) &#123;</span><br><span class="line">    log.info(<span class="string">"[%s] supervisor is running."</span>, dataSource);</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.CREATING_TASKS);</span><br><span class="line">    createNewTasks();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">"[%s] supervisor is suspended."</span>, dataSource);</span><br><span class="line">      gracefulShutdownInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是根据摄入规则运行任务的整个过程，这里我们没有提到的是通过http的方式提交任务的过程，不过这个也不是太难，具体可以查看http接口的方式找到入口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</span><br><span class="line"><span class="meta">@Produces</span>(MediaType.APPLICATION_JSON)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">specPost</span><span class="params">(<span class="keyword">final</span> SupervisorSpec spec, @Context <span class="keyword">final</span> HttpServletRequest req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asLeaderWithSupervisorManager(</span><br><span class="line">      manager -&gt; &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment">// 这一步会创建或者更新supervisor</span></span><br><span class="line">        manager.createOrUpdateAndStartSupervisor(spec);</span><br><span class="line">        <span class="keyword">return</span> Response.ok(ImmutableMap.of(<span class="string">"id"</span>, spec.getId())).build();</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就不过多的赘述http的请求流程了，总而言之一句话，通过http的方式创建任务最终也会走到上面的代码逻辑中。在上面的runInternal方法中我们可以看到有一行createNewTasks的代码，创建任务最终就是进入到这个方法中。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewTasks</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 由于是新创建的任务，因此这里的任务数量必定是0</span></span><br><span class="line">  <span class="comment">// iterate through all the current task groups and make sure each one has the desired number of replica tasks</span></span><br><span class="line">  <span class="keyword">boolean</span> createdTask = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, TaskGroup&gt; entry : activelyReadingTaskGroups.entrySet()) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (ioConfig.getReplicas() &gt; taskGroup.tasks.size()) &#123;</span><br><span class="line">      ......</span><br><span class="line">      createTasksForGroup(groupId, ioConfig.getReplicas() - taskGroup.tasks.size());</span><br><span class="line">      createdTask = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (createdTask &amp;&amp; firstRunTime.isBeforeNow()) &#123;</span><br><span class="line">    <span class="comment">// Schedule a run event after a short delay to update our internal data structures with the new tasks that were</span></span><br><span class="line">    <span class="comment">// just created. This is mainly for the benefit of the status API in situations where the run period is lengthy.</span></span><br><span class="line">    scheduledExec.schedule(buildRunTask(), <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们省略了不必要的代码，可以看到创建任务走到createTasksForGroup这个方法中了，点开这个方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTasksForGroup</span><span class="params">(<span class="keyword">int</span> groupId, <span class="keyword">int</span> replicas)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JsonProcessingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TaskGroup group = activelyReadingTaskGroups.get(groupId);</span><br><span class="line">  Map&lt;PartitionIdType, SequenceOffsetType&gt; startPartitions = group.startingSequences;</span><br><span class="line">  Map&lt;PartitionIdType, SequenceOffsetType&gt; endPartitions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (PartitionIdType partition : startPartitions.keySet()) &#123;</span><br><span class="line">    endPartitions.put(partition, getEndOfPartitionMarker());</span><br><span class="line">  &#125;</span><br><span class="line">  Set&lt;PartitionIdType&gt; exclusiveStartSequenceNumberPartitions = activelyReadingTaskGroups</span><br><span class="line">      .get(groupId)</span><br><span class="line">      .exclusiveStartSequenceNumberPartitions;</span><br><span class="line"></span><br><span class="line">  DateTime minimumMessageTime = group.minimumMessageTime.orNull();</span><br><span class="line">  DateTime maximumMessageTime = group.maximumMessageTime.orNull();</span><br><span class="line"></span><br><span class="line">  SeekableStreamIndexTaskIOConfig newIoConfig = createTaskIoConfig(</span><br><span class="line">      groupId,</span><br><span class="line">      startPartitions,</span><br><span class="line">      endPartitions,</span><br><span class="line">      group.baseSequenceName,</span><br><span class="line">      minimumMessageTime,</span><br><span class="line">      maximumMessageTime,</span><br><span class="line">      exclusiveStartSequenceNumberPartitions,</span><br><span class="line">      ioConfig</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  List&lt;SeekableStreamIndexTask&lt;PartitionIdType, SequenceOffsetType&gt;&gt; taskList = createIndexTasks(</span><br><span class="line">      replicas,</span><br><span class="line">      group.baseSequenceName,</span><br><span class="line">      sortingMapper,</span><br><span class="line">      group.checkpointSequences,</span><br><span class="line">      newIoConfig,</span><br><span class="line">      taskTuningConfig,</span><br><span class="line">      rowIngestionMetersFactory</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (SeekableStreamIndexTask indexTask : taskList) &#123;</span><br><span class="line">    Optional&lt;TaskQueue&gt; taskQueue = taskMaster.getTaskQueue();</span><br><span class="line">    <span class="keyword">if</span> (taskQueue.isPresent()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 添加task的时候如果有异常则说明添加失败，添加成功之后，会通过定期调度来执行znode节点的创建</span></span><br><span class="line">        taskQueue.get().add(indexTask);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (EntryExistsException e) &#123;</span><br><span class="line">        stateManager.recordThrowableEvent(e);</span><br><span class="line">        log.error(<span class="string">"Tried to add task [%s] but it already exists"</span>, indexTask.getId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to get task queue because I'm not the leader!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到首先是摄入任务的一些正常配置，<strong>接下来会获取到taskMaster的taskQueue</strong>，这里就是新建任务的核心内容了，也是整个业务的关键，其主要思想就是通过taskQueue实现任务的生产和消费，这个也算是一种很常用的模式了，生产的话就是将新建的任务存放到队列中，消费的话就是将任务从队列中取出来，并跟新到zookeeper节点下面，催生peon进程了，上面我们看到了生产任务的过程，消费任务的话要从taskMatser看起了，不过taskMaster也仅仅是任务的入口，并不是真正消费任务的地方，其中的核心代码就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.leadershipListener = <span class="keyword">new</span> DruidLeaderSelector.Listener()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">becomeLeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    giant.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I AM THE MASTER OF THE UNIVERSE.</span></span><br><span class="line">    log.info(<span class="string">"By the power of Grayskull, I have the power!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      taskLockbox.syncFromStorage();</span><br><span class="line">      taskRunner = runnerFactory.build();</span><br><span class="line">      taskQueue = <span class="keyword">new</span> TaskQueue(</span><br><span class="line">          taskLockConfig,</span><br><span class="line">          taskQueueConfig,</span><br><span class="line">          taskStorage,</span><br><span class="line">          taskRunner,</span><br><span class="line">          taskActionClientFactory,</span><br><span class="line">          taskLockbox,</span><br><span class="line">          emitter</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sensible order to start stuff:</span></span><br><span class="line">      <span class="keyword">final</span> Lifecycle leaderLifecycle = <span class="keyword">new</span> Lifecycle(<span class="string">"task-master"</span>);</span><br><span class="line">      <span class="keyword">if</span> (leaderLifecycleRef.getAndSet(leaderLifecycle) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.makeAlert(<span class="string">"TaskMaster set a new Lifecycle without the old one being cleared!  Race condition"</span>)</span><br><span class="line">           .emit();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.addManagedInstance(taskRunner);</span><br><span class="line">      leaderLifecycle.addManagedInstance(taskQueue);</span><br><span class="line">      leaderLifecycle.addManagedInstance(supervisorManager);</span><br><span class="line">      leaderLifecycle.addManagedInstance(overlordHelperManager);</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.addHandler(</span><br><span class="line">          <span class="keyword">new</span> Lifecycle.Handler()</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">              initialized = <span class="keyword">true</span>;</span><br><span class="line">              serviceAnnouncer.announce(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">              serviceAnnouncer.unannounce(node);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      giant.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopBeingLeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    giant.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      initialized = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">final</span> Lifecycle leaderLifecycle = leaderLifecycleRef.getAndSet(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (leaderLifecycle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leaderLifecycle.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      giant.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们可以看到taskMaster首先是使用了zookeeper进行选主操作，一旦选出来之后，就会执行一些初始化的操作，这些初始化的操作是<code>leaderLifecycle.addManagedInstance</code>完成的，上文也有解释<code>leaderLifecycle</code>像是一个钩子，会自动的初始化一些操作，这里我们可以跟进一下TaskQueue的start方法，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LifecycleStart</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">giant.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Preconditions.checkState(!active, <span class="string">"queue must be stopped"</span>);</span><br><span class="line">  active = <span class="keyword">true</span>;</span><br><span class="line">  syncFromStorage();</span><br><span class="line">  managerExec.submit(</span><br><span class="line">      <span class="keyword">new</span> Runnable()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              manage();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">  );</span><br><span class="line">  ScheduledExecutors.scheduleAtFixedRate(</span><br><span class="line">      storageSyncExec,</span><br><span class="line">      config.getStorageSyncRate(),</span><br><span class="line">      <span class="keyword">new</span> Callable&lt;ScheduledExecutors.Signal&gt;()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ScheduledExecutors.<span class="function">Signal <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            syncFromStorage();</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">  managementMayBeNecessary.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  giant.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们看到主要是两块的业务逻辑<code>manage()、syncFromStorage()</code>，当前我们是跟进任务的创建，因此下面的代码可以暂时搁置。我们看一下manage执行了什么操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">manage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">log.info(<span class="string">"Beginning management in %s."</span>, config.getStartDelay());</span><br><span class="line">Thread.sleep(config.getStartDelay().getMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore return value- we'll get the IDs and futures from getKnownTasks later.</span></span><br><span class="line">taskRunner.restore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (active) &#123;</span><br><span class="line">  giant.lock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Task futures available from the taskRunner</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, ListenableFuture&lt;TaskStatus&gt;&gt; runnerTaskFutures = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> TaskRunnerWorkItem workItem : taskRunner.getKnownTasks()) &#123;</span><br><span class="line">      runnerTaskFutures.put(workItem.getTaskId(), workItem.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Attain futures for all active tasks (assuming they are ready to run).</span></span><br><span class="line">    <span class="comment">// Copy tasks list, as notifyStatus may modify it.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Task task : ImmutableList.copyOf(tasks)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!taskFutures.containsKey(task.getId())) &#123;</span><br><span class="line">        <span class="keyword">final</span> ListenableFuture&lt;TaskStatus&gt; runnerTaskFuture;</span><br><span class="line">        <span class="keyword">if</span> (runnerTaskFutures.containsKey(task.getId())) &#123;</span><br><span class="line">          runnerTaskFuture = runnerTaskFutures.get(task.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Task should be running, so run it.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> taskIsReady;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            taskIsReady = task.isReady(taskActionClientFactory.create(task));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(e, <span class="string">"Exception thrown during isReady for task: %s"</span>, task.getId());</span><br><span class="line">            notifyStatus(task, TaskStatus.failure(task.getId()), <span class="string">"failed because of exception[%s]"</span>, e.getClass());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (taskIsReady) &#123;</span><br><span class="line">            log.info(<span class="string">"Asking taskRunner to run: %s"</span>, task.getId());</span><br><span class="line">            runnerTaskFuture = taskRunner.run(task);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskFutures.put(task.getId(), attachCallbacks(task, runnerTaskFuture));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTaskPending(task)) &#123;</span><br><span class="line">        <span class="comment">// if the taskFutures contain this task and this task is pending, also let the taskRunner</span></span><br><span class="line">        <span class="comment">// to run it to guarantee it will be assigned to run</span></span><br><span class="line">        <span class="comment">// see https://github.com/apache/druid/pull/6991</span></span><br><span class="line">        taskRunner.run(task);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Kill tasks that shouldn't be running</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; tasksToKill = Sets.difference(</span><br><span class="line">        runnerTaskFutures.keySet(),</span><br><span class="line">        ImmutableSet.copyOf(</span><br><span class="line">            Lists.transform(</span><br><span class="line">                tasks,</span><br><span class="line">                <span class="keyword">new</span> Function&lt;Task, Object&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function">                  </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> task.getId();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!tasksToKill.isEmpty()) &#123;</span><br><span class="line">      log.info(<span class="string">"Asking taskRunner to clean up %,d tasks."</span>, tasksToKill.size());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> String taskId : tasksToKill) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          taskRunner.shutdown(</span><br><span class="line">              taskId,</span><br><span class="line">              <span class="string">"task is not in runnerTaskFutures[%s]"</span>,</span><br><span class="line">              runnerTaskFutures.keySet()</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(e, <span class="string">"TaskRunner failed to clean up task: %s"</span>, taskId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// awaitNanos because management may become necessary without this condition signalling,</span></span><br><span class="line">    <span class="comment">// due to e.g. tasks becoming ready when other folks mess with the TaskLockbox.</span></span><br><span class="line">    managementMayBeNecessary.awaitNanos(MANAGEMENT_WAIT_TIMEOUT_NANOS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    giant.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是一个死循环，主要的操作就是<code>taskRunner.run(task);</code>这一行代码，这里的taskRunner是一个接口，我们可以任选一个实现累来看一下任务创建的过程是怎么样的，这里我选了<code>RemoteTaskRunner</code>，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListenableFuture&lt;TaskStatus&gt; <span class="title">run</span><span class="params">(<span class="keyword">final</span> Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> RemoteTaskRunnerWorkItem completeTask, runningTask, pendingTask;</span><br><span class="line">  <span class="keyword">if</span> ((pendingTask = pendingTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    log.info(<span class="string">"Assigned a task[%s] that is already pending!"</span>, task.getId());</span><br><span class="line">    runPendingTasks();</span><br><span class="line">    <span class="keyword">return</span> pendingTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((runningTask = runningTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ZkWorker zkWorker = findWorkerRunningTask(task.getId());</span><br><span class="line">    <span class="keyword">if</span> (zkWorker == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.warn(<span class="string">"Told to run task[%s], but no worker has started running it yet."</span>, task.getId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">"Task[%s] already running on %s."</span>, task.getId(), zkWorker.getWorker().getHost());</span><br><span class="line">      TaskAnnouncement announcement = zkWorker.getRunningTasks().get(task.getId());</span><br><span class="line">      <span class="keyword">if</span> (announcement.getTaskStatus().isComplete()) &#123;</span><br><span class="line">        taskComplete(runningTask, zkWorker, announcement.getTaskStatus());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runningTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((completeTask = completeTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> completeTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addPendingTask(task).getResult();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面有一行代码<code>runPendingTasks</code>，跟进该代码可以发现有一行代码<code>tryAssignTask(task, taskRunnerWorkItem)</code>，该过程是一个阻塞的过程，核心代码也只有一行：<code>announceTask</code>，该方法的目的就是在zookeeper上发布一个任务，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">announceTask</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Task task,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ZkWorker theZkWorker,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemoteTaskRunnerWorkItem taskRunnerWorkItem</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String worker = theZkWorker.getWorker().getHost();</span><br><span class="line">  <span class="keyword">synchronized</span> (statusLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!zkWorkers.containsKey(worker) || lazyWorkers.containsKey(worker)) &#123;</span><br><span class="line">      <span class="comment">// the worker might have been killed or marked as lazy</span></span><br><span class="line">      log.info(<span class="string">"Not assigning task to already removed worker[%s]"</span>, worker);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"Coordinator asking Worker[%s] to add task[%s]"</span>, worker, task.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建znode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CuratorUtils.createIfNotExists(</span><br><span class="line">        cf,</span><br><span class="line">        JOINER.join(indexerZkConfig.getTasksPath(), worker, task.getId()),</span><br><span class="line">        CreateMode.EPHEMERAL,</span><br><span class="line">        jsonMapper.writeValueAsBytes(task),</span><br><span class="line">        config.getMaxZnodeBytes()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    RemoteTaskRunnerWorkItem workItem = pendingTasks.remove(task.getId());</span><br><span class="line">    <span class="keyword">if</span> (workItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.makeAlert(<span class="string">"WTF?! Got a null work item from pending tasks?! How can this be?!"</span>)</span><br><span class="line">         .addData(<span class="string">"taskId"</span>, task.getId())</span><br><span class="line">         .emit();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RemoteTaskRunnerWorkItem newWorkItem = workItem.withWorker(theZkWorker.getWorker(), <span class="keyword">null</span>);</span><br><span class="line">    runningTasks.put(task.getId(), newWorkItem);</span><br><span class="line">    log.info(<span class="string">"Task %s switched from pending to running (on [%s])"</span>, task.getId(), newWorkItem.getWorker().getHost());</span><br><span class="line">    TaskRunnerUtils.notifyStatusChanged(listeners, task.getId(), TaskStatus.running(task.getId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Syncing state with Zookeeper - don't assign new tasks until the task we just assigned is actually running</span></span><br><span class="line">    <span class="comment">// on a worker - this avoids overflowing a worker with tasks</span></span><br><span class="line">    Stopwatch timeoutStopwatch = Stopwatch.createStarted();</span><br><span class="line">    <span class="keyword">while</span> (!isWorkerRunningTask(theZkWorker, task.getId())) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> waitMs = config.getTaskAssignmentTimeout().toStandardDuration().getMillis();</span><br><span class="line">      statusLock.wait(waitMs);</span><br><span class="line">      <span class="keyword">long</span> elapsed = timeoutStopwatch.elapsed(TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (elapsed &gt;= waitMs) &#123;</span><br><span class="line">        log.makeAlert(</span><br><span class="line">            <span class="string">"Task assignment timed out on worker [%s], never ran task [%s]! Timeout: (%s &gt;= %s)!"</span>,</span><br><span class="line">            worker,</span><br><span class="line">            task.getId(),</span><br><span class="line">            elapsed,</span><br><span class="line">            config.getTaskAssignmentTimeout()</span><br><span class="line">        ).emit();</span><br><span class="line">        taskComplete(taskRunnerWorkItem, theZkWorker, TaskStatus.failure(task.getId()));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，提交摄入任务并在zookeeper上面发布任务的正流程就结束了，不过这个时候任务并没有被peon进程领取并执行，另外还包含一些细节，如taskMaster故障之后重新选举任务的重建过程是怎么样的。这些就留着以后有时间再来分析了吧。</p><h2 id="broker源码走读"><a href="#broker源码走读" class="headerlink" title="broker源码走读"></a>broker源码走读</h2><p>上面的过程中我们简单的看了一下提交摄入任务的整体流程，也看到了任务是如何在zookeeper上进行发布的，也就是数据的摄入是如何执行的，另外一个核心的问题就是数据的查询是什么流程了，这个我们可以采用同样的方式，从http接口的方式来分析具体的实现，具体入口如下：</p><h2 id="MiddleManager源码走读"><a href="#MiddleManager源码走读" class="headerlink" title="MiddleManager源码走读"></a>MiddleManager源码走读</h2><p>在真正走读代码之前我们还是先回顾一下MiddleManager的功能，并通过功能作为入口一点一点的深入代码的解析。首先从官网上我们知道middleManager是用来摄入数据的，数据的摄入又分为以下几个步骤：</p><ul><li>对于一个append类型的任务来说，会调用Overload上的allocate接口来生成segment的唯一标识，对于一个覆盖写的任务来说这是通过锁定一个时间区间并创建一个新的版本号来实现的</li><li>如果是一个realtime类型的摄入任务的话，segment马上就可以查到了，但是当前的segment并未发布</li><li>当完成了当前segment数据的摄入之后，将会把segment发不到深度存储中，并且记录当前segment的元数据，如果是realtime类型的task，那么还会等待Historical进程来加载数据，否则的话segment会马上存在与historical进程所在的节点上</li></ul><p>知道了MiddleManager的功能之后，我们就可以通过跟踪代码来看一下具体的流程了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间关系，关于druid启动的流程我们的分析就到此为止了，后面会专门针对具体的process来查看具体的功能代码。</p><p><a href="https://www.jianshu.com/p/c04db5d3ed90" target="_blank" rel="noopener">Druid中用到的一些技术</a></p><h1 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h1><p>1、生产环境中realtime的内存设置为1G，结果发现对于两个字段的groupby操作经常会将实时摄入的节点打卦，后面经过每秒上报数据评估以及SQL查询的条件估算实际，对应时间区间的内存大小为3G，因此调整之后解决了查询数据量将节点打卦的情况，但是依然留存一个问题，就是查询效率，因为在定制sql的时候，采用了两个字段的groupBy的操作，结果发现，相较于一个字段的group by，两个字段进行groupby明显要慢很多。后面查阅资料发现，单个字段的groupBY会被优化成topn查询，因此，我们的业务将需要进行两个字段的groupby采用transform的方式在摄入的时候将其拼接成一个字段，这样针对这一个字段进行groupBY，效率明显提升上去了，大致从原来的20s提升为2s。</p><p>另外在实际操作的过程中，由于我们数据摄入是从kafka中获取到的，而kafka中消息是一个宽消息，对应为null或者为空字符串的字段在数据摄入的时候会被转换成0（转换的过程中会抛出大量的process error，但是结果并不会受到影响），由于查询需要，我这边需要把非0的数据过滤出来，因此在sql查询的时候是通过！=0的方式来过滤的，结果很奇怪，查询结果中竟然包含了为0 的选项，因此我又试了一下&gt;0的选项，结果发现这次筛选出来的数据完全满足要求了，最后我又筛选了=0的选项，从整体的条数来判断，=0的数据量也是对的上的，因此，对于&gt;0的选项还不清楚为什么这种查询条件会把=0的数据给查询出来。有待跟进</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>quartz 源码剖析</title>
      <link href="/2019/10/16/quartz-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/10/16/quartz-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工作的过程中有使用过quartz进行作业的调度，通常情况下我们是可以使用jdk自带的调度来实现一些简单的调度，不过当需要使用比较高级的调度功能的时候，jdk自带的调度功能就没有办法满足了，比如我们希望只有周末或者月末不进行调度，节假日不进行调度等。使用之余自然也对其调度的原理比较感兴趣，因此花了点时间来进行学习源码。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="quickstart"><a href="#quickstart" class="headerlink" title="quickstart"></a>quickstart</h2><p>我们首先通过一个示例来演示一下quartz如何实现作业的调度，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStart</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(StartJob.class).withIdentity("quick start", "wes").build();</span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger().withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">10</span>)).startNow().build();</span><br><span class="line">        scheduler.start();</span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StartJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"quick start!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码最终是以10s中执行一次StartJob，具体输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">quick start!</span><br><span class="line">quick start!</span><br><span class="line">quick start!</span><br><span class="line">quick start!</span><br><span class="line">quick start!</span><br></pre></td></tr></table></figure><h2 id="框架下的实体，及实体之间的关系"><a href="#框架下的实体，及实体之间的关系" class="headerlink" title="框架下的实体，及实体之间的关系"></a>框架下的实体，及实体之间的关系</h2><p>在介绍quartz之前我们先来看一下其中存在的一些实体概念：</p><ul><li>JobDetail表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。</li><li>Trigger代表一个调度参数的配置，什么时候去调。</li><li>Scheduler代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。</li></ul><p>下面我们用一张图来演示一下这些实体之间的关系(此图来源于网上)，如下：</p><p><img src="//southrivers.github.io/2019/10/16/quartz-源码剖析/quartz.png" alt></p><p>上图中最核心的应该就是scheduler了，这是整个调度的核心，触发调度的核心就是<code>scheduler.start()</code>，接下来的分析就从这里开始。</p><h2 id="quartz调度的实现"><a href="#quartz调度的实现" class="headerlink" title="quartz调度的实现"></a>quartz调度的实现</h2><p><code>scheduler.start()</code>方法执行会进入如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> QuartzScheduler sched;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line">    sched.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我们看到stdScheduler会调用QuartzScheduler的start方法，这可以说明我们的StdScheduler其实是QuartzScheduler的一个代理。接下来我们看一下QuartzScheduler的start方法执行了什么操作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 在启动QuartzScheduler之前，通知到当前调度器的listener</span></span><br><span class="line">    notifySchedulerListenersStarting();</span><br><span class="line"></span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">// 将pause标志位改为false</span></span><br><span class="line">    schedThread.togglePause(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 通知listener，scheduler完成启动</span></span><br><span class="line">    notifySchedulerListenersStarted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我省略了部分不必要的代码，将流程大致分为三个步骤，分别是：</p><ul><li>通知当前scheduler的listener该scheduler开始启动</li><li>将调度线程的pause标志位改为false</li><li>最后在完成启动的之后再次通知对应的listener已经完成调度器的启动</li></ul><p>这里的listener和tomcat的listener机制很相似，其为框架提供了一种可扩展的机制。上面代码中的核心步骤就是<code>schedThread.togglePause(false)</code>这一行，接下来我们跟进一下，看这一步究竟做了什么工作吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">togglePause</span><span class="params">(<span class="keyword">boolean</span> pause)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sigLock) &#123;</span><br><span class="line">        paused = pause;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (paused) &#123;</span><br><span class="line">            signalSchedulingChange(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sigLock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们首先会获取当前对象的一个锁，然后<code>sigLock</code>来实现多线程的同步操作。在初始阶段，代码的执行会走到下面<code>sigLock.notifyAll();</code>，这一步的操作就是通知所有等待在该对象上的线程进行一些操作，我们接下来看一下在该对象上等待的线程在被唤醒前和唤醒后分别执行了什么操作吧，接下来我们就不绕弯子了，直接进入正题QuartzScheduler的run方法，代码有点长：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> acquiresFailed = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待scheduler将pause置为false，这个是通过scheduler.start方法来设定的</span></span><br><span class="line">    <span class="keyword">while</span> (!halted.get()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// check if we're supposed to pause...</span></span><br><span class="line">            <span class="keyword">synchronized</span> (sigLock) &#123;</span><br><span class="line">                <span class="keyword">while</span> (paused &amp;&amp; !halted.get()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// wait until togglePause(false) is called...</span></span><br><span class="line">                        sigLock.wait(<span class="number">1000L</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// reset failure counter when paused, so that we don't</span></span><br><span class="line">                    <span class="comment">// wait again after unpausing</span></span><br><span class="line">                    acquiresFailed = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (halted.get()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            .....</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 阻塞的方式获取当前可用的线程的数量，如果获取不到则会一直阻塞</span></span><br><span class="line">            <span class="keyword">int</span> availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();</span><br><span class="line">            <span class="keyword">if</span>(availThreadCount &gt; <span class="number">0</span>) &#123; <span class="comment">// will always be true, due to semantics of blockForAvailableThreads...</span></span><br><span class="line"></span><br><span class="line">                List&lt;OperableTrigger&gt; triggers;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                clearSignaledSchedulingChange();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    triggers = qsRsrcs.getJobStore().acquireNextTriggers(</span><br><span class="line">                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</span><br><span class="line">                    acquiresFailed = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">                        log.debug(<span class="string">"batch acquisition of "</span> + (triggers == <span class="keyword">null</span> ? <span class="number">0</span> : triggers.size()) + <span class="string">" triggers"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (triggers != <span class="keyword">null</span> &amp;&amp; !triggers.isEmpty()) &#123;</span><br><span class="line"></span><br><span class="line">                    .....</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// set triggers to 'executing'</span></span><br><span class="line">                    List&lt;TriggerFiredResult&gt; bndles = <span class="keyword">new</span> ArrayList&lt;TriggerFiredResult&gt;();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> goAhead = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">synchronized</span>(sigLock) &#123;</span><br><span class="line">                        goAhead = !halted.get();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 获取当前trigers对应的作业的详细信息</span></span><br><span class="line">                    <span class="keyword">if</span>(goAhead) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</span><br><span class="line">                            <span class="keyword">if</span>(res != <span class="keyword">null</span>)</span><br><span class="line">                                bndles = res;</span><br><span class="line">                        &#125;</span><br><span class="line">                        ......</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bndles.size(); i++) &#123;</span><br><span class="line">                        TriggerFiredResult result =  bndles.get(i);</span><br><span class="line">                        TriggerFiredBundle bndle =  result.getTriggerFiredBundle();</span><br><span class="line">                        Exception exception = result.getException();</span><br><span class="line">                        </span><br><span class="line">                        .....</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// it's possible to get 'null' if the triggers was paused,</span></span><br><span class="line">                        <span class="comment">// blocked, or other similar occurrences that prevent it being</span></span><br><span class="line">                        <span class="comment">// fired at this time...  or if the scheduler was shutdown (halted)</span></span><br><span class="line">                        <span class="keyword">if</span> (bndle == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 使用JobShell封装代执行的作业</span></span><br><span class="line">                        JobRunShell shell = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</span><br><span class="line">                            shell.initialize(qs);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (SchedulerException se) &#123;</span><br><span class="line">                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 将作业丢到线程池中执行并返回，注意这里并不是阻塞调用，有返回值主要是为了判断将作业提交到线程池的时候是否有异常</span></span><br><span class="line">                        <span class="keyword">if</span> (qsRsrcs.getThreadPool().runInThread(shell) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                            <span class="comment">// this case should never happen, as it is indicative of the</span></span><br><span class="line">                            <span class="comment">// scheduler being shutdown or a bug in the thread pool or</span></span><br><span class="line">                            <span class="comment">// a thread pool being used concurrently - which the docs</span></span><br><span class="line">                            <span class="comment">// say not to do...</span></span><br><span class="line">                            getLog().error(<span class="string">"ThreadPool.runInThread() return false!"</span>);</span><br><span class="line">                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">continue</span>; <span class="comment">// while (!halted)</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码整体有点长，这里我删除了不算太重要的内容，从流程上来看的话也还算比较简单，代码中已经备注了相关的信息：</p><ul><li>等待scheduler将pause置为false，这个是通过scheduler.start方法来设定的</li><li>阻塞的方式获取当前可用的线程的数量，如果获取不到则会一直阻塞</li><li>获取当前triggers，以及其对应的作业的详细信息</li><li>使用JobShell封装待执行的作业，并将该作业丢到线程之中执行</li></ul><p>上面分析了scheduler启动的过程，在上面这个过程中的最后是将作业提交到线程池中进行执行，具体作业是怎么执行的我们还没有看到，接下来我们继续跟进代码来分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">runInThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runnable == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (nextRunnableLock) &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment">// 从availWorkers获取对应的资源用于执行任务</span></span><br><span class="line">        <span class="keyword">if</span> (!isShutdown) &#123;</span><br><span class="line">            WorkerThread wt = (WorkerThread)availWorkers.removeFirst();</span><br><span class="line">            busyWorkers.add(wt);</span><br><span class="line">            wt.run(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        nextRunnableLock.notifyAll();</span><br><span class="line">        handoffPending = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中我们可以看到有availWorkers和busyWorkers两个列表，这种模式在池化资源的时候非常有用，总结其目的无非就是实现线程的复用和线程体量的控制，作业的具体执行还在于提交的Runnable的run方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    qs.addInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OperableTrigger trigger = (OperableTrigger) jec.getTrigger();</span><br><span class="line">        JobDetail jobDetail = jec.getJobDetail();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line"></span><br><span class="line">            JobExecutionException jobExEx = <span class="keyword">null</span>;</span><br><span class="line">            Job job = jec.getJobInstance();</span><br><span class="line"></span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// execute the job</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Calling execute on job "</span> + jobDetail.getKey());</span><br><span class="line">                job.execute(jec);</span><br><span class="line">                endTime = System.currentTimeMillis();</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">            jec.setJobRunTime(endTime - startTime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// notify all job listeners</span></span><br><span class="line">            <span class="keyword">if</span> (!notifyJobListenersComplete(jec, jobExEx)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ....</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                complete(<span class="keyword">true</span>);</span><br><span class="line">            &#125; ....</span><br><span class="line"></span><br><span class="line">            qs.notifyJobStoreJobComplete(trigger, jobDetail, instCode);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        qs.removeInternalSchedulerListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中具体的流程可以大致分为几个步骤：</p><ul><li>使用jobFactory通过反射的方式获取job实例</li><li>执行job对象的execute方法</li><li>通知作业监听器当前作业完成情况</li></ul><p>到此整个作业调度的流程我们大致看完了，不过quartz实现的作业调度的方式远不止这么简单，其本身是具备分布式调度的能力，至于如何实现分布式调度，那肯定是需要协调者存在的，通常可以使用数据库，另外作业相关的信息也是可以持久化到数据库中的，不过这些暂时没有用到，因此也就不整理了。另外分布式的调度也有基于quartz基础之上实现的，业内使用的比较广泛的应该就是elastic-job了，其中协调者使用的是zookeeper来完成的。接下来我们来演示一个稍微复杂的例子，通过quartz来构建一个DAG（列表简化版的DAG）</p><h2 id="DAG的实现"><a href="#DAG的实现" class="headerlink" title="DAG的实现"></a>DAG的实现</h2><p>基于quartz实现时间层面上的调度显然是没有问题的，不过如果job之间有依赖关系的话应该如何实现呢？这个在具体的实施方案上有两种，一种是将作业的dag存放在jobDataMap上，通过构建起始节点并将DAG传入起始节点，并通过JobExecutionContext在作业之间传播DAG即可，如下：</p><h3 id="JobDataMap实现DAG"><a href="#JobDataMap实现DAG" class="headerlink" title="JobDataMap实现DAG"></a>JobDataMap实现DAG</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hw;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 基于jobDataMap 实现作业之间有依赖关系的调度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JobDataMapDAG</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这一步是模拟一个作业转换图，当前是job之间的关系的绑定，还可以使用触发trigger的方式，使用trigger来完成多个作业的触发</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        JobDataMap jobDataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        jobDataMap.put(StartJob<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">TransformJob</span>.<span class="title">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        jobDataMap.put(TransformJob<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">EndJob</span>.<span class="title">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        JobDetail startJob = JobBuilder.newJob(StartJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                .withDescription("this is description")</span><br><span class="line">                .withIdentity(<span class="string">"hello"</span>, <span class="string">"wes"</span>)</span><br><span class="line">                .usingJobData(jobDataMap)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withDescription(<span class="string">"this is trigger"</span>)</span><br><span class="line">                .withIdentity(<span class="string">"trigger"</span>, <span class="string">"wes"</span>)</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.repeatSecondlyForever(<span class="number">20</span>))</span><br><span class="line">                .startNow()</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        scheduler.scheduleJob(startJob, trigger);</span><br><span class="line">        scheduler.start();</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StartJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.print(<span class="string">"start ---------------&gt; "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成start job之后调度到下面一个作业中</span></span><br><span class="line">            String nextJob = jobExecutionContext.getJobDetail().getJobDataMap().getString(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Job)(Class.forName(nextJob).newInstance())).execute(jobExecutionContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"transform ---------------&gt; "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 完成transform job之后调度到下面一个作业中</span></span><br><span class="line">            String nextJob = jobExecutionContext.getJobDetail().getJobDataMap().getString(<span class="keyword">this</span>.getClass().getName());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((Job)(Class.forName(nextJob).newInstance())).execute(jobExecutionContext);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EndJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的最终输出如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Defaulting to no-operation (NOP) logger implementation</span><br><span class="line">SLF4J: See http:<span class="comment">//www.slf4j.org/codes.html#StaticLoggerBinder for further details.</span></span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br><span class="line">start ---------------&gt; transform ---------------&gt; end</span><br></pre></td></tr></table></figure><p>上面这种方式会存在一个问题，那就是一个父节点对应多个子节点的情况下这种方式的调度是串行的的，无法同时执行多个后继节点的作业调度，不过这个问题是可以通过开启多个线程来实现子节点任务的并发执行。一种更好的方式是job执行完之后，触发后继节点的trigger，由trigger对后继节点进行点火操作，这样可以复用框架层面上给我们提供的线程池的能力。另外，如果我们要kill一个作业，是不是也会考虑大量的善后工作呢？既然如此，我们最好还是通过框架层面上给我们提供的工具来实现这种作业的调度为好。这里由于时间关系暂时不深究了，另外，构建DAG也可以使用listener来实现。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>quartz作为业内一款优秀的定时调度框架，应用范围很广，因此阅读一下源码还是很有必要的，上面的构建DAG的例子就真真的是我们工程的一个需求，当时是要实现ETL工具的开发，由于时间关系，这里不再赘述，后面看工作需要有时间再补齐吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>elsatic-job 源码剖析</title>
      <link href="/2019/10/16/elsatic-job-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/10/16/elsatic-job-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>监控项目相关</title>
      <link href="/2019/10/08/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/10/08/%E7%9B%91%E6%8E%A7%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop之spark streaming</title>
      <link href="/2019/10/08/hadoop%E4%B9%8Bspark-streaming/"/>
      <url>/2019/10/08/hadoop%E4%B9%8Bspark-streaming/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡</title>
      <link href="/2019/10/08/%E5%A4%8D%E6%9D%82%E5%9D%87%E8%A1%A1/"/>
      <url>/2019/10/08/%E5%A4%8D%E6%9D%82%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>copycat源码剖析</title>
      <link href="/2019/10/08/copycat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/10/08/copycat%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>分布式一致性分析</title>
      <link href="/2019/10/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/08/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>分布式一致性一直以来是困扰我的一个问题，造成这种困扰的原因主要有：</p><ul><li>分布式一致性和数据库的一致性有什么关系？</li><li>分布式一致性中间这么多的中间状态会对最终的一致性有什么影响？</li></ul><p>关于第一个问题，我想说的是分布式一致性和数据库一致性没有什么关系。这一点最初很难理解，差了很多资料，基本上都说的稀里糊涂的。尤其在看了《分布式原理与实践》之后：开篇就以2pc、3pc为背景来阐述一致性，讲的我云里雾里。直到后来从万能的知乎上找到还算说的过去的讲解：<strong>分布式一致性算法可以认为是分布式共识算法</strong>，也就是说对于一个分布式系统中所有的节点都对某一个状态达成共识。而数据库的一致性则是ACID中的C，这里说的其实是事务的一个特征，我也查阅了相关的数据库资料，对于事务里面一致性的解释并没有一个严格的定义，而是说符合预期。这个可真就是比较宽泛的定义了，<strong>符合预期！</strong> 当然杠精们肯定会有此一杠，系统达到一个一致性的状态也算是符合预期啊或者反之。这个真就是仁者见仁、智者见智了。</p><p>关于第二个问题，是由于在投票的过程中出现的各种网络问题导致的丢包，或者说请求丢失的问题，排列组合起来基数会很大，因此正向推导一致性基本不可行（状态实在是太多了，当然这肯定是一个有限状态机）。不过比较好的方案是反向推导,比如对于2pc的提交操作，具体的流程可以是：事务提交的条件-&gt;所有的参与者都提交，所有的参与者都提交的条件-&gt;所有的参与者在第一阶段都通过了请求。</p><h1 id="分布式一致性协议的演化"><a href="#分布式一致性协议的演化" class="headerlink" title="分布式一致性协议的演化"></a>分布式一致性协议的演化</h1><p>在分布式系统中，每个子系统都能够准确地知道自己的状态，不过却没有办法直接获取其他节点的状态，因此当一个操作需要跨越多台机器的时候，需要一个<strong>协调者</strong>负责收集所有<strong>参与者</strong>的状态，并根据状态来决定参与者下一步的操作，基于此衍生出了两种大名鼎鼎的算法：2pc、3pc。</p><h2 id="2pc"><a href="#2pc" class="headerlink" title="2pc"></a>2pc</h2><p>2pc全称是two phase commit，也就是2阶段提交协议，里面包含了两种角色，协调者、参与者，协调者知道所有参与者的信息。具体如下：</p><h3 id="提交事务请求"><a href="#提交事务请求" class="headerlink" title="提交事务请求"></a>提交事务请求</h3><ul><li>事务询问：协调者首先向参与者发起请求，询问是否可以执行事务操作</li><li>执行事务：各个参与者在收到协调者发过来的请求之后，会将对应的操作记录到undo和redo事务日志中（<del>如果有节点没有响应会如何？</del>）</li><li>参与者向协调者反馈：参与者向协调者反馈是否成功记录了操作的redo和undo日志，如果成功记录了就返回yes，否则返回no（<del>有节点丢失了响应会如何？</del>）</li></ul><h3 id="执行事务提交"><a href="#执行事务提交" class="headerlink" title="执行事务提交"></a>执行事务提交</h3><p>协调者会根据参与者反馈的消息进行判断接下来的操作，具体如下：</p><h4 id="执行事务提交-1"><a href="#执行事务提交-1" class="headerlink" title="执行事务提交"></a>执行事务提交</h4><p>如果协调者从所有参与者收到的响应都是yes的话，那么这个时候会发起请求来提交事务，具体如下：</p><ul><li>发送提交请求：协调者向参与者发起事务提交请求</li><li>事务提交：参与者在收到协调者发来的提交请求之后会提交本机事务，并释放事务资源</li><li>反馈结果：参与者反馈事务提交的结果</li><li>完成事务：协调者收到所有的请求之后，来提交事务</li></ul><p>上面的整个过程是事务提交的过程，不过这里是存在异常情况的，如反馈提交的结果中包含了no的消息，这马上就要转到下面这种方式了。</p><h4 id="中断事务"><a href="#中断事务" class="headerlink" title="中断事务"></a>中断事务</h4><p>如果协调者收到了来自参与者第二阶段no的反馈，或者协调者在等待超时之后还没有收到所有参与者反馈的消息，那么就会中断当前事务的执行，具体如下：</p><ul><li>发送回滚请求：协调者向所有的参与这发送回滚请求</li><li>事务回滚：参与者接收到来自协调者的请求之后会执行undo操作，并释放事务执行期间占用的资源</li><li>反馈事务回滚结果：参与者向协调者反馈事务的执行结果</li><li>中断事务：协调者在收到所有参与者的ack之后，完成事务中断，结束会话。</li></ul><p>上面的过程中存在的异常状态实在是太多太多了，比如在事务处理的过程中，部分节点丢包了结果会如何呢？</p><p>按照前面的思路，我们其实可以倒推：事务什么时候提交呢？所有参与者在第二阶段的响应都已经反馈给协调者yes，如果中间有节点没有反馈的话会怎么样呢？要么事务中断回滚（网络连接没有问题），要么系统处于异常状态，需要人为介入。如果所有的协调者都反馈为yes，那么第一阶段肯定也都是yes了，如果第一阶段有请求丢失了，那么会产生什么影响呢？事务中断或者系统处于异常状态！因此，这样来考虑就不用考虑中间可能出现的各种异常状态了（毕竟中间状态实在太多，无法枚举）。</p><p>二阶段提交的问题也比较明显（参与的角色及数据角度来分析）：</p><ul><li>同步阻塞：参与者之间相互阻塞</li><li>单点故障：协调者单点故障</li><li>脑裂：在第二阶段由于网络问题可能导致部分节点提交的情况</li></ul><h2 id="3pc"><a href="#3pc" class="headerlink" title="3pc"></a>3pc</h2><p>3pc全称是three phase commit，也就是三阶段提交协议，相较于二阶段提交，其主要多了一个超时提交的机制，这个机制就会导致数据出现不一致的情况，具体的分为：</p><h3 id="cancommit"><a href="#cancommit" class="headerlink" title="cancommit"></a>cancommit</h3><ul><li>事务咨询：协调者向所有的参与者发送canCommit请求，询问是否可以执行事务提交操作，等待各个参与者的响应</li><li>各个参与者向协调者反馈事务询问的响应：参与者在收到来自协调者的canCommit请求后，会根据自身是否可以执行事务来决定返回的信息</li></ul><h3 id="precommit"><a href="#precommit" class="headerlink" title="precommit"></a>precommit</h3><p>该阶段协调者会根据参与者的反馈来决定是否可以进行事务的预提交操作，因此该阶段有点类似于二阶段提交的第二个阶段了（不过从过程上来看更多的是二阶段中的第一个阶段）</p><h4 id="执行事务预提交（没有提到超时的情况，不过超时会回滚）"><a href="#执行事务预提交（没有提到超时的情况，不过超时会回滚）" class="headerlink" title="执行事务预提交（没有提到超时的情况，不过超时会回滚）"></a>执行事务预提交（没有提到超时的情况，不过超时会回滚）</h4><ul><li>发送预提交请求：协调者向所有的参与者发送preCommit的请求，此时协调者进入prepare状态</li><li>事务预提交：参与者在收到协调者的请求之后，会执行事务提交，并将undo和redo信息记录到事务日志中</li><li>各参与者向协调者反馈事务执行结果：参与者向协调者反馈事务预提交的执行结果，并进入等待状态</li></ul><h4 id="中断事务-1"><a href="#中断事务-1" class="headerlink" title="中断事务"></a>中断事务</h4><p>上面事务进入预提交的阶段是所有的参与者给协调者的ack中都是成功的情况，如果在canCommit阶段返回的ack有失败的情况，那么就会在preCommit中进入事务中断的执行，具体过程如下：</p><ul><li>发送中断请求：协调者向所有的参与者发送中断请求</li><li>中断事务：收到来自协调者的中断请求之后（或者自身等待超时之后），该事务就会被中断</li></ul><h3 id="docommit"><a href="#docommit" class="headerlink" title="docommit"></a>docommit</h3><p>到了这个阶段，事务会进行真正的提交，具体情况又存在两种：</p><h4 id="执行提交"><a href="#执行提交" class="headerlink" title="执行提交"></a>执行提交</h4><ul><li>发送提交请求：协调者收到来自所有参与者的请求之后，会向所有的参与者发送doCommit请求</li><li>事务提交：参与者在收到协调者的请求之后会提交本地的事务</li><li>反馈事务提交结果：参与者完成事务提交之后，向协调者发送ack的响应</li><li>完成事务：协调者在接收到来自参与者的ack响应之后，即完成事务</li></ul><h4 id="中断事务-2"><a href="#中断事务-2" class="headerlink" title="中断事务"></a>中断事务</h4><ul><li>发送中断请求：协调者向所有的参与者发送abort请求</li><li>事务回滚：参与者接收到abort请求之后，执行事务回滚</li><li>反馈事务回滚的结果： 参与者在完成事务回滚之后，向协调者发送Ack的消息</li><li>中断事务：协调者接收到所有的参与者反馈的消息后，完成事务的中断</li></ul><p>上面的过程也是太多太多了，我们也可以采用倒推（其实是最优解的算法的方式）的方式来缩减状态：事务什么情况下会提交 -&gt; 所有的参与者都收到doCommit请求（如果部分节点超时回滚，就需要人工介入来解决状态的不一致性），什么情况下会收到所有参与者doCommit的请求呢 -&gt; 那就是收到所有的preCommit的请求，如果preCommit请求有部分没有收到呢？这种情况下压根就不会再执行doCommit请求，因此也就意味着事务执行失败。</p><p>通过上面这种分析，我们可以知道3pc解决的是减小冲突域，当然也从一定角度上在preCommit阶段就通过canCommit阶段的响应来快速反馈是否可以提交事务了。简而言之，就是一个字：快！</p><hr><p>对比二阶段提交，我们可以看到三阶段的前两个阶段是对2pc进行了拆分，这个有点类似于降低锁的颗粒度（细化了提交操作的过程），带来的好处自然也是类似的，那就是减小阻塞的颗粒度。</p><p>该过程还存在一个问题，这个问题其实和二阶段是同一个问题，那就是在真正发送提交动作之前（协调者已经准备doCommit提交的操作了），结果参与者之间出现网络分区，有些节点能收到这个doCommit请求，有些没有收到，那么就会导致最终整体出现不一致性。</p><p><strong>另外，超时就应该回滚</strong></p><hr><h2 id="paxos算法"><a href="#paxos算法" class="headerlink" title="paxos算法"></a>paxos算法</h2><p><strong>个人觉得分布式一致性和三阶段提交较为相似，其主要解决的是三阶段里面的controller异常挂死的问题，多个提议者更像是多个controller，如果多个controller同时挂死，那么也是没有办法达成一致性的，另外三阶段是为了实现提交数据的一致性，而分布式一致性主要是为了实现提议者一致性，因此，两者目的并不相同</strong></p><p>在分布式系统中，大名鼎鼎的分布式一致性算法当属paxos了，这是一种基于消息传递并且高度容错的算法，不过在理解这个算法的时候是着实不好理解，每次总是看着后面的又忘记了前面的，这个个人感觉还是因为缺少相应的场景可以适配这种算法，或者说理论的本身是枯燥的。不过，我们还是稍微提一下这个理论，并通过leader的选举来例证这个算法的正确性。这个算法中存在三种角色（每种角色都会存在多个成员）：</p><p>简单的理解，对于分布式一致性的目标应该是我set一个变量到这个集群，一旦集群接受了这个值，那么我再次从该集群get该条数据的时候结果一定是上次提交的结果，不过这里需要注意的是，是从集群get该数据的时候，并不是从集群中的某一个具体实例获取（具体实例获取到的值可能不同）</p><ul><li>决策者：对最终的结果提出决策的角色，回应提议者的proposal</li><li>提议者：发起提议的角色，提议包含了proposal id和对应的value</li><li>群众：学习最终决策的结果</li></ul><p>对应的过程如下：</p><ul><li>阶段一：<ul><li>提议者首先发起(Mn)的proposal，该请求会发送给超过半数的决策者，该请求的类型是prepare，并且该请求并不会携带value，只有议案的编号</li><li>决策者收到了一个(Mn)的prepare请求之后，会承诺不再接收编号小于Mn的proposal了。同时会响应提议者promise类型的响应。生成该响应的规则及内容是：<ul><li>首先会比较该提议编号是不是大于自己响应的所有的prepare提议的编号，如果是则该决策者会返回自己之前同意的（很明显这里的同意的议案不是prepare阶段提供的）编号最大的提议对应的值vx，</li><li>同时该决策者也会拒绝批准任何编号小于等于Mn的prepare请求，也会拒绝编号小于Mn的propose请求（该请求在阶段二，注意prepare和promise的区别）。</li></ul></li></ul></li><li>阶段二：<ul><li>如果提议者收到了来自半数以上的决策者对于其发出的编号为Mn的prepare请求的响应promise之后，那么他会发出一个propose请求，该请求为(Mn, vx)，vx就是收到的编号最大的提议的值，当然如果响应中不包含任何vx（决策者还没有做过决策），那么该value就是随意设定的</li><li>决策者在收到accept类型的(Mn， vx)的请求后，如果该决策者还没有对任何大于Mn的prepare类型的提议做出过决议，决策者就会通过并提交该议案。并将决策的结果返回给提议者</li><li>提议者收到来自决策者的响应之后，会判断是否有过半的决策者提交了该议案，如果是则表示本次提议成功。</li></ul></li></ul><p>个人觉得这和三阶段提交非常相似，但是又略有不同，可以尝试分析一下三阶段主要是基于controller实现提议的发起，这里则是通过提议者发起提议，两者发起提议的第一个阶段都是类似于canCommit的判断，对于三阶段就不必多说了，对于paxos来说，这个阶段是发起一个提议，该提议携带了一个自增且唯一的proposal ID（并未携带value）。另外paxos中的提议者和决策者是可以相互转换的，这意味着客户端的请求打到集群中的那个节点，那个节点则充当了三阶段的controller的角色。由于paxos中的controller节点是集群中的一份子，这也因此保证了一点就是controller是多活的，也因此可以保证服务一直可用。这一阶段的主要目的是对能够提交请求的proposer形成一个决议，通俗的讲就是在集群中选举一个leader用来提交客户端的请求，可以看到，每来一个客户端的请求，就需要执行一遍阶段一，这个本身是可以优化掉的，优化的前提就是在当前的集群中选举出一个恒定的leader，该leader负责客户端请求的发起，如果客户端的请求打到了非leader的节点，该节点会将请求转发到leader节点（leader此时充当了proposer的角色），选出了leader之后，就可以忽略当前这个阶段了，这也是工程中用到的raft、multiple-paxos协议的核心机制了。至于如何在当前用于决策客户端请求的集群中筛选出来leader的角色则可以基于当前的paxos协议来实现了，这个有点像是怎么一条咬住了自己尾巴的大蛇了。</p><p>接下来三阶段和paxos都会根据返回的结果来继续下面的操作了。不过三阶段中提交的value是用户自己设置的，而paxos中的value则是由在提交议案的后返回promise的时候，携带了决策者本身已经接收到的proposal ID最大的value的值。不过二者决策是否进入下一个阶段的时候都是通过半数决议来达成的。接下来paxos则只会有一个阶段就是提交议案（这个时候会携带对应的value），而三阶段则进入precommit的阶段。</p><p>上面的过程中阶段二的最后一个阶段可能会由于决策者在还没有收到propose的情况下，有其他的提议者发起一个Mn+1的请求而导致再次发起prepare请求，这样就会形成活锁。</p><p>raft精简了paxos，因此可以从raft的角度证明一致性协议的正确性。</p><p>另外集群节点动态的变更带来的问题如何解决？？？？？</p><p>上面的过程中我们看到的是提议的生成，其中提到的角色是提议者和决策者，并没有群众这种角色。群众这种类型的角色主要是用来学习议案的，不过话说回来，提议者本身也是群众的角色（毕竟prepare的过程中学到的是前面议案的结果）。</p><p>其实上面的过程已经简化了论证，另外书里面也还有些细节并没有提起，例如：</p><p>很显然上述协议的过程要求提议者提前知道有多少个决策者，不然提议者无法根据返回结果来判断自己的提议是否被大多数的决策者通过（大多数也就意味着，要知道总数）。当因为脑裂或者宕机发生导致集群中部分节点出现问题的时候，整个决策者就可能无法提供后续的服务，这种情况下就需要人工介入来解决这个问题，另外值得一提的是，如果有新的决策者加入了，那么提议者之前所知道的总的数量就会发生变化，而决策者们要将这种变化广播出去，也会存在相应的问题，我怎么才能在广播之后保证我广播之前的决策者的数量没有发生变化呢，呵呵！看来还是无解了，当然这个只是我自己的一些看法，不过，相信不久的将来应该可以找到答案，只是现在我还没有这个方法解释而已。</p><p>另外要强调一下的是分布式一致性实现的是共识算法，也就是对某个事情达成共识，但是一致的结果正确性如何保证并没有提及，不过既然能够保证一致性了，那么在此基础上保证结果的可预测性（或者说正确性）应该就仅仅涉及工程上的实践了。</p><h3 id="leader选举"><a href="#leader选举" class="headerlink" title="leader选举"></a>leader选举</h3><p>后议！另外raft也是一种分布式一致性算法，有时间可以查看并总结一下，另外基于raft而实现的copycat也是不错的源代码，有时间可以看一下</p><p><strong>raft的leader是兼具了paxos的提议者和决策者的角色</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop之zookeeper</title>
      <link href="/2019/10/08/hadoop%E4%B9%8Bzookeeper/"/>
      <url>/2019/10/08/hadoop%E4%B9%8Bzookeeper/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hadoop之kafka</title>
      <link href="/2019/10/08/hadoop%E4%B9%8Bkafka/"/>
      <url>/2019/10/08/hadoop%E4%B9%8Bkafka/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合类之HashMap</title>
      <link href="/2019/10/08/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BHashMap/"/>
      <url>/2019/10/08/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BHashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>世间本没有集合，只有数组、链表，特定场景的需求多了，就逐渐衍生出了集合，java中的集合也确实是比较好的源代码，并且面试的过程中也会比较多的考到这些内容，因此有必要去详细的剖析一下，就先从HashMap说起吧。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>在介绍代码以及操作之前，先来看一下HashMap的结构，这样后面也会有一个比较清晰的认知：</p><p><img src="//southrivers.github.io/2019/10/08/java集合类之HashMap/20201017180734.jpg" alt></p><p>如上图所示HashMap是由一个链表和一个数组构成的，通常来说我们看代码的核心在于源代码，不过HashMap的核心个人以为在于重要的参数，这里我们先来看一下这些参数分别是什么，后面再分别来看一下为什么这些参数的的值设置成这些。</p><ul><li><code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</code>：这个是桶的默认的大小，也就是上图中数组的大小</li><li><code>MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</code>：这个是桶的最大的大小，也就是最多可以是2^30，一般很少能够达到这个体量</li><li><code>DEFAULT_LOAD_FACTOR = 0.75f;</code>：负载因子，该值代表的是HashMap扩容的阈值，该阈值是集合中元素的个数和桶个数的比值，并非是使用的桶的比例（有可能出现hash冲突，多个元素放置到一个桶中）</li><li><code>TREEIFY_THRESHOLD = 8;</code>：这个参数是在JDK8中新引入的，代表了当某一个桶中的元素个数由于哈希冲突达到一定的阈值之后，链表就会树化，不过这并不是充分条件，而是必要条件，树化的另外一个必要条件是桶的大小达到了64以上</li><li><code>UNTREEIFY_THRESHOLD = 6;</code>：由树退化成链表的条件，这里不是7的原因是留一个缓冲区，避免链表和树频繁的转化</li><li><code>MIN_TREEIFY_CAPACITY = 64;</code>：桶中的链表树化的另外一个必要条件</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>提起hashmap，还是先从构造函数说起吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的构造函数中可以看到HashMap的构造函数其实仅仅初始化了两个参数：<code>initialCapacity、loadFactor</code>，这两个参数是HashMap的核心参数，分别代表了初始的容量的大小，以及负载因子的大小，不过上面上面在计算扩容阈值的时候，并不是简单的将构造函数传进来的initialCapacity和loadFactor简单的相乘，而是调用了<code>tableSizeFor(initialCapacity)</code>函数，这里我们也来看一下究竟做了什么处理，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来到这里一眼望过去就是一堆的移位操作，想说一句MMP的，什么鬼玩意儿。概括的来说：这里就是为了取一个不比cap小的最小的2^n幂。至于为什么取成这么一个值，我们可以先不用关心，继续往下看。</p><p>上面的构造函数的过程中我们并没有看到桶的初始化，而仅仅是初始化了一些基本的变量，那么不禁要问一句，桶的初始化是在哪里呢？这里是一种lazy 的机制，只有在使用到HashMap的时候才会真正的创建HashMap所需要的桶，我们就来看一下put操作是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Associates the specified value with the specified key in this map.</span></span><br><span class="line"><span class="comment"> * If the map previously contained a mapping for the key, the old</span></span><br><span class="line"><span class="comment"> * value is replaced.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key key with which the specified value is to be associated</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value value to be associated with the specified key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value associated with &lt;tt&gt;key&lt;/tt&gt;, or</span></span><br><span class="line"><span class="comment"> *         &lt;tt&gt;null&lt;/tt&gt; if there was no mapping for &lt;tt&gt;key&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *         (A &lt;tt&gt;null&lt;/tt&gt; return can also indicate that the map</span></span><br><span class="line"><span class="comment"> *         previously associated &lt;tt&gt;null&lt;/tt&gt; with &lt;tt&gt;key&lt;/tt&gt;.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>在解读集合代码的时候很多人都说要多看注释，起初我是不以为意的，但是随着了解的深入就发现，确实注释是比较有营养的。在put操作上面的注释中我们可以看到HashMap是允许key值为null的，并且允许value为null，因此当我们使用获取某一个值返回为null的时候并不能说明HashMap中没有该key，也有可能是key对应的value为null。</em></p><p>续接上文，桶的初始化是什么样的一个流程，在我们真正的使用put操作取填充HashMap的时候，我们看到首先定义了一坨变量，并进行了响应的判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line"><span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br></pre></td></tr></table></figure><p>这里首先是判断table是否为空或者长度为0，如果是的话，这里首先会使用resize方法初始化tab，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，前面一坨代码是用来确定桶的大小以及阈值并创建空桶的，真正的操作在于下面的循环中，不过当前由于oldTab为null，因此这里会直接返回一个新生成的桶。</p><p>真正的put操作还在上一个代码段的下半部分，首先会进行一个判断<code>(p = tab[i = (n - 1) &amp; hash]) == null</code>，在继续解说之前还必须要讲明白的就是hash值是怎么来的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就到了精髓部分了，我们可以看到当key为null的时候将会得到一个0的hashcode，而key不是null的时候是会将key的hashcode值和其自身无符号右移16为按位异或，这里可能会有人有疑问，为什么要无符号右移16为，直接取hashcode不香么？这个原因在于通常情况下我们的桶的数量都是比较小的，如果我们直接将得到的hashcode与桶的大小进行取模，可能产生的hash冲突会比较大，原因在于hashcode的高位都没有用上，因此这里采用了这种方式将hashcode进行移位操作来充分使用高位的数据，至于这里为什么要使用异或的方式，&amp;或者|可不可以呢？那肯定也是可以的，只不过这种不是一个好的选择，原因在于按位|的方式当hashcode的某一位为1的时候，结果就可以确定了，而当hashcode的某一位为0的时候，按位&amp;的方式结果也确定了，这从一定的程度上缩小了离散的可能性，增大了hash冲突的可能，因此这里才使用了异或的方式来计算hashcode的值。</p><p>续接上文对某一个桶是否为空的判断，当桶中对应的元素为null的时候表示桶还是空的，因此我们可以直接放入数据，当桶中存在数据的时候会对桶中跟节点的类型进行判断，具体分成两种情况，如果是一个TreeNode，我们就调用树的方法存放对应的数据，否则的话就直接通过一个死循环将节点追加到列表中，不过在追加的过程中增加了对是否树化的判断，具体条件就是链表的长度是否达到了8并且桶的大小是否已经达到了64。最后判断桶中容量的大小是否已经扩容的阈值，如果达到扩容的阈值就进行resize，resize代码如上。</p><p>这里我们假定已经达到了阈值需要进行resize，我们可以看一下resize具体执行了什么操作吧</p><ul><li>容量和阈值都通过移位操作扩充为原来的2倍</li><li>通过rehash操作将桶中的链表进行rehash</li></ul><p>阈值以及容量扩充为原来的2倍，这个我们没有疑问，rehash的一个过程是什么样子的呢？核心在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">    lo.....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    hi.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初看到这段代码的时候我其实是一脸疑惑的，后来查阅资料才发现这里其实也是为什么桶的长度设置为2^n的原因原因在于rehash的过程中，很多人第一眼看到<code>e.hash &amp; oldCap</code>可能会和<code>e.hash &amp; (n-1)</code>混淆，不过真实因为&amp;oldCap，所以这里其实是取的<code>e.hash&amp;100000....</code>而不是<code>e.hash&amp;111111....</code>，这里oldCap要多出来一位，因此如果<code>e.hash &amp; oldCap</code>为0的话，则说明e.hash的高1位并没有什么卵用，因此重新rehash的时候依然是落在这个桶里面，而<code>e.hash &amp; oldCap</code>如果不为0的话，hashcode的高位必然是有用的（并且&amp;的结果是oldCap），因此最终的结果必然是将该元素移动到current+oldCap的位置。</p><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><p>上面简要的分析了一下构造函数以及put的整体流程，接下来看一下我们获取元素的方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashmap的get方法如上所示，先来解读一下注释：注释说了，存在两种情况</p><ul><li>一种是返回不是null的情况，这种情况下可能是key为null或者key不为null的情况，不过元素肯定是存在桶中的</li><li>另一种是返回值为null的情况，这种情况下key可能为null并且对应的value存在且为null，或者元素根本就不存在桶中</li></ul><p>区分key到底寸步存在不可以使用get方法进行判断，而只可以使用containKey方法进行判断</p><p>上面的get方法最终会执行到getNode方法中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，整个过程也是比较简单的过程，是直接判断链表中、或者树中的的每一个元素是否满足hash值是否相同并且key相等或者key使用equals方法判断仍然相等，如果是说明我们找到了该元素，否则的话就继续找下去。</p><h2 id="参数取值考究"><a href="#参数取值考究" class="headerlink" title="参数取值考究"></a>参数取值考究</h2><h3 id="红黑树及阈值"><a href="#红黑树及阈值" class="headerlink" title="红黑树及阈值"></a>红黑树及阈值</h3><p>为什么jdk8使用红黑树：红黑树的查询效率为O(log n)，链表的查询效率为O(n)，既然如此为什么不从一开始就考虑使用红黑树来代替链表呢，这是因为红黑树的<strong>一个TreeNode占用的空间为Node的2倍（可以通过查看内部类）</strong>。既然如此，为什么树化的阈值是8呢？因为使用随机的hashcode的情况下，很少会出现桶中元素的个数大于8的情况，如果用于自己实现了并不是优选的hash算法，可能会导致某一个桶中的数据会比较多，使用随机的hashcode的情况下所有的桶中数据的分布会呈现波松分布，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* Because TreeNodes are about twice the size of regular nodes, we</span><br><span class="line">* use them only when bins contain enough nodes to warrant use</span><br><span class="line">* (see TREEIFY_THRESHOLD). And when they become too small (due to</span><br><span class="line">* removal or resizing) they are converted back to plain bins.  In</span><br><span class="line">* usages with well-distributed user hashCodes, tree bins are</span><br><span class="line">* rarely used.  Ideally, under random hashCodes, the frequency of</span><br><span class="line">* nodes in bins follows a Poisson distribution</span><br><span class="line">* (http://en.wikipedia.org/wiki/Poisson_distribution) with a</span><br><span class="line">* parameter of about 0.5 on average for the default resizing</span><br><span class="line">* threshold of 0.75, although with a large variance because of</span><br><span class="line">* resizing granularity. Ignoring variance, the expected</span><br><span class="line">* occurrences of list size k are (exp(-0.5) * pow(0.5, k) /</span><br><span class="line">* factorial(k)). The first values are:</span><br><span class="line">*</span><br><span class="line">* 0:    0.60653066</span><br><span class="line">* 1:    0.30326533</span><br><span class="line">* 2:    0.07581633</span><br><span class="line">* 3:    0.01263606</span><br><span class="line">* 4:    0.00157952</span><br><span class="line">* 5:    0.00015795</span><br><span class="line">* 6:    0.00001316</span><br><span class="line">* 7:    0.00000094</span><br><span class="line">* 8:    0.00000006</span><br><span class="line">* more: less than 1 in ten million</span><br></pre></td></tr></table></figure><p>可以看到一个桶中长度为8的可能性是：<code>0.00000006</code>（这里波松分布是指在桶中存放的元素的个数的概率分布，元素长度概率分布随元素的个数呈现出波松分布），这几乎是不可能的事情，因此树化的阈值选择了8，而由treeNode转化为链表的阈值是6，并不是7，这是增加了一个长度的缓冲区，避免树和链表之间频繁的转化。</p><h3 id="为什么loadfactor是0-75"><a href="#为什么loadfactor是0-75" class="headerlink" title="为什么loadfactor是0.75"></a>为什么loadfactor是0.75</h3><p>hashmap存在负载因子是在时间和空间上做的折中，时间上的折中是如果我们的负载因子为1，那么我们往里面存放数据等于桶的个数的时候才会进行扩容，如果我们的hash算法能尽量保持均衡的话还好一点，否则我们将有可能在某一个桶中存放了一个长的链表，我们知道链表的查询效率为O(n)，降低loadfactor就可以让数据在较少的时候触发rebalance，这样可以减小由于hash碰撞生成的链表过长导致的查询效率降低的问题。而如果loadfactor太低的时候，可能出现的问题是桶的利用率太低，浪费很多空间，至于为什么是0.75而不是0.6或者0.8，这个也只是个经验值，也是经过大量的统计得出的最优质。</p><h3 id="hashmap为什么每次扩充元素，选择为原来的2倍："><a href="#hashmap为什么每次扩充元素，选择为原来的2倍：" class="headerlink" title="hashmap为什么每次扩充元素，选择为原来的2倍："></a>hashmap为什么每次扩充元素，选择为原来的2倍：</h3><p>这个要回归到hashmap确定元素的方法上来：<code>tab=[(n - 1) &amp; hash]</code>，当n为2的n次幂的时候，一个好处就是n-1的低位全部是1，这样就能够hash的低位特征能够被全部保留下来，至于不采用取余的方式，是因为位运算的效率肯定是高于取余运算的，如果我们设定的table不是2的幂，那么会有什么问题呢，其实这个也不会有问题，在上面的构造函数中，我们可以看到有一行代码：<code>this.threshold = tableSizeFor(initialCapacity);</code>，这一行代码就是专门用来将我们非标的容量参数转化为标准的参数的，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一步的操作是将cap-1的低位全部置为1的过程，最后判断n是否小于0或者大于允许的最大容量，来确定最终的容量的大小的过程！</p><h2 id="modCount引发的问题"><a href="#modCount引发的问题" class="headerlink" title="modCount引发的问题"></a>modCount引发的问题</h2><p>在实际的工程实践中，曾经遇到过的问题是在遍历一个map的过程中又改变了map的结构，这里改变结构是指增加或者删除一个元素，结果引发了一个并发改动的异常问题，模拟代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">"aaa"</span>, <span class="number">123</span>);</span><br><span class="line">        put(<span class="string">"bbb"</span>, <span class="number">456</span>);</span><br><span class="line">        put(<span class="string">"ccc"</span>, <span class="number">678</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"aaa"</span>.equals(key)) &#123;</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出异常如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">java.util.ConcurrentModificationException</span><br><span class="line">at java.util.HashMap$HashIterator.nextNode(HashMap.java:<span class="number">1445</span>)</span><br><span class="line">at java.util.HashMap$KeyIterator.next(HashMap.java:<span class="number">1469</span>)</span><br><span class="line">at com.hw.config.BatchConfig.test(BatchConfig.java:<span class="number">21</span>)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:<span class="number">43</span>)</span><br><span class="line">at java.lang.reflect.Method.invoke(Method.java:<span class="number">498</span>)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod$<span class="number">1</span>.runReflectiveCall(FrameworkMethod.java:<span class="number">50</span>)</span><br><span class="line">at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:<span class="number">12</span>)</span><br><span class="line">at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:<span class="number">47</span>)</span><br><span class="line">at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:<span class="number">17</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:<span class="number">325</span>)</span><br><span class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">78</span>)</span><br><span class="line">at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:<span class="number">57</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">3</span>.run(ParentRunner.java:<span class="number">290</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">1</span>.schedule(ParentRunner.java:<span class="number">71</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:<span class="number">288</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.access$<span class="number">000</span>(ParentRunner.java:<span class="number">58</span>)</span><br><span class="line">at org.junit.runners.ParentRunner$<span class="number">2</span>.evaluate(ParentRunner.java:<span class="number">268</span>)</span><br><span class="line">at org.junit.runners.ParentRunner.run(ParentRunner.java:<span class="number">363</span>)</span><br><span class="line">at org.junit.runner.JUnitCore.run(JUnitCore.java:<span class="number">137</span>)</span><br><span class="line">at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:<span class="number">68</span>)</span><br><span class="line">at com.intellij.rt.execution.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:<span class="number">47</span>)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:<span class="number">242</span>)</span><br><span class="line">at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:<span class="number">70</span>)</span><br></pre></td></tr></table></figure><p>通过跟进代码发现是由于一个变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><p>由于HashMap并非是线程安全的类，因此，当有一个线程在访问HashMap的时候，另外一个线程改变了HashMap的结构，这样就可能会引发并发的问题，因此采用了这种fast-fail的方式尽量保证了多线程情况下的程序的正确执行。上面的代码中很明显是一个线程，不过这里很明显缩小了失败条件的范围。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="头插法与尾插法"><a href="#头插法与尾插法" class="headerlink" title="头插法与尾插法"></a>头插法与尾插法</h2><p>resize采用的是尾插的方式，如果是头插的方式会存在并发的问题，参见：<a href="https://blog.csdn.net/littlehaes/article/details/105241194" target="_blank" rel="noopener">头插法死循环问题</a></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面初步对HashMap进行了分析，后面会对比一下HashMap的其他实现类以及其他的集合类的具体实现</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java集合类之List</title>
      <link href="/2019/10/08/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList/"/>
      <url>/2019/10/08/java%E9%9B%86%E5%90%88%E7%B1%BB%E4%B9%8BList/</url>
      
        <content type="html"><![CDATA[<p>底层实现和树的关系</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java中常用的list有LinkedList、ArrayList，他们的区别是底层的数据存储，对于LinkedList而言，底层采用的是链表，而对于ArrayList而言，底层采用的是数组，链表的特点是能够很方便的使用内存碎片，并且加入、删除元素的过程由于仅仅需要改动指针，因此是常量级别的响应时间，而对于数组而言，其底层的存储空间要求是连续的，因此需要分配大量的连续空间，不过因为其内存空间连续的特点，我们可以以常量的访问时间获取元素，不过当我们针对ArrayList中的元素进行增加或者删除的时候，需要移动大量的元素，因此当数据结构有变化的时候其操作的效率是比较低的，而数组的特点则是可以以常量的</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><p>先来看一下LinkedList，其类图如下所示：</p><p><img src="//southrivers.github.io/2019/10/08/java集合类之List/linkedList.png" alt></p><p>我们先来看一下该类上面的注释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Doubly-linked list implementation of the &#123;@code List&#125; and &#123;@code Deque&#125;</span><br><span class="line"> * interfaces.  Implements all optional list operations, and permits all</span><br><span class="line"> * elements (including &#123;@code null&#125;).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;All of the operations perform as could be expected for a doubly-linked</span><br><span class="line"> * list.  Operations that index into the list will traverse the list from</span><br><span class="line"> * the beginning or the end, whichever is closer to the specified index.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;</span><br><span class="line"> * If multiple threads access a linked list concurrently, and at least</span><br><span class="line"> * one of the threads modifies the list structurally, it &lt;i&gt;must&lt;/i&gt; be</span><br><span class="line"> * synchronized externally.  (A structural modification is any operation</span><br><span class="line"> * that adds or deletes one or more elements; merely setting the value of</span><br><span class="line"> * an element is not a structural modification.)  This is typically</span><br><span class="line"> * accomplished by synchronizing on some object that naturally</span><br><span class="line"> * encapsulates the list.</span><br><span class="line"> *</span><br><span class="line"> * If no such object exists, the list should be &quot;wrapped&quot; using the</span><br><span class="line"> * &#123;@link Collections#synchronizedList Collections.synchronizedList&#125;</span><br><span class="line"> * method.  This is best done at creation time, to prevent accidental</span><br><span class="line"> * unsynchronized access to the list:&lt;pre&gt;</span><br><span class="line"> *   List list = Collections.synchronizedList(new LinkedList(...));&lt;/pre&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The iterators returned by this class&apos;s &#123;@code iterator&#125; and</span><br><span class="line"> * &#123;@code listIterator&#125; methods are &lt;i&gt;fail-fast&lt;/i&gt;: if the list is</span><br><span class="line"> * structurally modified at any time after the iterator is created, in</span><br><span class="line"> * any way except through the Iterator&apos;s own &#123;@code remove&#125; or</span><br><span class="line"> * &#123;@code add&#125; methods, the iterator will throw a &#123;@link</span><br><span class="line"> * ConcurrentModificationException&#125;.  Thus, in the face of concurrent</span><br><span class="line"> * modification, the iterator fails quickly and cleanly, rather than</span><br><span class="line"> * risking arbitrary, non-deterministic behavior at an undetermined</span><br><span class="line"> * time in the future.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed</span><br><span class="line"> * as it is, generally speaking, impossible to make any hard guarantees in the</span><br><span class="line"> * presence of unsynchronized concurrent modification.  Fail-fast iterators</span><br><span class="line"> * throw &#123;@code ConcurrentModificationException&#125; on a best-effort basis.</span><br><span class="line"> * Therefore, it would be wrong to write a program that depended on this</span><br><span class="line"> * exception for its correctness:   &lt;i&gt;the fail-fast behavior of iterators</span><br><span class="line"> * should be used only to detect bugs.&lt;/i&gt;</span><br></pre></td></tr></table></figure><p>上面大概意思是说：</p><ul><li>linkedList同时实现了List和Deque接口，并且允许List中的元素为null</li><li>由于实现了一个双端队列的接口，当我们获取List中的某个元素的时候，其真实的操作是会选择性的选择队头或者队尾的元素作为起始节点。</li><li>LinkedList所有的操作都是线程非安全的，因此在存在多个线程并发的访问List的时候，我们需要通过外部的锁对象来保证并发访问的安全性，或者通过Collections.synchronizedList来保障</li><li>提供了fail-fast的机制，当我们的List在对应的iterator创建好之后，如果我们不是通过iterator对应的add或者remove方法改变了数据的话，当我们发现List的结构发生了变化，说明可能是存在其他的线程操作了这个List，这个时候我们会抛出ConcurrentModificationException来终止当前的操作。（如果我创建了iterator不用，我又通过add方法修改数据结构会抛出异常么？同一个线程的情况下。怎么样解决这个问题？）</li></ul><p>java的集合中大量的使用了模版模式，也就是将公共的实现放到抽象类中（如有必要，提供默认的实现），针对不同的特性在子类中提供覆盖的能力。</p><p>来看一下LinkedList类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to first node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (first.prev == null &amp;&amp; first.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Pointer to last node.</span></span><br><span class="line"><span class="comment"> * Invariant: (first == null &amp;&amp; last == null) ||</span></span><br><span class="line"><span class="comment"> *            (last.next == null &amp;&amp; last.item != null)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p>对应的Node的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由Node的定义我们也可以看出LinkedList是一个双向链表。</p><p>查看一下LinkeList继承的AbstractSequentialList的抽象类可以知道，我们的LinkedList只需要实现listIterator和size方法就可以了。我们首先看一下AbstractSequentialList中方法listIterator被用到的地方可以看到如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> listIterator(index).next();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchElementException exc) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(<span class="string">"Index: "</span>+index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也即是当我们尝试获取某个位置的对象的时候就会调用listIterator方法，next方法会返回下一个元素并返回前一个游标（或者说指针），这里不是太清楚下一个元素指代的是哪一个元素，因为按理说下表应该就是从0开始的（TODO）</p><p>续接上文，我们跟进一下在linkedList中listIterator的实现是什么样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ListItr(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一步是针对查询的元素进行的合法性校验，后面会返回一个ListItr对象，该对象实现了ListIterator接口。不过很遗憾上面get方法被LinkedList给重写掉了，重写的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最终会调用如下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中我们可以看到，当我们获取某一个下标的数据的时候，LinkedList首先会判断该下标是离头节点近呢还是离尾节点近，并根据这个条件选择从队头或者是队尾访问元素。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redission分布式锁的二三事</title>
      <link href="/2019/10/08/redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/"/>
      <url>/2019/10/08/redission%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BA%8C%E4%B8%89%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>druid源码剖析</title>
      <link href="/2019/10/08/druid%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/10/08/druid%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>近期服务端偶发几起close_wait问题，搞得人心慌慌，按照之前的经验是由于服务端生成的数据量太大，导致服务端在请求频繁调用之后服务端老年代gc频繁出现的问题，查看代码发现数据库配置的最大连接数是100，而最小的连接数是50，怀着踹踹不安的心情区看了一下日志，发现数据库在连接为50的时候就已经无法创建新的连接了，而后查了一下数据库支持的最大连接数是5000，也就是说物理连接的数量既没有超过后台的限制，也没有超过数据库中的限制，因此怀疑数据库连接没有能够释放，进行了一次druid相关源码的剖析。摘要：关键词：poolingPeak:峰值</p><p>druid是一阿里巴巴开源的一款数据库连接池管理器，利用池化的思想来管理数据库连接，池化的好处如下：</p><p>1、对于创建和销毁代价特别大的资源，池化可以提高资源复用率2、可以通过池子有效的控制池化资源的数量，这样也可以避免较大的开销</p><p>druid号称是为监控而生，既然要做到监控，必然会使用代理：操作的具体行为都是使用代理来完成，在完成的过程中产生监控的数据</p><p>druid按照功能可以划分为一下几点</p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>首先要提到的就是代理，既然要做监控，那么肯定是要制造监控的机会，这里的大量使用了代理的设计模式：使用代理类来完成功能的调用在代理类和实现类中间加入需要监控的事件。对于sql查询，可以监控的对象有：datasource、connection、statement、result，我们可以从一个监控对象入手来分析，就以statement入手来分析：</p><h1 id="数据库连接池管理"><a href="#数据库连接池管理" class="headerlink" title="数据库连接池管理"></a>数据库连接池管理</h1><p>数据库连接池管理的话是基于一个数组来实现的，该对象拥有一个池子（数组），一个用于控制生产和消费线程的锁，以及用于创建和消费连接的线程，其流程图如下：</p><h1 id="过滤器链"><a href="#过滤器链" class="headerlink" title="过滤器链"></a>过滤器链</h1><p>过滤器链是一种设计模式，这种模式将数据的处理抽象到一系列的对象中，并在这些对象中传递事件处理的请求，责任链参与的对象有</p><ul><li>事件请求</li><li>请求处理对象简述一下这种设计模式，如下：</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>druid源码远不止这么些，以上是我自己比较关心的业务的部分，感谢druid的作者温少，让我们可以有膜拜的机会</p><p>附：里面大量用到了holder这种命名的规范，这种命名的化可以推测出来其作用：某种资源的持有者</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>一次jvm内存溢出的分析</title>
      <link href="/2019/10/08/%E4%B8%80%E6%AC%A1jvm%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/10/08/%E4%B8%80%E6%AC%A1jvm%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>redis那些事</title>
      <link href="/2019/10/08/redis-%E7%BC%93%E5%AD%98/"/>
      <url>/2019/10/08/redis-%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工作的过程中有使用过redis作为热点数据的缓存，刚接触的时候还热火朝天的学了一把基本的数据类型和操作，不过并没有深入的了解过这个东西，刚好趁闲下来的时间好好地学习一下。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>为了方便初始化环境，采用了一种比较方便的安装方式docker安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull redis</span><br><span class="line">docker run --name myredis -d -p 6379:6379 redis</span><br><span class="line">docker exec -it myredis redis-cli</span><br></pre></td></tr></table></figure><h2 id="上帝视角"><a href="#上帝视角" class="headerlink" title="上帝视角"></a>上帝视角</h2><p>redis对外呈现的数据结构是包括<code>string、list、hash、set、zset</code>，不过这些种类的对象都源自于同一个结构体：redisObject，对应结构体的定义如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:4;        </span><br><span class="line">    unsigned encoding:4;    </span><br><span class="line">    unsigned lru:LRU_BITS;  </span><br><span class="line">    int refcount;　　　　　　 </span><br><span class="line">    void *ptr;              </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li>type：记录了对象对外呈现的类型，分别是string、hash、list、set、zset</li><li>encoding：用于记录该类型的对象底层采用的数据结构</li><li>lru：记录对象最后一次被访问的时间</li><li>refcount：表示当前对象引用计数的大小，当值为0的时候将会被回收</li><li>ptr：指向实际数据的指针</li></ul><p>redisObject的存在更多的像是一个门面，可以提供一些通用的函数，并没有特殊的含义或者目的</p><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p>redis是key-value类型的数据库，redis的key是string，对应的value则由以下几种基本数据类型组成：</p><ul><li>string：string的底层实现方式redisObject中的encoding包括了int、raw、embstr，其中每种具体的实现都是针对内存空间的占用和内存分配成本的管控，具体如下：<img src="//southrivers.github.io/2019/10/08/redis-缓存/string.png" alt>这里需要注意的是出现了一种新的数据结构SDS（简单动态字符串），对应的定义如下(<em>还有flag标记位，不重要，未给出</em>)：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line">    //  记录已使用长度</span><br><span class="line">    int len;</span><br><span class="line">    // 记录空闲未使用的长度</span><br><span class="line">    int free;</span><br><span class="line">    // 字符数组</span><br><span class="line">    char[] buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>可以看到底层采用的是字符数组的方式来存放数据，而字符数组采用预分配的机制，也即是空间不够用的时候会对数组长度进行扩展，<strong>预分配的好处是减少了内存空间的分配次数</strong>，这在一定程度上可以提升内存的使用效率。另外上面的结构体中我们可以看到其中记录了已使用的长度，这样就使得<strong>获取字符串长度的时候时间复杂度是O(1)</strong>。</p><ul><li>set：redis的底层采用了intset和hashtable两种数据结构存储，intset可以理解为数组，hashtable就是普通的哈希表，只不过对应的value为null，只有在集合中的元素都是整数值并且集合中元素的数量不超过512个的时候才会采用intset</li><li>zset：zset在集合数量小于128个并且所有成员的长度小于64字节的时候直接使用zipList进行存储，其中节点中的第一个元素保存数据，第二个保存score，这样依次按照score从小到大进行存储，其查找复杂度也为<code>O(n)</code>，而当上述条件不满足的时候则直接使用skipList编码来进行存储，对应的结构体如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct zset &#123;</span><br><span class="line"></span><br><span class="line">    // 字典，键为成员，值为分值</span><br><span class="line">    // 用于支持 O(1) 复杂度的按成员取分值操作</span><br><span class="line">    dict *dict;</span><br><span class="line"></span><br><span class="line">    // 跳跃表，按分值排序成员</span><br><span class="line">    // 用于支持平均复杂度为 O(log N) 的按分值定位成员操作</span><br><span class="line">    // 以及范围操作</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure></li></ul><p>如上，其对应的dict字段指向一个字典，字典的key为member，value为该member对应的score，zskiplist则是跳表，用于支持<code>O(log N)</code>的查找操作。相较于平衡树，跳表并不要求太严格的平衡操作，实现上更为粗糙，不过查询效率却能够大大的提高</p><ul><li>list：list底层采用的数据结构为quickList+zipList，它会在长度为空的时候自动删除，具体如下图所示：<img src="//southrivers.github.io/2019/10/08/redis-缓存/list.png" alt>其基本的组成是quickList，其中保存了head和tail指针，这也保证了lpush、rpop操作的时间复杂度是O(1)，quickList中的每一个元素由一个quickListNode组成，其中除了指向前后节点的指针外，还包含了指向zipList的指针，zipList是list中的数据真正存储的地方。采用zipList而不是LinkedList的主要原因是因为LinkedList中的每个节点都包含了两个指针，这会造成极大的内存开销，而这些开销本身都是没有用的。因此底层采用了zipList这种压缩的数据结构（连续的内存空间分配）有效的减少了内存空间的浪费。zipList在存储的元素或者其内存空间达到一定程度之后会逆行裂变的操作。</li><li>hash：redis使用字典作为其底层实现（长度、数量小于一定值的时候采用的是zipList来优化内存使用，过大则直接使用hashtable），一个字典中可以包含多个哈希表节点，而每一个哈希表节点中保存了字典中的一个键值对，对应内存分布如下所示：<img src="//southrivers.github.io/2019/10/08/redis-缓存/hash.png" alt>如上图所示会涉及以下几种数据结构：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict &#123;</span><br><span class="line">    dictType *type;    //类型特定函数</span><br><span class="line">    void *privdata;    //私有数据</span><br><span class="line">    dictht ht[2];    //2个哈希表，哈希表负载过高进行rehash的时候才会用到第2个哈希表</span><br><span class="line">    int rehashidx;    //rehash目前进度，当哈希表进行rehash的时候用到，其他情况下为-1</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure></li></ul><p>其中的type字段为指针类型，其定义了针对特定类型的函数，这里的指针很像是java中的接口一样，通过虚化实现提供了多台的能力。ht为一个数组，通常情况下我们只会使用<code>ht[0]</code>，只有在hash负载过高进行rehash的时候才会使用<code>ht[1]</code>,rehashidx则表示了在rehash的过程中的进度，默认为-1（没有进行rehash操作）。哈希表指向的字段为<code>dictht</code>其具体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictht &#123;</span><br><span class="line">    dictEntry **table;    //哈希表数组</span><br><span class="line">    unsigned long size;    //哈希表大小，即哈希表数组大小</span><br><span class="line">    unsigned long sizemask; //哈希表大小掩码，总是等于size-1，主要用于计算索引</span><br><span class="line">    unsigned long used;    //已使用节点数，即已使用键值对数</span><br><span class="line">&#125;dictht;</span><br></pre></td></tr></table></figure><p>在上述的结构中主要是table指针，该指针指向一个数组，数组的每一个元素又是一个指针，指向了dictEntry结构，对应定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry &#123;</span><br><span class="line">    void *key;</span><br><span class="line">    union &#123;</span><br><span class="line">        void *val;</span><br><span class="line">        uint64_t u64;    //uint64_t整数</span><br><span class="line">        int64_t s64;    //int64_t整数</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;    //指向下个哈希表节点</span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p>上述结构体中需要注意的next指针是用来解决hash冲突的问题。redis采用了渐进式rehash的方式来避免在hash表扩容的时候阻塞时间太久而造成的不可用，具体过程如下：    - 为<code>ht[1]</code>分配空间，让字典同时持有<code>ht[0]</code>、<code>ht[1]</code>两个哈希表    - 将字典中的rehashidx置位为0，标识rehash的正式开始    - 在rehash进行的期间，每次对字典执行添加、删除、查找或者更新操作的时候，程序除了执行指定的操作之外还会将<code>ht[0]</code>中对应的rehashidx下标所标识的数据移过去    - 重复上述操作直到将哈希表中所有的键值对移过去</p><p>在渐进式rehash的过程中需要注意的是增加只会在新的哈希表中执行，而删除、修改、查询则会在两个哈希表中进行</p><h2 id="redis集群模式"><a href="#redis集群模式" class="headerlink" title="redis集群模式"></a>redis集群模式</h2><p>redis集群模式大概可以分为三种类型：</p><ul><li>主从：这种模式包含了master和slave两种角色，其中祝数据库提供读写操作，并将写操作导致的数据变化自动同步给从数据库，在从数据库进行同步的时候包含了两种同步的方式：<ul><li>增量同步：这种方式同步的是指令流，主节点会将对自己的状态产生修改性影响的指令记录在内存的buffer中，然后异步的将指令同步到从节点，既然是异步，必然以带来问题，当祝节点进程突然挂掉之后，就会导致数据的丢失</li><li>快照同步：这种同步方式首先需要在祝节点上执行bgsave，将内存中的数据全部写到磁盘中，然后将内容全部传递到从节点，从节点清空内存，并加载快照，不过在快照同步的过程中可能会有新的指令过来，这部分指令则采用增量同步的方式完成，值得一提的是由于redis是单线程，因此在同步数据到磁盘的时候其实是通过fork出一个子进程来完成数据落地操作的。</li></ul></li><li>哨兵：上述主从方式解决了高可用的问题，不过需要人工介入来完成主备的切换，哨兵模式实现了类似故障自愈的能力，在主节点不可用的时候，哨兵进程会通过投票的机制将原来的主节点移除，并选出新的主节点，而客户端进程在链接集群的时候，会首先链接到哨兵，由哨兵告诉客户端祝节点的地址，并在主节点出现问题的时候将这种变化知会到客户端</li><li>cluster模式：在上述两种模式中都解决了数据库高可用的问题，不过很遗憾的是不管是主从还是哨兵其本质都无法将数据分片，来切分到不同的服务器上面，这也带来了一个问题，当数据量、请求访问量足够大的时候，单机就会出现性能瓶颈。redis集群模式的数据分片采用的是数据分片的方式，一个redis集群包含了16384个槽位，数据库中的每一个键都属于这些槽位中的一个，同时每个槽位也对应了一个节点，如下演示了一个包含了三个主节点redis集群：<img src="//southrivers.github.io/2019/10/08/redis-缓存/slot.png" alt>redis集群的客户端在连接到集群中的一个节点的时候会获取这种映射关系，这种关系将会在收到重定向响应（slot发生了迁移导致对应的key发生了迁移）的时候进行更新，如上图所示，集群模式下的redis更多的是像多套主从集群组成的联邦，只不过slave只会从master同步数据并不会占用槽位。并且集群模式下，所有的主节点承担了客户端所有的读写操作，而对于slave节点仅仅是做了高可用的保障机制。另外值得一提的是redis集群采用的是流言协议，这可能会在一定的程度上造成数据的缺失。</li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><p>如果说redis中最常用的操作，应该就是获取对应的value这种操作了，大多数的redis客户端都提供了<code>keys、scan</code>这两种模式，对于keys这种操作会一次性将所有的数据查出来，当key的个数过多的时候会导致服务端处于阻塞的状态，因此该命令是严禁用于生产环境中的，而scan操作则是采用游标的方式迭代返回所有的数据，我们可以设置批量查询的数据量，不过基于scan的操作在对应的value结构发生改变的时候可能会导致数据重复查询，因此使用的时候需要注意去重的操作，至于为什么会导致数据重复被查询，有兴趣的可以自行查阅文档。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>TODO</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>redis采用了epoll的模型避免了服务端阻塞的性能问题，并且所有的操作都是基于内存的，因此即便是单线程也依然是非常快的，另外单线程带来的好处是避免了线程切换和竞态产生的消耗</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库-索引</title>
      <link href="/2019/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/"/>
      <url>/2019/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库-事务</title>
      <link href="/2019/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/"/>
      <url>/2019/10/08/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>搞后台开发，如果说对数据库不熟悉，那基本上就是死穴，由于专业限制，本人对数据库这一块一直心有余悸，每次看到存储引擎、事务等相关的知识的时候总是前怕狼后怕虎，所以专门抽出一点时间整理以下数据库事务相关的东西。另外多说一句，数据库相关的知识应该主要就是</p><ul><li>事务</li><li>索引</li><li>锁</li></ul><p>这三大块吧，本文只针对数据库事务做相关的整理，后面会有专门的文章整理其他的特性。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>数据库事务是一组操作数据的指令的集合，这种操作可以是读取，也可以是更新。事务具备以下特性：</p><ul><li>原子性：事务所包含的指令集要么全部执行，要么全部不执行</li><li>一致性：一致性没有一个严格的数学定义，松散一点的说，就是能够按照用户的预期来执行（这里需要多说以下，数据库的一致性和分布式一致性所说的一致性是不同的，之前看raft或者poxas的时候，经常会搞混淆，分布式一致性可以叫成分布式共识更好一点，不同的节点看到的状态是一致的，不会有节点看起来是A，另外一些节点看起来是B状态！）</li><li><strong>隔离性</strong>：隔离是事务之间相互之间不干扰，从一个事务的视角来看，其他的事务要么在当前这个事务之前已经完成，要么在当前这个事务已经完成之后才开始，这样每个事务都感觉不到其他事务的存在</li><li>持久性：事务一旦完成之后，他对数据库的影响是永久性的，即便系统出现故障</li></ul><p>接下来重点说一下<strong>事务隔离级别</strong>及其所带来的问题：</p><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><p>隔离界别分为以下几种</p><h2 id="读未提交（read-uncommitted）"><a href="#读未提交（read-uncommitted）" class="headerlink" title="读未提交（read uncommitted）"></a>读未提交（read uncommitted）</h2><p>允许事务T1读取事务T2中没有提交的数据，如果T2执行失败，发生了回滚，那么T1就读取到了错误的数据，对应到具体的问题就是数据的脏读</p><h2 id="读已提交-read-committed"><a href="#读已提交-read-committed" class="headerlink" title="读已提交 (read committed)"></a>读已提交 (read committed)</h2><p>事务T1读取到了事务T2中已经提交的数据，这样会带来的问题是：如果T1连续两次读取到某一条数据，那这两次读取到的结果不一致，会引发的问题就是不可重复读</p><h2 id="可重复读-repeatable-read"><a href="#可重复读-repeatable-read" class="headerlink" title="可重复读 (repeatable read)"></a>可重复读 (repeatable read)</h2><p>事务T1在连续读取某一条记录的间隙不存在另外一个事务T2对该记录的修改（mysql innodb默认的事务隔离级别），无法解决幻读的问题</p><h2 id="序列化-serializable"><a href="#序列化-serializable" class="headerlink" title="序列化 (serializable)"></a>序列化 (serializable)</h2><p>完全串行化，每个事务都会获取表级锁，可以解决所有的问题，带来的问题是事务吞吐量的降低、cpu利用率低下以及较高的响应时延</p><h1 id="隔离级别引发的问题"><a href="#隔离级别引发的问题" class="headerlink" title="隔离级别引发的问题"></a>隔离级别引发的问题</h1><p>接下来我们会通过mysql演示数据库事务隔离级别所带来的问题，mysql事务隔离级别查看及修改方式（我当前安装的是mysql8.0）：查看数据库事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select @@transaction_isolation;</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| @@transaction_isolation |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">| REPEATABLE-READ         |</span><br><span class="line">+<span class="comment">-------------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>修改当前会话的事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">SESSION</span> | <span class="keyword">GLOBAL</span>] <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> &#123;<span class="keyword">READ</span> UNCOMMITTED | <span class="keyword">READ</span> COMMITTED | REPEATABLE <span class="keyword">READ</span> | <span class="keyword">SERIALIZABLE</span></span><br></pre></td></tr></table></figure><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>一个事务T1访问到了另外一个事务T2修改了、但是没有提交的数据<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E8%84%8F%E8%AF%BB.png" alt></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>一个事务T1多次读取某一个数据，在两次读取数据之间，另外一个事务T2对数据进行了修改并提交，导致T1连续两次读取到的数据发生了变化，对比脏读，不可重复读取到的是另一个事务已经提交的数据，而脏读读取到的是另一个事务没有提交的数据<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4.png" alt></p><h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>mysql innodb默认的事务隔离界别就是可重复读，这个我们可以测试一下：<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt>上面我们在左边开启一个事务，然后插入一条数据，在右边区查看表中的记录，在左边的事务没有提交的情况下，可以看到右边查到的数据为空，直到左边的事务commit之后，右边的查询才可以读取到<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-commit.png" alt>接下来我们模拟在一个事务连续两次读某个记录操作的过程中，另外一个事务来修改该记录，如下：<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-1.png" alt>我们可以看到，左右两边同时开启一个事务之后，右边在update一条记录（未commit）的情况下，左边查看到的结果仍然是旧的数据，接下来我们将右边的事务commit之后，再查看左边的查询是否是可重复读的，如下<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BBcommit.png" alt>经过上面的测试流程我们可以清楚的看到在可重复读的隔离级别中，一个事务的多次读操作不会受到另外一个事务写的影响，最后我们来测试一下两个事务同时更新某一条记录的情况：<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-update.png" alt>这种情况下我们发现其中的一个更新事务会被阻塞直至超时。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读也可以称之为虚读，事务T1批量修改表中的数据，在T1还没有提交之前事务T2新增了一行T1需要修改的数据并提交，T1在提交的时候发现了一行本来应该修改，但是没有修改的数据。<img src="//southrivers.github.io/2019/10/08/数据库-事务/%E5%B9%BB%E8%AF%BB.png" alt>对比脏读，幻读和不可重复读都是读取了另外一条提交了的事务的数据，幻读强调的是一批数据的修改，不可重复读强调的是一条数据的修改</p><h1 id="数据库的一致性"><a href="#数据库的一致性" class="headerlink" title="数据库的一致性"></a>数据库的一致性</h1><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节主要介绍了数据库事务相关的知识，需要明确的是事务的隔离级别越高，性能就越差，另外实现事务隔离的机制通常是采用加锁的方式，这将会在后续的文章中持续跟进。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>netty学习</title>
      <link href="/2019/10/08/netty%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/08/netty%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/2019/10/08/NIO/"/>
      <url>/2019/10/08/NIO/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>相信很多java开发工程师都有经历过NIO面试的吊打，这里需要澄清一下，我们<strong>IO其实跟java的关系其实不大</strong>的！可能很多做java开发的人都都会一头雾水，怎么就没关系了呢？没错，真的没有关系，IO永远是针对操作系统而言的，并且通常情况下我们其实更关注的是NI，当然并不是NO不重要，只是我们日常开发的过程中很少会有NO的瓶颈，毕竟数据掌握在我们自己手中，但是对于输入流就不一样了，尤其是网络上的输入流。</p><h1 id="IO介绍"><a href="#IO介绍" class="headerlink" title="IO介绍"></a>IO介绍</h1><h2 id="内存空间"><a href="#内存空间" class="headerlink" title="内存空间"></a>内存空间</h2><p>在真正的开始介绍IO的相关概念之前，我觉得有必要介绍一下操作系统的内存空间的划分：操作系统会将内存空间划分为用户空间和内核空间，内核空间是操作系统运行的内存空间，而用户空间是用户进程运行的内存空间。之所以对内存空间进行划分是为了安全，将用户的进程空间隔离在操作系统的进程空间之外，这样的话即便是用户进程的非法操作也可以在操作系统层面上做统一的控制。从而保证操作系统的正常运行。</p><p>在读写文件的时候用户进程会通过系统调用由用户态切换为内核态，当文件准备就绪之后又会由内核态切换为用户态，而用户态和内核态之间的切换需要保存现场，相关的系统开销是比较大的。</p><h2 id="IO过程"><a href="#IO过程" class="headerlink" title="IO过程"></a>IO过程</h2><p>IO是外部设备和计算机之间的一种交互，整个交互的过程分成两步：</p><ul><li>发起IO操作：用户线程（或者进程）通过系统调用向内核发起读取数据的请求，由于数据可能不存在内存中，这时候发起系统调用的线程会进入等待（当然也可以不等待）</li><li>实际IO操作：数据从磁盘上读取到内核空间之后（或者网络上的分组数据到齐之后），由用户线程或者进程将内核空间中的数据拷贝到用户空间的过程（当然也可以是内核线程主动将数据拷贝到用户空间）</li></ul><p><strong>第一个过程</strong>涉及的阻塞操作（等待与否）就是我们常说的IO中的<strong>阻塞或者非阻塞</strong>，第二个过程涉及的阻塞操作（主动拷贝数据与否）我们称之为同步或者异步</p><h2 id="IO模型划分"><a href="#IO模型划分" class="headerlink" title="IO模型划分"></a>IO模型划分</h2><p>linux的IO大致可以划分成如下几种：</p><ul><li>同步阻塞IO</li><li>同步非阻塞IO</li><li>多路复用IO</li><li>异步IO</li></ul><p>我们分别来看一下：</p><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p><img src="//southrivers.github.io/2019/10/08/NIO/BIO.png" alt></p><p>如上，用户进程或者线程发起recvfrom系统调用来读数据的时候，这个时候不管我们要读取的是网络数据还是磁盘数据，都会出现如下的处理过程：</p><ul><li>用户进程或者线程进入等待：网络数据需要等待足够的分组到来，本地磁盘会通过<strong>缺页异常中断</strong>将文件从磁盘加载到指定的内核内存空间，数据未准备好的情况下将会用户进程或者线程将会一直阻塞直到数据准备好，阻塞的过程中用户的线程或者进程做不了其他的事情</li><li>数据拷贝：数据准备好之后由用户线程将内核空间的数据拷贝到用户空间</li></ul><p>上面两个步骤中第一步我们称之为阻塞，第二步我们称之为同步，因此合起来就叫做同步阻塞IO。</p><p>上面这种问题可以通过服务端配置多线程的方式来进行优化，更进一步，我们可以指定线程池来进行优化，这样可以控制服务端能同时处理的连接的个数。</p><h3 id="同步非阻塞IO（NIO）"><a href="#同步非阻塞IO（NIO）" class="headerlink" title="同步非阻塞IO（NIO）"></a>同步非阻塞IO（NIO）</h3><p>上面的处理流程中很明显存在一个问题，那就是当数据不存在的时候用户的进程或者线程将会一直阻塞，也就没办法处理其他业务了，假定线程资源被连接耗尽了，而连接又没有真正的数据发送到服务端，那么服务端就处于僵死的状态了，因此通常情况下可以设置服务端为非阻塞的状态，对应的系统调用图如下：<img src="//southrivers.github.io/2019/10/08/NIO/NIO.png" alt>当设置了非阻塞的时候，我们通过系统调用read操作来读取数据的时候，如果没有数据会立即返回一个错误，由于此时进程或者线程已经又从内核态转变成用户态，因此用户的线程不会阻塞，而接下来的过程中我们就可以继续处理我们自己的业务了（这里的业务不再是从上面对应的socket接收数据了），例如打印个hello world，然后我们在接下来的一轮循环中再次从socket中读取数据（<strong>这里的socket需要记录并保存，否则我们将无法再使用这些socket</strong>）。</p><p>当我们在循环的过程中发现有socket数据准备好之后，用户进程或者线程就可以同步去拷贝数据了。这里我们看到了循环的过程，其实是用户态的多路复用，只不过这个多路复用和真正的多路复用还不太一样，真正的多路复用是阻塞的，也就是说当复用器（并没有所谓的复用器，这里其实是用户进程或者线程）监听的多路socket都没有数据的时候其实是会阻塞的，因此是需要单独的一个线程完成多路数据的监听的，防止阻塞主线程，NIO（用户态的多路复用）更多的像是是一个忙等待并非像多路复用那样是一个阻塞的过程。如下，我们用java代码演示一下：</p><p>服务端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;SocketChannel&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// TODO 当前是主线程负责所有数据的处理，其实可以更优雅一点，新建一个线程用于处理所有数据，不过这么做也没有他大问题</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 客户端简历连接之后会生成一个新的socket用于接收数据</span></span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != socketChannel) &#123;</span><br><span class="line">                list.add(socketChannel);</span><br><span class="line">                <span class="keyword">for</span> (SocketChannel l : list) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        l.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (SocketChannel l : list) &#123;</span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (l.read(buffer) != -<span class="number">1</span>) &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            System.out.println(<span class="string">"++++++++++++++++++++"</span>);</span><br><span class="line">                            System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        l.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String res = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">null</span> != (res = scanner.nextLine())) &#123;</span><br><span class="line">            buffer.put(res.getBytes());</span><br><span class="line">            <span class="comment">// 这里的buffer的用法不对，不过仅仅用于调测，问题不大，只要两次输入的字符串的长度一致即可</span></span><br><span class="line">            buffer.flip();</span><br><span class="line">            socketChannel.write(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">        &#125;</span><br><span class="line">        socketChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，关于客户端的代码没有什么好说的，服务端的代码就有讲究了，我们在创建了一个serverSocketChannel后，特意设置其为非阻塞。需要注意的是这里的阻塞不仅包括IO的阻塞，<strong>也包括accept的阻塞</strong>，当设置为非阻塞的时候accept在调用的时候如果没有客户端链接过来，那么会直接返回一个null，而如果我们设置为阻塞，则在accept的时候如果没有连接到来，那么用户线程或者进程会一直阻塞住直到有连接过来。</p><p>另外我们还看到了在serversocket监听到用户的请求过来的并生成对应的socket的时候，我们将其保存在一个list中，这种情况下其实就是模拟的多路复用IO中的<strong>多路</strong>，如果我们不保存多路的话，那么我们怎么样<strong>复用一个线程</strong>来轮训呢？毕竟，我们需要知道这么多新建的socket对应的fd。再进一步可以想像一下，我们新建了一个连接到服务端，此时如果不保存该链接对应的socket，那么过了十分钟后，客户端向服务端发送了一条消息，我们却找不到对应的socket了，那么数据又怎么获取到呢？</p><h3 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h3><p>多路复用IO顾名思义，多个IO由同一个监听器完成监视（多个IO由复用同一个监视器），具体可以分成以下三种模型：</p><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>系统调用函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int select(int maxfdp, fd_set *readfds, fd_set *writefds, fd_set *errorfds, struct timeval *timeout);</span><br></pre></td></tr></table></figure><p>查看该系统调用的说明如下：</p><p><img src="//southrivers.github.io/2019/10/08/NIO/select.png" alt></p><p>上面主要的结构体是fd_set，该set是一个位图代表的集合，我们使用该位图来表征文件描述符（具体点就是文件描述符为x则将位图的x位进行置位），具体定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    long fds_bits[1024 / 64];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure><p>上面使用long类型的数据来作为位图的基本单元，每一个long类型的数据都是由64个bit组成，因此我们使用 1024/64个long类型的数据就可以指代一个1024位的集合了。接下来我们如果我们想要监听文件描述符为x（x&lt;1024）的读事件，只需要将readfds对应的第x位进行置位即可，同理写事件、错误事件只需要将writefds、errorfds对应的位进行置位就可以了。</p><p>select有一个明显的缺点，那就是fd_set太小，虽然可以更改，不过大小都是通过宏引入的，因此会存在限制。另外这么多的文件描述符需要从用户空间和内核空间来回进行拷贝，因此也会有一定的开销，再者，这么多的文件描述符都需要内核进行全遍历（不论该fd对应的socket是否有数据到来），因此也会有一定的开销，不过相较于NIO中使用list来保存并遍历socket，select是通过内核来进行遍历所有的fd（NIO是用户主动遍历所有的socket，有点类似于批量插入的时候在用户的循环中插入数据，肯定是内核这种提交一个集合的方式插入效率要高一点），毕竟用户线程或者进程主动遍历的会带来多次的系统调用开销。</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll系统调用也可以用于执行多路复用IO，对应的函数原型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;poll.h&gt;</span><br><span class="line">int poll(struct pollfd* fds, unsigned int nfds, int timeout);</span><br></pre></td></tr></table></figure><p>上面的函数使用到一个结构体pollfd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct pollfd &#123;</span><br><span class="line">    int fd;         // 文件描述符</span><br><span class="line">    short events;   // 等待的事件</span><br><span class="line">    short revents;  // 实际发生了的事件</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对应的参数的含义分别如下：</p><ul><li><strong>fds为文件描述符相关的结构体对应的数组的头指针</strong></li><li>nfds用来描述数组的长度，毕竟数组是有序的，<strong>只要确定了头指针，就可以通过下表来确定范围</strong></li><li>timeout用来指定接口调用的超时时间</li></ul><p>这里其实和select并没有太多的不同，只是这里使用了一个指针指向文件描述符的数组，因此调用的时候文件描述符不再拘于长度了，其他的过程也还是一样的。不过其在遍历的时候仍然需要把所有的文件描述符都给遍历，而不论是否真的有数据。这样一旦文件描述符过多，同样会使用户进程陷于内核态无法自拔。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>上面两种类型的多路复用都面临两个问题：</p><ul><li>文件描述符在用户空间和内核空间大量copy</li><li>大量没有数据的socket不停的被轮循是否有数据到来</li></ul><p>这无形中加大了系统的开销，epoll是上面两种模型的一种增强，<strong>其本质是创建一个文件，将其他的socket对应的fd所关心的事件注册进来</strong>，因此该文件相当于一个事件表，接收其他的socket的事件的到来，这个时候如果我们想要查看有哪些socket出现了我们期待的事件，只需要在用户空间和内核空间中<strong>传递一个文件描述符</strong>就可以了，另外我们在拿到新生成的文件描述符后就可以查询文件描述符对应的文件内容，从而将真正有数据的socket给取出来，而且不会因为有大量的socket而导致系统调用文件描述符拷贝带来的开销，也不会全遍历文件描述符对应的socket，因此效率可以说是最高的。</p><p>epoll具体的调用流程如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int epoll_create(int size);</span><br><span class="line">int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure><p>上面的第一个函数<code>epoll_create</code>就是用来创建一个文件，该文件就是一个事件表，接下来epoll_ctl会将第一步创建得到的文件描述符epfd作为参数传进来，并将我们关心的文件fd的事件epoll_event注册进来，当对应的fd有事件epoll_event到来的时候会通过系统的回调函数将其写到epfd对应的文件中。最后异步epoll_wait则有点类似于select的作用，不过区别于select，这里选出来的socket是有数据的socket并非全量的socket。</p><p>在上面多路复用的几个系统调用函数中我们都看到了timeout这个参数，代表的是该系统调用的超时时间，0表示立即返回，这种情况下有点类似于accept的非阻塞，-1表示永久阻塞，这有点类似于accpet的阻塞，为正则代表设定阻塞的超时时间。</p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p>比较少见，暂不研究</p><h2 id="JAVA-NIO"><a href="#JAVA-NIO" class="headerlink" title="JAVA NIO"></a>JAVA NIO</h2><p>上面介绍了一些理论性的东西，接下来看一下java中NIO相关的组成部分，java中的NIO涉及了<strong>磁盘文件和网络文件相关的类库，这里做特殊声明</strong></p><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><p>buffer看名字也可以直到是缓冲区，buffer出现的原因是优化了stream（流）的吞吐量限制，通常情况下我们在读写文件的时候用到的比较多的其实是stream，这里就不细说了，buffer的本质是一个数组的包装类，也就是说我们进行数据读写的时候操作的是buffer中的数组，只不过buffer提供了更强大的API。buffer涉及了几个比较核心并且晦涩的成员变量：</p><ul><li>position：第一个可以读写的位置</li><li>limit：第一个不可以读写的位置</li><li>capacity：buffer的容量</li><li>mark：缓存position的位置用于重复读、写的操作</li></ul><p>上面介绍了一下buffer中的几个变量，这几个变量在使用的过程中对应了buffer的读、写两种模式，如下图所示：</p><p><img src="//southrivers.github.io/2019/10/08/NIO/buffer.png" alt></p><p>在写模式中，position代表了下一个可写的位置，limit为capacity-1（数组的最末位，也就是第一个不可写的位置），在读模式中，position代表了第一个可以读的位置，limit则代表了第一个不可读的位置。buffer由读模式切换为写模式的时候需要调用flip方法翻转一下，由写模式切换为读模式的时候需要调用clear（<strong>清空缓冲区，其实是将上述成员变量复位</strong>）或者compact（<strong>区别于clear方法，该方法在切换为写模式的时候，会将还没有来的及读的数据拷贝到数组的首端，position放到第一个可写的位置</strong>）方法。mark在调用了mark方法的时候会记录当前的position的位置，后续可以使用reset方法来将position复位到mark所指定的标记位。</p><h3 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h3><p>channel类似于文件句柄，不管这个文件是网络文件还是磁盘文件，我们拿到句柄之后就可以对文件进行读写操作，读写的时候需要使用上面提到的buffer来存放数据</p><ul><li>filechannel：对于filechannel并没有太多好讲的，只是有一点需要明确一下其是阻塞的，没有所谓的非阻塞一说，因此也就用不到下面的selector了</li><li>socketchannel&amp;serversocketchannel：socketchannel用来表示服务端与客户端建立的链接，serversocketchannel用于监听特定的端口来接收客户端的请求，区别于filechannel，这两种类型的channel可以设置阻塞、非阻塞的模式。</li></ul><h3 id="selector"><a href="#selector" class="headerlink" title="selector"></a>selector</h3><p>selector是多路复用器，针对前面的socketchannel、serversocketchannel的非阻塞模式会特别有用，其会监听注册到该复用器上的channel的事件（该事件是通过socket对应的buff的回调函数写入的）。我们可以直接通过select来查看已经就绪的channel，最后通过一个示例来演示一下几个模块的组合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TODO channel关闭的异常待处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOSelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建serversocketchannel，用于接收客户端的请求</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        serverSocketChannel.bind(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>));</span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建多路复用器，用于将各种channel及对应的事件注册进来</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 筛选出所有的可以处理的channel对应的selectionKey</span></span><br><span class="line">            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterators = keys.iterator();</span><br><span class="line">            <span class="comment">// 遍历处理每一个key</span></span><br><span class="line">            <span class="keyword">while</span> (iterators.hasNext()) &#123;</span><br><span class="line"></span><br><span class="line">                SocketChannel socketChannel = <span class="keyword">null</span>;</span><br><span class="line">                SelectionKey selectionKey = iterators.next();</span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123;</span><br><span class="line">                    socketChannel = (SocketChannel) selectionKey.channel();</span><br><span class="line">                    <span class="comment">// 创建buffer用于读取数据</span></span><br><span class="line">                    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                    socketChannel.read(buffer);</span><br><span class="line">                    <span class="comment">// 将buffer切换为读模式（从buffer中读取数据）</span></span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        System.out.println(buffer.toString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将成员变量复位</span></span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                iterators.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>多路复用IO解决的问题是连接数比较多，但是大量连接都没有数据的情况，非阻塞IO解决的是服务端由于阻塞导致线程资源耗尽，进程僵死的问题，因此并不能说哪种方案是最优的，具体场景具体分析吧。而且并不是NIO或者多路复用就是最优的方案，当真的有很多连接都处于活跃状态，阻塞IO可能会更好一点，毕竟只需要一次系统调用。</p><p><a href="http://tutorials.jenkov.com/java-nio/index.html" target="_blank" rel="noopener">NIO官方网站</a></p><p><a href="https://embed-linux-tutorial.readthedocs.io/zh_CN/latest/system_programing/socket_io.html" target="_blank" rel="noopener">其他好文章</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jvm垃圾回收机制</title>
      <link href="/2019/10/08/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/10/08/java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Java和C++相比最大的好处就在于自动的进行垃圾回收，不需要程序员手动释放，这大大的方便了我们的开发，不过作为一个合格的Java程序开发人员，我们还是有必要了解一下内存回收的一些知识</p><h1 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h1><p><img src="//southrivers.github.io/2019/10/08/java垃圾回收机制/JVM%E5%86%85%E5%AD%98.png" alt>JVM内存结构如上图所示，每一部分都有专门的用处</p><ul><li><p>java虚拟机栈：java虚拟机栈是线程私有的，方法在执行的时候都会创建一个栈帧，主要用来方法调用过程中的一些变量，这些变量包括：局部变量表（各种基本类型和引用类型的指针），方法出口等信息</p></li><li><p>本地方法栈：和java虚拟机栈的作用是相似的，只不过本地方法栈是用来为Native方法服务的</p></li><li><p>程序计数器：程序计数器用来记录程序执行的行号，是为了确保线程切换之后能恢复到正确的位置继续执行，每一个线程都有一个独立的计数器（程序计数器是线程私有的）</p></li><li><p>堆内存：用来存放对象实例，也是垃圾回收算法主要回收的一块地方</p></li><li><p>方法区：非堆，主要用来存放类信息、常量、静态变量（类级别的变量）等数据</p><h1 id="对象存活的判定"><a href="#对象存活的判定" class="headerlink" title="对象存活的判定"></a>对象存活的判定</h1><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>引用技术算法是通过在给对象添加一个引用计数器，对象被引用一次就将该计数值加1，当对象的引用值为0的时候，就可以确定该对象可以回收了，这种算法有个缺点：循环引用。<img src="//southrivers.github.io/2019/10/08/java垃圾回收机制/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt>如上图所示，假设Obj A和Obj B都可以被回收的情况下，A、B相互引用，那么这两个对象都不会被回收掉。不过引用计数法还是有一些使用场景的，它的优点就是实现简单，只是在JVM中我们没有采用这种方式来对对象存活进行判定。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法是通过一系列的GC Root的对象作为起点，判断这些GC Root对象到堆内存中的对象是否可达，如果不可达，说明对象可以被回收了，反之，对象还存活着。值得一说的是，这些GC Root对象的选取是有条件的，必然不能是堆内存中的对象作为GC Root（试想一下，如果GC Root可以是堆内存中的对象的话，那么可达性分析算法和上面的引用计数法就没有区别了），可以作为GC Root的对象如下：</p></li><li><p>栈（包括java虚拟机栈和本地方法栈）中的局部变量</p></li><li><p>方法区中的类变量、静态常量</p><h1 id="垃圾收集的算法"><a href="#垃圾收集的算法" class="headerlink" title="垃圾收集的算法"></a>垃圾收集的算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>标记清除会将需要回收的对象进行标记，在标记完之后触发垃圾回收操作，这种垃圾回收算法会产生以下问题：</p></li><li><p>空间问题：会有很多内存碎片</p></li><li><p>效率问题：当产生很多内存碎片之后，再次给对象分配内存的时候，可能会需要寻找很久才可以找到合适的空间</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法是将内存划分为大小相等的两块，每次分配对象的时候都会将存活的对象移动到另外一块内存中，这样原来的内存空间就可以全部回收了，不过这种回收算法有着明显的缺陷，那就是内存的使用率不高，每次都只使用了50%</p></li></ul><h2 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h2><p>标记整理分为两个阶段，标记阶段会讲存活的对象进行标记，整理阶段会将存活的对象向内存的一端移动，然后将边界之外的内存全部回收掉</p><h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>当前主要的垃圾回收都采用分代回收的策略：将内存划分为新生代和老年代，并针对不同的内存采用不同的回收算法：</p><ul><li>新生代：在新生代，每次垃圾回收都会有大量的对象被回收掉，因此采用复制的算法可以大大的节约内存的浪费，将新生代的内存划分为两个surviver区和一个Eden区，每次回收都会将from surviver 和Eden区中存活的对象移动到另外一个surviver中，由于存活的对象surviver可能无法全部回收，因此在垃圾回收的时候会使用老年代进行担保。</li><li>老年代：由于老年代没有额外的担保，因此在垃圾回收的时候采用的是标记整理的算法</li></ul><h1 id="GC的触发条件"><a href="#GC的触发条件" class="headerlink" title="GC的触发条件"></a>GC的触发条件</h1><ul><li>空间不足的时候</li><li>System.gc()方法调用的时候，不建议使用</li><li>空间分配担保失败的时候</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP/IP详解</title>
      <link href="/2019/10/08/TCP-IP%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/10/08/TCP-IP%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近服务端总是会出现一些CLOSE_WAIT的问题，因此抽时间了解并整理了TCP相关的知识点，说是详解其实也并不是，仅仅把一些关键的东西列出来吧。</p><h1 id="TCP详解"><a href="#TCP详解" class="headerlink" title="TCP详解"></a>TCP详解</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TCP属于传输层的协议，提供面向连接的、端到端可靠的包传输。</p><!-- ## 数据报结构--><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="//southrivers.github.io/2019/10/08/TCP-IP详解/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt></p><ul><li>客户端发送一个SYN（n）包到服务端，同时客户端进入SYN_SENT状态，等待服务端的应答</li><li>服务端收到客户端的SYN包之后，必须确认ACK（n+1），并发出一个SYN（m）的包，此时服务器进入SYN_RECV状态</li><li>客户端收到了服务器的SYN+ACK包之后，向服务发送确认报文ACK（m+1），此时客户端和服务端进入到ESTABLISHED的状态</li></ul><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="//southrivers.github.io/2019/10/08/TCP-IP详解/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt></p><ul><li>客户端发送释放连接的报文，并停止发送数据，此时客户端进入FIN_WAIT_1，等待服务端的确认</li><li>服务端收到客户端的报文之后，会立即回复客户端收到报文了，同时进入CLOSE_WAIT的状态</li><li>客户端收到服务端确认的报文之后，会立即进入FIN_WAIT_2的状态，由于服务端可能还有没有处理完的数据，因此客户端并不会立即回复客户端（这也是为什么需要4次挥手的原因）</li><li>服务端将最后的数据处理并发送完之后，就会向客户端发送一个FIN包，此时服务端进入LAST_ACK的状态，同时客户端结束FIN_WAIT_2状态进入TIME_WAIT状态</li><li>客户端在收到服务端的报文之后，会立即回一个ACK的报文，用于确定已经收到服务端要求结束的报文，同时进入TIME_WAIT状态</li><li>服务端收到ACK的报文之后会立即终止，客户端在等待2MSL之后也会终止（之所以等待2MSL，是因为断开连接之后可能会收到迟到的报文）<!-- # 拥塞控制## 拥塞控制方式## 拥塞控制详解--><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1></li></ul><p><strong>上面的状态可以反过来进行记忆：SYN_SENT 可以极为SENT_SYN，CLOSE_WAIT可以记为WAIT_CLOSE等等，这样会比较方便</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>mybatis源码剖析</title>
      <link href="/2019/10/08/mybatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/10/08/mybatis%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h1><p>本节主要对mybatis的整个流程进行分析，在分析之前有必要先说明：如果从配置文件以及映射文件的加载到解析去分析整个流程的话，流程复杂且不说，而且舍本逐末。因此本小结先从使用者的角度去阅读代码：如下是用户使用mybatis的代码，我们就从入口开始进入分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//mybatis的配置文件</span></span><br><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line"><span class="comment">//使用类加载器加载mybatis的配置文件（它也加载关联的映射文件）</span></span><br><span class="line">InputStream is = App<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>().<span class="title">getResourceAsStream</span>(<span class="title">resource</span>)</span>;</span><br><span class="line"><span class="comment">//构建sqlSession的工厂</span></span><br><span class="line">SqlSessionFactory sessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(is);</span><br><span class="line">SqlSession session = sessionFactory.openSession();</span><br><span class="line"><span class="comment">// ----入口----</span></span><br><span class="line">UserMapper userMapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行查询返回一个唯一user对象的sql</span></span><br><span class="line">User user = userMapper.getUser(<span class="number">1</span>);</span><br><span class="line">System.out.println(user);</span><br><span class="line"></span><br><span class="line">session.close();</span><br></pre></td></tr></table></figure><p>— session代表一次和数据库的会话，姑且可以认为是一个连接 —</p><p>sqlsession可以认为是数据库的代理，其本身代理了数据库增删改查的功能sqlsession.getMapper会调用configuration.getmapper(Mapper.class, this)，该方法会继续调用mapperRegister.getMapper的方法来获取mapper接口对应的mapperProxyFactory，接下来通过工厂模式获取mapperProxy对象，该对象即是mapper.xml的代理对象，过程如下：<img src="//southrivers.github.io/2019/10/08/mybatis源码剖析/%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Iface</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">result</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhanceTest</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> enhance(<span class="string">"proxy!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">enhance</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Iface iface = (Iface) Proxy.newProxyInstance(Iface.class.getClassLoader(), new Class[]&#123;Iface.class&#125;, new EnhanceTest());</span><br><span class="line">        String x = iface.result();</span><br><span class="line">        System.out.println(<span class="string">"the result is: "</span> + x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">the result is: proxy!</span><br></pre></td></tr></table></figure><p>通过上面的代码我们可以知道，并不需要必须定制一个接口的实现类来实现动态代理。</p><h2 id="接下来是用生成的代理去执行对应的方法操作数据库"><a href="#接下来是用生成的代理去执行对应的方法操作数据库" class="headerlink" title="接下来是用生成的代理去执行对应的方法操作数据库"></a>接下来是用生成的代理去执行对应的方法操作数据库</h2><p>上一步获取到的是一个使用jdk动态代理生成的代理对象，因此所有的方法调用首先会进入invoke方法中，也就是上一步生成的mapperproxy对象的invoke方法中该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object<span class="class">.<span class="keyword">class</span>.<span class="title">equals</span>(<span class="title">method</span>.<span class="title">getDeclaringClass</span>())) </span>&#123;</span><br><span class="line">        <span class="comment">// 如果通过动态代理生成的对象调用的是object 中的方法，则直接通过反射的方式来调用即可</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDefaultMethod(method)) &#123;</span><br><span class="line">          <span class="comment">// 兼容jdk1.8，在接口中可以拥有default声明的方法的实现</span></span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存dao接口方法和mapper方法的映射，并获取当前dao接口所对应的mapper方法</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">// mappermethod调用execute方法，并根据该mappermethod的command、method字段确定要执行的方法和返回的结果</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br></pre></td></tr></table></figure><p>代码调用流程如下：</p><h2 id="mybatis插件"><a href="#mybatis插件" class="headerlink" title="mybatis插件"></a>mybatis插件</h2><p>mybatis的插件功能使得mybatis具备可扩展的功能，插件的加载是在实例化executor的过程中，实例化executor是在创建sqlsession的时候。插件实现的功能是对executor的增强，增强的实现需要我们实现Interceptor接口，具体的实现逻辑需要借助于Plugin类的wrap方法，wrap的方法最终会调用Proxy的newInstance生成代理实例，每一个代理实例都是对当前代理的增强，因此，executor最终是会包含所有的interceptor的增强的逻辑的，在通过executor执行代码的调用的逻辑的时候，这种增强会通过plugin的invoke方法回到interceptor中的intercept方法中，我们的增强逻辑实现在Interceptor的intercept方法中即可。将增强的功能单独放到插件中去实现，并将插件注入到实现invocationhandler的类中，这样在实现invocationhandler的类中的invoke方法调用增强逻辑据可以了，拦截器的注入可以通过构造器注入，也可以通过setter方法注入。（interceptor有接口、有实现，把这种实现织入到已有的类中，对已有的类进行增强！而不是对interceptor做增强的操作，角色有点反转，这样可以使得插件的实现更清爽）接下来我们依然画一下流程图：<img src="//southrivers.github.io/2019/10/08/mybatis源码剖析/%E6%8B%A6%E6%88%AA%E5%99%A8%E9%80%BB%E8%BE%91.png" alt>Plugin实现了InvocationHandler接口代理应该是把invocationhandler接口的功能合并到被代理的对象中，合入的过程是可以做相应的控制的 –</p><h2 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h2><p>作为web应用，一般都会使用缓存技术来拦截大量奔向数据库的请求，来减轻数据库的压力。mybatis提供了一级缓存和二级缓存这两种缓存的机制，这两级缓存均是使用cache接口的实现类。mybatis提供了丰富的缓存实现，具有基本功能的perpetualcache（一个封装了hashmap的类），mybatis使用了装饰的模式来实现缓存（装饰和代理很像代理更多的是权限的控制，装饰更多的是功能的丰富，二者都会持有被装饰的或者被代理的对象）。</p><p>perpetualCache仅仅封装了hashmap，其所有的操作也是针对hashmap而言，LRUcache封装了perpetualcache，并通过将查询的key缓存的到一个keymap（一个重写了removeEldestentry方法的hashmap）中，或者缓存中存在数据的时候，将最近的一次查询对应的key移动到keymap的队首，从而实现LRU的策略，如果keymap的尺寸大于要求就将最旧的值给去掉其流程图如下：<img src="//southrivers.github.io/2019/10/08/mybatis源码剖析/lru.png" alt></p><p>blockcache 实现了阻塞的特性，该特性是基于java的重入锁实现的，同一个时刻下blockcache仅允许一个线程访问指定key的缓存项，其他的线程将会被阻塞其锁的阻塞关系图如下：<img src="//southrivers.github.io/2019/10/08/mybatis源码剖析/blockingcache.png" alt>大致的逻辑是当有多个线程同时查询某一个key对应的value的时候，如果每个线程都去查询一次数据库，这显然不合理，因此让第一个查询该key所对应的线程通过生成一个锁并<strong>尝试</strong>加锁阻塞其他线程（如果加锁失败则该线程就会被阻塞），如果从缓存中查出数据，直接返回，否则获取锁的线程直接查询数据库并写入缓存以上是缓存的实现，下面是使用上面的实现来构建复杂的缓存体系</p><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>一级缓存是在创建BaseExecutor的时候通过构造器的方式来进行创建的，在查询的时候会根据查询的条件进行构建key然后通过该key获取缓存中对应的value，如果获取不到就直接查询数据库，一级缓存是数据库的最后一道防线，并且默认是开启的，而且所使用cache就是perpetralcache，由于以及缓存是在baseExecutor中创建的，因此其是和sqlsession绑定的</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>二级缓存是构建在一级缓存的基础之上，查询请求会先落到二级缓存中，然后才是一级缓存，<strong>二级缓存和具体的空间绑定</strong>，并且默认是不开启的，只有用户做了相关的配置之后才会生效，具体的配置可以参见网上的相关文档。<strong>一级缓存是和sqlsession绑定的</strong>，因此不存在并发的问题（哪个线程查询结果返回的晚就使用哪个查询结果做缓存），二级缓存是在mappedstatement中获取的（一级缓存是在创建executor中获取的），而mappedstatement存在于全局的配置中，因此可以被多个executor获取。这种共享缓存引起的问题主要有一下两点：<code>1、多个线程访问共享内存引发的线程安全问题</code><code>2、多个事务访问共享内存引发的脏读的问题</code>对于共享内存引发的安全问题可以通过synchroinzedcache来解决，这个装饰类会在构造二级缓存的时候被默认给加上，至于多个事务引发的脏读的问题，需要借助于tcm（transactionalcachemanager）来解决</p><p>这样就会因为共享数据的访问而引发线程安全的问题。多个事务共享一个缓存实例也会导致具体如下：</p><p>Xmlconfigbuilder负责读取mybatis的配置文件并转换为configuration对象在构建configuration的过程中会使用xmlmapperbuilder读取xmlmapper对象，完成namespace的注册，将需要注册的资源加载进来。接下来需要创建sqlsession，在创建的时候会生成executor，通过jdk动态代理的方式对executor进行增强（plugin）最后在执行方法调用的时候会为被执行的接口通过动态代理的方式生成相应的对象。</p><h1 id="核心知识点记录"><a href="#核心知识点记录" class="headerlink" title="核心知识点记录"></a>核心知识点记录</h1><p>作为一个有着4年helloworld的小白同志，今天终于怀着激动的心情开始阅读源码了，千里之行，始于足下，希望能够坚持下来。今日特此一记</p>]]></content>
      
      
      
        <tags>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java线程池</title>
      <link href="/2019/06/02/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2019/06/02/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近在后台用到了线程池，之前的工作中现网也因为线程池的使用不当引发过多次的问题，因此抽时间总结了一下线程池相关的内容，以备后用。</p><h1 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h1><h2 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h2><h3 id="初始化及提交任务"><a href="#初始化及提交任务" class="headerlink" title="初始化及提交任务"></a>初始化及提交任务</h3><p>线程池采用了池化的技术来实现线程的复用，并且还实现了队列用于保存提交的任务，从而将线程和任务进行了解偶。我们先来看一下jdk给我们提供的线程池的实现，并具体的说明一下线程池的参数，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize：核心线程池</li><li>maximumPoolSize：最大线程池</li><li>keepAliveTime：超出核心线程数量之后的线程在没有使用的情况下的存活时间</li><li>unit：存活时间的单位</li><li>workQueue：提交任务的保存队列（注意并不是所有提交的任务一定会入队列）</li><li>threadFactory：创建新线程的工厂类</li><li>handler：饱和策略（当阻塞队列中已经满并且线程池中线程的数量达到最大线程池的情况下，对于新提交的任务的处理策略）</li></ul><p>接下来看一下任务提交的整个过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    /*</span><br><span class="line">     * Proceed in 3 steps:</span><br><span class="line">     *</span><br><span class="line">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="line">     * start a new thread with the given command as its first</span><br><span class="line">     * task.  The call to addWorker atomically checks runState and</span><br><span class="line">     * workerCount, and so prevents false alarms that would add</span><br><span class="line">     * threads when it shouldn&apos;t, by returning false.</span><br><span class="line">     *</span><br><span class="line">     * 2. If a task can be successfully queued, then we still need</span><br><span class="line">     * to double-check whether we should have added a thread</span><br><span class="line">     * (because existing ones died since last checking) or that</span><br><span class="line">     * the pool shut down since entry into this method. So we</span><br><span class="line">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="line">     * stopped, or start a new thread if there are none.</span><br><span class="line">     *</span><br><span class="line">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="line">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="line">     * and so reject the task.</span><br><span class="line">     */</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在解释上面代码之前，有必要先看一下集合核心的字段及方法，上面的代码中有一个核心的字段ctl，该字段是一个AtomicInteger类型的字段，是一个32位的变量，其中低29位表示线程池中线程的数量，高三位则代表了线程池的状态，用来表征线程池状态的状态如下：</p><ul><li>RUNNING    = -1 &lt;&lt; COUNT_BITS：高三位是111，低29位是0</li><li>SHUTDOWN   =  0 &lt;&lt; COUNT_BITS：高三位是000，低29位是0</li><li>STOP       =  1 &lt;&lt; COUNT_BITS：高三位是001，低29位是0</li><li>TIDYING    =  2 &lt;&lt; COUNT_BITS：高三位是010，低29位是0</li><li>TERMINATED =  3 &lt;&lt; COUNT_BITS：高三位是100，低29位是0</li></ul><p><img src="//southrivers.github.io/2019/06/02/java线程池/state" alt></p><p>上面可以看到的是running -&gt; terminated是一个依次递增的过程。</p><p>比较重要的方法如下：</p><ul><li>int runStateOf(int c)     { return c &amp; <del>CAPACITY; }：</del>CAPACITY高三位是1，其余是0，用来获取线程的状态信息</li><li>int workerCountOf(int c)  { return c &amp; CAPACITY; }：高三位是0，其余为1，用于获取线程池中线程数量的信息</li><li>int ctlOf(int rs, int wc) { return rs | wc; }：用于将高三位rs（runStatus）和低29位wc（workerCount）组合成ctl变量</li></ul><p>在介绍完这些基础知识之后，我们来看一下，任务提交的过程中线程池框架的处理过程是什么样子的：</p><ul><li>如果线程池中线程的数量小于corePoolSize，这个时候就会创建一个新的线程来执行任务</li><li>如果线程池中运行的线程的数量超过了corePoolSize则会判断当前线程池的状态，如果线程池处于运行状态，并且能够将任务添加到队列中则会进行一次doubleCheck来看一下线程池是否处于运行状态，如果线程池已经不在运行的状态，则会尝试将任务移出队列，如果移出成功则会使用提供的reject策略进行处理任务，否则会判断当前线程的数量是否为0，如果是0的话，则会通过提交一个空任务来创建一个线程。</li><li>如果队列已经满了，则会将线程扩充到maxPoolSize来执行任务</li><li>如果线程池中线程的数量已经到达了maxPoolSize，则会使用reject策略进行处理任务</li></ul><p>下面我们简要的通过一个流程图来演示一下新任务提交的过程中，线程池是如何处理的：// TODO</p><h3 id="增加线程：addWorker"><a href="#增加线程：addWorker" class="headerlink" title="增加线程：addWorker"></a>增加线程：addWorker</h3><p>上面的过程中我们看到线程池中核心的方法就是<code>addWorker、reject</code>，因此接下来我们来看一下线程池添加线程的过程（说明一下这里addWorker有两个参数，其中firstTask是该worker执行的第一个任务，一旦线程创建成功之后就会直接从队列中获取任务了，就不会再在这里传参数来构建worker并执行任务了），具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private boolean addWorker(Runnable firstTask, boolean core) &#123;</span><br><span class="line">        retry:</span><br><span class="line">        for (;;) &#123;</span><br><span class="line">            int c = ctl.get();</span><br><span class="line">            int rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">            // Check if queue empty only if necessary.</span><br><span class="line">            if (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                   firstTask == null &amp;&amp;</span><br><span class="line">                   ! workQueue.isEmpty()))</span><br><span class="line">                return false;</span><br><span class="line"></span><br><span class="line">            for (;;) &#123;</span><br><span class="line">                int wc = workerCountOf(c);</span><br><span class="line">                if (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                    return false;</span><br><span class="line">                if (compareAndIncrementWorkerCount(c))</span><br><span class="line">                    break retry;</span><br><span class="line">                c = ctl.get();  // Re-read ctl</span><br><span class="line">                if (runStateOf(c) != rs)</span><br><span class="line">                    continue retry;</span><br><span class="line">                // else CAS failed due to workerCount change; retry inner loop</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ........</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上述代码中retry部分的判断比较复杂，线程池状态处于非运行状态并且线程终止、任务异常、队列为空任何一个条件满足的情况下则添加任务失败。关于这个判断的话我们可以大致的总结一下（把括号内的条件拆解会比较好理解一点）：</p><ul><li>当线程池处于或者更高的shutdown状态的时候，我们就不应该往队列中添加任务了</li><li>如果线程池处于更高的状态并且提交的任务不是null的情况下，则说明此时线程池已经关闭了，因此也不能再往线程池中添加任务了</li><li>如果线程池处于更高的状态并且线程池中的队列也已经为空了，我们也不应该提交任务了，这一步的分析要回到上面execute的方法中，上面的execute的方法中我们会看到当线程池中线程的数量为空的时候是会通过提交一个空的任务来创建一个线程，并从queue中获取任务，也就说明了线程池正常运行状态的时候肯定不是空，如果线程池中的线程已经是空的了，说明可能正在进行的操作是线程的销毁，因此这种情况下也不应该新建线程，所以直接<code>return false</code>了。</li></ul><p>如果不是上面这些情况的话，我们则会通过cas的操作来增加一个worker：<code>compareAndIncrementWorkerCount(c)</code>，这里新增一个worker也是需要一定条件的，具体如下：</p><ul><li>只有线程池中线程的数量少于CAPACITY并且线程的数量少于核心线程或者最大线程的时候才会创建，需要注意这里到底是小于核心线程还是最大线程的数量是和传入的参数相关的。</li></ul><p>上面的整个过程还只是针对线程池中线程的数量做自加的操作，到此为止线程池中线程的数量并没有发生实质的操作，接下来才是真正的创建线程的过程，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">Worker w = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">    <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">            <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">            <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">            <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                workers.add(w);</span><br><span class="line">                <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                    largestPoolSize = s;</span><br><span class="line">                workerAdded = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">            t.start();</span><br><span class="line">            workerStarted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">        addWorkerFailed(w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> workerStarted;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到首先定义了两个标记位：<code>workerStarted、workerAdded</code>，分别用来表征线程成功启动、创建线程成功。接下来会首先创建一个worker对象，worker对象的创建伴随着一个线程的创建，具体可以参见worker的构造函数。我们可以获取worker里面的线程。接下来我们会获取当前线程池的一把锁，这个是可重入锁，意味着一个线程可以向该线程池中添加多次任务（在当前线程抢到了锁的情况下）。接下来我们会获取线程池的状态，并判断（或）：</p><ul><li>线程池处于运行的状态</li><li>线程处于shutdown的状态（此时queue中可能还有没有处理完的任务，这种情况下是要求创建没有任务的线程来消费剩下的任务的）</li></ul><p>上面的条件二者满足其一的情况下则可以向线程池中添加新的线程，如果添加线程成功了则可以开始执行任务了，如果执行任务中失败了，或者压根创建线程都没有成功的情况下则我们还应该还原现场：将线程的数量减一。</p><p>这里值得注意的是worker有点类似于一个包装器，用来包装任务和线程，并且其实现了AQS框架的lock操作。</p><h3 id="拒绝策略：reject"><a href="#拒绝策略：reject" class="headerlink" title="拒绝策略：reject"></a>拒绝策略：reject</h3><p>在上面的代码中我们可以看到在一定的情况下我们需要拒绝新加入的任务，总结概括一下拒绝的策略，如下：</p><ul><li>任务队列满的时候</li></ul><p>接下来我们通过具体的代码来分析一下拒绝的流程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">reject</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    handler.rejectedExecution(command, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，这里拒绝的过程相对来说就比较简单了，直接是调用我们传入（或是缺省默认的情况）的拒绝策略来执行了。</p><p>到这里还缺失了一个步骤没有看到：当线程池中线程的数量大于corepoolsize之后，队列还没有满的情况下需要将新的任务添加到队列中，当队列满之后就会创建新的线程来执行任务，那么加入队列的任务是什么时候被线程池中的线程执行的呢？这些都要从ThreadPoolExecutor的内部类Worker来说起了。在介绍worker之前，先来简单的对其做一下介绍：worker实现了AQS框架，并继承了Runnable接口，我们知道AQS的作用主要是实现加解锁的工具，既然是继承了AQS，那么worker肯定是实现了自己的加解锁的过程，之所以要实现加解锁是为了防止在任务执行的过程中，线程接收到中断的信号，那么这种情况下会导致任务的执行失败，通过加一个不可重入的排它锁，当一个任务在执行的时候，外部想要中断这个任务就必须要获取锁，而现实的情况是锁不可重入且是排它的，因此就必须等待当前任务执行完毕。那么什么情况下会发生中断任务的请求呢？这个也可以在源码的注释中找到答案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/* When a new task is submitted in method &#123;@link #execute(Runnable)&#125;,</span></span><br><span class="line"><span class="comment"> * and fewer than corePoolSize threads are running, a new thread is</span></span><br><span class="line"><span class="comment"> * created to handle the request, even if other worker threads are</span></span><br><span class="line"><span class="comment"> * idle.  If there are more than corePoolSize but less than</span></span><br><span class="line"><span class="comment"> * maximumPoolSize threads running, a new thread will be created only</span></span><br><span class="line"><span class="comment"> * if the queue is full.  By setting corePoolSize and maximumPoolSize</span></span><br><span class="line"><span class="comment"> * the same, you create a fixed-size thread pool. By setting</span></span><br><span class="line"><span class="comment"> * maximumPoolSize to an essentially unbounded value such as &#123;@code</span></span><br><span class="line"><span class="comment"> * Integer.MAX_VALUE&#125;, you allow the pool to accommodate an arbitrary</span></span><br><span class="line"><span class="comment"> * number of concurrent tasks. Most typically, core and maximum pool</span></span><br><span class="line"><span class="comment"> * sizes are set only upon construction, but they may also be changed</span></span><br><span class="line"><span class="comment"> * dynamically using &#123;@link #setCorePoolSize&#125; and &#123;@link</span></span><br><span class="line"><span class="comment"> * #setMaximumPoolSize&#125;. &lt;/dd&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaximumPoolSize</span><span class="params">(<span class="keyword">int</span> maximumPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(ctl.get()) &gt; maximumPoolSize)</span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的注释中可以清晰的看到我们是可以在线程池处于运行状态的时候动态的调整线程池的大小的，而这个动态调整的一个过程就会触发中断的信号，查看其他核心参数的调整也都可以看到中断的过程。接下来看一下Work的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的介绍中我们可以知道，task和worker都实现了Runnable的接口，再看一下worker的构造函数，是否会发现这其实就是一个代理的过程呢？这里需要简单的介绍一下worker的构造函数：</p><ul><li>state：state是一个计数器，用来表征AQS的同步状态，也即是当前worker是否已经加锁了</li><li>firstTask：用户提交的任务，这里需要注意，虽然task实现了Runnable接口，但是并不是会使用firstTask来完成线程的创建的，其只是用来执行任务的，可能这句话不太好理解，不过线程池的目标就是用来复用线程的，如果我们用task来创建线程，那么势必造成再来一个任务就没有办法复用这个task所创建的线程了。</li><li>thread：线程池中真正执行任务的线程</li></ul><p>当任务被执行的时候，最终会走到runWorker方法中，这里代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">            <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">            <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">            <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的过程中可以看到，执行任务的时候会首先对worker进行unlock，此时任务还没有执行，因此是可以中断的状态，接下来就进入一个while循环了，可以看到该while循环是不停的获取任务的过程，一旦获取到任务，接下来就会对当前的worker进行上锁，并执行任务，如果任务执行失败就会抛出异常，并最终执行<code>processWorkerExit(w, completedAbruptly);</code>方法。这里还有两个过程需要分析：<code>getTask</code>、<code>processWorkerExit</code>，我们接下来分别看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Are workers subject to culling?</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是获取任务的整个过程，这里首先会线程池状态是否异常，如果是则进入一个销毁线程池的过程，具体参见decrementWorkerCount，接下来会判断线程池中线程的数量是否超过允许的最大值或者获取任务是否超时。接下来进入一个任务获取的过程。</p><p>最后是任务执行完之后一个退出的过程，该过程是线程池中没有任务的情况下线程池中线程的销毁策略，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 任务异常终止的情况下需要将worker的数量-1</span></span><br><span class="line">    <span class="keyword">if</span> (completedAbruptly) <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">        decrementWorkerCount();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除worker</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        completedTaskCount += w.completedTasks;</span><br><span class="line">        workers.remove(w);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 除了任务执行完之后，队列中存放的任务为空的情况下，什么情况下还会进行线程的销毁呢？</span></span><br><span class="line">    <span class="comment">// 那就是整个线程池都销毁的时候，因此这一步是判断是否有必要终止线程池</span></span><br><span class="line">    tryTerminate();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">            <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class="line">                min = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行任务的过程中有任何失败导致线程数量（并不是真正线程的个数）回退，就会通过添加一个初始任务为空的worker</span></span><br><span class="line">        addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池的种类"><a href="#线程池的种类" class="headerlink" title="线程池的种类"></a>线程池的种类</h2><p>上面我们从源码的层面上分析了一下线程池的原理，接下来看一下当前较常用的线程池工具类，这些常用的线程池的生成是在Executors里面，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),</span><br><span class="line">                                  threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是从源代码中摘抄的（除了上面的这些个种类的线程池，还包含了ForkJoin类型的线程池），从上面的定义中可以看到这些个种类的线程池都是通过ThreadPoolExecutor来生成的，唯一的区分是线程池的参数会有所不同：</p><ul><li>newFixedThreadPool：这里我们可以看到当前线程池的核心线程池大小和最大线程池大小是一致的，使用的队列是一个无界的阻塞队列</li><li>newCachedThreadPool：这里是一个缓存线程池，可以看到这里的核心线程池是0，并且接收的队列是一个<strong>同步阻塞队列</strong>，试想一下如果我们使用这种线程池，如果我只提交一个任务，那么由于核心线程池中线程的数量是0，将会导致firstTask无法被触发，最终会导致没有办法消费队列中的任务。这个问题看起来很奇怪，根本原因出在我们所使用的用于接收任务的队列上面<strong>SynchronousQueue</strong>，下面会针对队列进行分析。</li><li>ScheduledThreadPoolExecutor：创建一个定长的线程池，<strong>DelayedWorkQueue</strong>也是一个阻塞队列</li></ul><h2 id="线程池中的队列（此处存疑）"><a href="#线程池中的队列（此处存疑）" class="headerlink" title="线程池中的队列（此处存疑）"></a>线程池中的队列（此处存疑）</h2><p>在介绍上面线程池种类的时候有提到线程池使用的阻塞队列，我们可以先对阻塞队列进行一个分类：</p><ul><li>有界队列：顾名思义，有界队列是队列的大小是有限制的，常用的有FIFO的ArrayBlockQueue、具备优先级的PriorityBlockingQueue</li><li>无界队列：队列的大小不受限制，这个可能会导致积压大量的任务并最终引发OOM，常见的有LinkedBlockingQueue</li><li>同步移交队列：这是一个比较特殊的队列，SynchronizedQueue并不是一个队列，而是线程之间的一种移交策略，当我们将任务放入队列时候必须要有一个线程等待接收这个任务。只有在使用无界队列或者有饱和策略（常见的就是由提交线程处理任务）的时候才使用这个队列。</li></ul><p><strong>关于队列的还有很多东西可以讲，后面会专门的抽出一个小结来说明线程池中的队列。</strong></p><h2 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h2><p>所谓饱和策略是指当我们没有办法往队列中添加任务的时候，针对新提交的任务的处理策略，具体可以参考如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerRunsPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> CallerRunsPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CallerRunsPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Executes task r in the caller's thread, unless the executor</span></span><br><span class="line"><span class="comment">     * has been shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            r.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that throws a</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> RejectedExecutionException&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AbortPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates an &#123;<span class="doctag">@code</span> AbortPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbortPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Always throws RejectedExecutionException.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RejectedExecutionException always</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task "</span> + r.toString() +</span><br><span class="line">                                             <span class="string">" rejected from "</span> +</span><br><span class="line">                                             e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that silently discards the</span></span><br><span class="line"><span class="comment"> * rejected task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardPolicy&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Does nothing, which has the effect of discarding task r.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A handler for rejected tasks that discards the oldest unhandled</span></span><br><span class="line"><span class="comment"> * request and then retries &#123;<span class="doctag">@code</span> execute&#125;, unless the executor</span></span><br><span class="line"><span class="comment"> * is shut down, in which case the task is discarded.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardOldestPolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> DiscardOldestPolicy&#125; for the given executor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DiscardOldestPolicy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Obtains and ignores the next task that the executor</span></span><br><span class="line"><span class="comment">     * would otherwise execute, if one is immediately available,</span></span><br><span class="line"><span class="comment">     * and then retries execution of task r, unless the executor</span></span><br><span class="line"><span class="comment">     * is shut down, in which case task r is instead discarded.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> r the runnable task requested to be executed</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e the executor attempting to execute this task</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">            e.getQueue().poll();</span><br><span class="line">            e.execute(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以看到，饱和策略大致可以分为四种：</p><ul><li>CallerRunsPolicy：这种方式我们是直接使用的r.run的方式，因此可以知道这种方式其实是使用的阻塞提交者的方式来执行任务的</li><li>AbortPolicy：抛出异常并终止执行的策略</li><li>DiscardOldestPolicy：丢弃最旧的任务的策略</li><li>DiscardPolicy：简单的丢弃策略，什么都不做</li></ul><h1 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h1><p>由于我们是做监控业务的，会有告警数据的处理，有一些告警策略需要针对某一种或者某一个类型的监控对象进行连续检测，由于我们生成的异常数据是写入到kafka，而做这种连续检测的是放在后台进行检测，我们的后台是部署了多个server端，不过由于需要连续检测，并且由于消息入队列的时候是没有key值的，因此kafka的分区只有一个，所以我们的后端其实是采用主备的方式进行消费数据的，这里我们使用到了线程池去消费，最初的时候我们使用的是一个无界队列，这导致我们的服务端隔一段时间会出现告警的积压，并且后端出现OOM，因此我们后面采用的是有界队列，并且是丢弃旧的数据的策略，毕竟告警有一定的时效性，才算稳定现网。</p><p>不过这也明显存在一个缺陷，因此可以采用的策略是：</p><ul><li>使用实时计算组件通过groupByKey，并增加kafka的分区来进行处理</li><li>增加kafka的分区，并将数据按照一定的规则写入redis，后台实现redis key值的切分完成并行的处理数据</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>每天进步一点点，加油！</p><p>cached pool 能够创建线程的原因</p><h1 id="TODO-scheduler取消调度线程的问题？？？？？remove无效"><a href="#TODO-scheduler取消调度线程的问题？？？？？remove无效" class="headerlink" title="TODO scheduler取消调度线程的问题？？？？？remove无效"></a>TODO scheduler取消调度线程的问题？？？？？remove无效</h1><!-- 博客https://www.cnblogs.com/trust-freedom/p/6681948.html -->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之lock</title>
      <link href="/2019/05/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Block/"/>
      <url>/2019/05/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8Block/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>lock是java并发包提供的管程的一种实现，相较于jdk给出的synchronized，其具备以下优点：</p><ul><li>能够响应中断：synchronized的wait方法是可以响应中断的，不过在获取锁的时候（也就是还没有进入synchronized的方法体的时候）线程是没有办法响应中断的，而lock在入口等待队列以及条件等待队列中都是可以响应中断的，究其原因是lock在入口等待队列以及条件等待队列都是运行态（不包含runnable的状态）</li><li>支持超时：synchronized是不支持超时的，这里的超时是获取锁的时候超时参数，并不是进入waiting、block中的超时，也即是获取锁的入口等待队列中是支持超时的</li><li>非阻塞的获取锁：lock提供了fast fail的机制，在获取不到锁的时候可以快速失败，而不是一只阻塞</li></ul><p>综上并发包中的lock保证了在获取锁的时候可中断、可超时、可快速失败。</p><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><p>接下来通过代码演示一个使用lock实现的阻塞队列：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">package com.hw;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.locks.Condition;</span><br><span class="line">import java.util.concurrent.locks.Lock;</span><br><span class="line">import java.util.concurrent.locks.ReentrantLock;</span><br><span class="line"></span><br><span class="line">public class TestQueue &#123;</span><br><span class="line"></span><br><span class="line">    private Object[] queue;</span><br><span class="line"></span><br><span class="line">    private Lock lock = new ReentrantLock();</span><br><span class="line"></span><br><span class="line">    Condition notFull = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    Condition notEmpty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    private int start;</span><br><span class="line"></span><br><span class="line">    private int end;</span><br><span class="line"></span><br><span class="line">    private int size;</span><br><span class="line"></span><br><span class="line">    public TestQueue(int i) &#123;</span><br><span class="line">        queue = new Object[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void addElement(Object x) &#123;</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        while (size + 1 &gt; queue.length) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                notFull.wait();</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue[end % queue.length] = x;</span><br><span class="line">        end++;</span><br><span class="line">        size++;</span><br><span class="line">        notEmpty.signal();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Object takeElement() throws InterruptedException &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        Object x = null;</span><br><span class="line">        while (size - 1 &lt; 0) &#123;</span><br><span class="line">            notEmpty.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        x = queue[start];</span><br><span class="line">        start = start++ % queue.length;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例代码如上，这里不再详细描述了，其本质就是管程的一种实现，上面使用的锁的实现是可重入锁，其可以保障同一个线程可以对同一个锁多次加锁，并且这种锁提供了公平和非公平的机制，所谓的公平锁是在条件变量的队列上等待时间长的线程将会优先获得锁，而非公平锁则无法保障这种机制。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本节先对java并发保重锁的实现进行分析，后面有时间的话会继续对其实现原理进行剖析</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>并发编程之AQS</title>
      <link href="/2019/05/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/"/>
      <url>/2019/05/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BAQS/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>java并发编程针对锁机制在我看来应该分为两种：jvm语言级别的（synchronized）、基于AQS衍生出来的，本节总结一下AQS的原理并展示一下衍生出来的工具类的源代码，最后给出一些示例来定制化一些基于AQS的同步工具。</p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>java中的同步组件除了jvm给我们提供的语言级别的同步机制外，剩下的就是通过AQS来实现的了，一般是实现AQS给我们提供的模板方法来定制化的实现一些锁。AQS的核心包含了：</p><ul><li>同步状态管理（volatile类型的state）</li><li>同步队列（双向队列）</li><li>等待通知 （signal）</li></ul><p>这里我们可以看到很像我们在前面线程小节中提到的生产者消费者模型中锁的获取，只不过这里多了一个同步队列，用于保存获取锁失败的线程，入队的顺序也决定了后续获取锁的顺序！下面我们具体看一下相关的实现。</p><p><strong>补图</strong>队列+状态</p><!--可以对比线程中的TSL涉及的锁--><h2 id="排他锁"><a href="#排他锁" class="headerlink" title="排他锁"></a>排他锁</h2><p>排他锁也叫独占锁，是指一个锁在某一时刻只能被一个线程占有，其他线程只有在持有锁的线程释放之后才可以获取到锁。我们接下来还是通过代码来演示一下加锁和解锁的流程吧：</p><h3 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h3><p>对于排他锁，程序的入口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>acquire方法就是抢占一个锁的入口，我们看到该方法是final的，这就意味着该方法不可以重写（一个模板方法），具体操作就是下面三段代码：</p><ul><li>tryAcquire(arg)：尝试获取锁 </li><li>addWaiter(Node.EXCLUSIVE)：获取失败则将当前线程封装成一个独占的Node并<strong>append到队尾直至成功</strong></li><li>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)：使线程在等待队列中休息，有机会获取锁（就是上节中提到的LockSupport.unpark操作）的时候再去尝试获取锁，该过程会自旋至获取到锁。</li></ul><p>最后我们还看到如果条件为true的话，还会执行一步selfInterrupt，这里解释一下执行该方法的作用。我们可以看到如果第一步获取锁资源成功的话，那也就不会有后面的操作了，只有在锁获取失败的时候才会让线程进入等待队列<strong>进行休息</strong>，这里特别强调了一下休息，是因为线程在处于waiting的状态（调用的park操作）的时候，是没有办法处理中断的，因此如果在waiting的过程中有中断过来，那么线程会抛出一个InterruptException。前面的小节中我们知道了中断的作用其实是给线程发送一条消息，并不会强制线程中断，而线程抛出异常之后会导致中断标志位复位（中断信号丢失），因此需要在唤醒线程后进行置位操作，告诉线程，在你睡眠期间有个家伙发了一个中断的信号，至于怎么处理，你自己看着办吧。下面我们从代码的层面上来跟进一下上面的流程吧。</p><h3 id="tryAcquire"><a href="#tryAcquire" class="headerlink" title="tryAcquire"></a>tryAcquire</h3><p>该方法就是一个模板方法，供子类实现，需要说明的是该方法之所以不是抽象的而是一个空的，是为了方便使用AQS的用户，如果是个抽象的，那么如果用户想要实现一个共享锁的话，需要重写排他锁才需要重写的方法！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addWaiter"><a href="#addWaiter" class="headerlink" title="addWaiter"></a>addWaiter</h3><p>当获取锁失败的时候，就会将当前线程封装成一个EXCLUSIVE类型的节点，并添加到队列的尾部，具体过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将当前线程构造成一个节点</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">    <span class="comment">// 当前线程获取队尾节点</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 将封装当前线程的节点的前置指针指向位节点，</span></span><br><span class="line">        <span class="comment">// 由于tail是一个共享数据，因此多个线程同时入队列的时候，</span></span><br><span class="line">        <span class="comment">// 必然会有多个node的前置节点指向尾节点</span></span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过cas操作将tail指向当前node</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            <span class="comment">// 成功的话则将之前的tail节点的后置指针指向当前节点，入队操作就完成了</span></span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 首次入队失败，则通过自旋的方式进行入队</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enq具体代码如下，可以看到该过程是一个自旋的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取队尾节点</span></span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">            <span class="comment">// 如果队列为空，则尝试初始化队列</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                <span class="comment">// 初始化队列成功的话，将tail指向当前节点</span></span><br><span class="line">                <span class="comment">// 这里如果有多个线程都进入到初始化队列的话，</span></span><br><span class="line">                <span class="comment">// 就只会有一个能够完成队列的初始化操作，</span></span><br><span class="line">                <span class="comment">// 因此最终进入这里的线程只会有一个，并不会有多个！</span></span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果队列不是空，并且节点入队失败或者队列为空，但是线程创建队列失败，</span></span><br><span class="line">            <span class="comment">// 那么最终肯定会执行到此处，那么自旋的方式设置尾节点就可以了</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面通过图示来演示一下获取锁失败后的入队过程：<img src="//southrivers.github.io/2019/05/25/并发编程之AQS/%E5%8A%A0%E5%85%A5%E9%98%9F%E5%B0%BE.png" alt>上图演示的是有多个线程同时竞争锁的情况下，失败的线程入队的情况，由于tail是共享数据，因此为了保证能够正确的更新tail，这里使用了类似于TSL的原子指令也就是CAS操作，其竞争如下图所示：<img src="//southrivers.github.io/2019/05/25/并发编程之AQS/cas%E7%AB%9E%E4%BA%89.png" alt>最后因为cas操作的原子性，能够成功变成队尾的只有一个节点，其他节点继续在新的tail上竞争，如下图所示：<img src="//southrivers.github.io/2019/05/25/并发编程之AQS/%E5%BE%AA%E7%8E%AF%E7%AB%9E%E4%BA%89%E5%8A%A0%E5%85%A5%E9%98%9F%E5%B0%BE.png" alt>个人认为上面的过程可以只包含enq(node)的过程。</p><p>上面我们看到了抢占不到锁的线程入队的过程，那么入队完了是不是就完事了？并不是！入队完还需要做什么呢？可以想像一下在医院排队挂号，如果我前面的人没有在办理业务，那么我是不是可以占着这个位子，然后找个小板凳坐下来歇歇呢？如果我前面的人已经在办理业务了，那又该怎么办才好？</p><p>接下来让我们来看一下线程入队之后会做什么操作吧，代码开始于<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 注意：方法执行的视角永远不要离开当前的线程，虽然该线程已经被封装到队列的尾部了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 标记是否被中断，这也是当前方法的返回值，用于在线程恢复的时候对中断位进行置位操作</span></span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 自旋的过程，可能会被park程waiting状态，记住当前线程还处于运行的状态，</span></span><br><span class="line">        <span class="comment">// 并不是添加到队列的尾部之后就马上处于waiting状态了</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 如果当前节点的前置节点是head的话，如果等待head去唤醒老二的话，本来是没有问题的，</span></span><br><span class="line">            <span class="comment">// 不过如果唤醒的信号丢了怎么办？如果信号重发了又怎么办？</span></span><br><span class="line">            <span class="comment">// 简单点，还是让老二自己去抢吧，如果竞争到了就可以把当前的队头给回收掉，抢不到继续抢！</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 还需要注意的就是如果线程不是首次进入这里的话，比如被interrupt，那么也是可能执行到这里的，</span></span><br><span class="line">            <span class="comment">// 不过由于被唤醒后检查前置节点发现，前置节点并不是head，那么会再次睡眠！</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点的前置节点不是队首，或者是队首但是竞争失败的话就进入到此处</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果等待的过程中没有成功的获取到资源</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果节点不是老二节点，或者节点是老二节点，但是获取锁失败了，那么就会判断当前节点该不该park掉（<strong>非老二park掉</strong>，老二的话继续抢）。因此接下来可以看一下shouldParkAfterFailedAcquire方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取当前节点前置节点的状态，节点初始化状态是0，并不是SIGNAL</span></span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="comment">// 如果前置节点的状态时SIGNAL，则表示前面节点代表的线程成功获取到锁的时候会通知后记节点</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">         * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 前置节点的状态大于0，说明前置节点代表的线程被取消了，因此这里将会执行一个短路操作，</span></span><br><span class="line">        <span class="comment">// 把被取消的节点全都去掉，下面的循环操作就是这个意思</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">         * indicate retry.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 这里将直接再次进入cas操作</span></span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 如果前置节点的状态是0（排他锁的默认值） 或者-3（共享锁才会用到，暂不考虑），说明前置节点不具备唤醒的能力</span></span><br><span class="line">        <span class="comment">// 那么将前置节点的状态更改为SIGNAL，这里之所以使用cas的操作，可能是其他线程代表的节点把当前线程的前置节点给</span></span><br><span class="line">        <span class="comment">// 短路掉了，因此需要用cas操作</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 想一下，如果pred是head节点会发生什么？如果这一步成功的话，就意味着head节点又要unpark老二节点，</span></span><br><span class="line">        <span class="comment">// 如果失败了，那刚好又要进入cas的操作了</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果当前线程对应的节点的前置节点设置了SIGNAL，当前线程就具备了park的资格了，接下来就是park掉线程，然后返回当前线程是否在waiting之后收到了interrupt信号，无论是否收到都直接重置，在线程被再次唤醒并正确获取到锁之后通过selfInterrupt进行置位操作。至此加锁的整个过程已经完结了，这里还是稍微有点复杂，可以多看几遍，如果不懂得话。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>接下来看一下怕他锁的解锁过程，同加锁的过程是一样的，解锁方法的入口也是一个final类型的方法，这也就是说我们没办法重写这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同获取锁的过程tryAcquire一样，AQS给我们提供了tryRelease方法，我们可以通过实现该方法来释放锁，该方法也是空，这也是模板设计模式的体现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为是排他锁，这里持有锁的线程只可能有一个，因此我们不用考虑并发唤醒的问题，在head存在，并且head的状态非0的情况下，唤醒node节点的后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 此处的node为head节点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 将head节点的状态清除</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">     * non-cancelled successor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 遍历找到第一个符合条件的节点</span></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO 这里如果s又被另外的入队的线程短路了，不过还没有回收的话，就会出现唤醒一个无效的线程，不会出现问题么？</span></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 定向唤醒线程</span></span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是排他锁的加锁和解锁的过程，volatile结合cas操作在并发这一块应该是很常见的操作，这里AQS内置了一个volatile类型的state，如果state为0就会唤醒后继节点。</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>共享锁是多个线程可以同时获取到同一个锁。共享锁一般可以用于限制程序的并发度，这里比较经典的用例就是信号量了。还是先看一下AQS共享锁的加锁和解锁是什么样子的吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>废话就不多说了，我们通过重写tryAcquireShared(arg)方法尝试获取指定量的资源，获取失败则入队，知道获取到资源位置，这里如果前面的线程获取到的资源一定会导致state小于0的话，<strong>会不会导致后面的封装了线程的节点阻塞？？？</strong></p><p>在获取资源失败的情况下，将会执行doAcquireShared(arg)方法，该方法详细内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构造共享节点并加入到队尾</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h2 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h2><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>cas 操作带来的问题ABA的问题，如何解决。</p><h1 id="小节"><a href="#小节" class="headerlink" title="小节"></a>小节</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java 并发编程工具类之LockSupport</title>
      <link href="/2019/05/15/java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2019/05/15/java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在java中和并发相关的自然是锁了，前面的小节中我们看到的java给我们提供的语言级别的同步原语，下面我们会继续看一下java中的并发编程框架：AQS以及由此衍生而来的各种锁和工具类，不过在进入正题之前，我们还是先看一下支撑AQS框架的类，这样分析起来才有根据。</p><h1 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h1><p>在java中current包基于AQS框架，而AQS框架基于两个类：</p><ul><li>LockSupport：提供park、unpark操作（是Unsafe的一个代理，最终调用的还是Unsafe的park、unpark操作）</li><li>Unsafe ：提供CAS操作（一般是通过自旋的方式进行操作，这里的cas应该是使用TSL指令来完成的）</li></ul><p>在前面线程状态分析的总结中我们看到了locksupport的park操作最终会是的当前线程进去waiting状态，我们知道Object的wait方法也会使得当前线程进入waiting的状态，那么两者有什么区别呢？</p><ul><li>区别1：locksupport不需要当前线程获取到锁，其所做的操作就仅仅是暂停当前线程，而Object是需要在同步代码块中执行</li><li>区别2：locksupport操作的对象是线程，而Object的wait方法操作的对象是object（locksupport操作的过程有点像是线程内部包含了一个object，该object不共享，其作用和java的Object是类似的，下面将给出分析）</li><li>区别3：locksupport是精准打击（狙击），而Object是针对一片线程进行的打击（散弹），这样Object的notify最终唤醒的线程就不确定了</li></ul><h2 id="java-线程源码"><a href="#java-线程源码" class="headerlink" title="java 线程源码"></a>java 线程源码</h2><p>从线程源码的视角来看一下locksupport的park、unpark操作分别做了什么或许就比较好理解上文lockspport的park以及object的wait的区别了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">  Parker*    _parker;</span><br><span class="line">public:</span><br><span class="line">  Parker*     parker() &#123; return _parker; &#125;</span><br><span class="line"></span><br><span class="line">void JavaThread::initialize() &#123;</span><br><span class="line">  // Initialize fields</span><br><span class="line">  _parker = Parker::Allocate(this) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，在每一个java线程内部都包含了一个Parker对象，该对象内部维护了一个_counter变量，<strong>变量初始值为0，当我们调用park方法的时候，会将该变量置位为1，而当我们调用unpark的时候则将该变量进行复位，我们看到该变量起到的作用就是一个信号量的作用，</strong> <strong>不过该信号量无法积累，最大只能为1</strong>。类比Object的wait方法，该变量就好像是在java线程的内部保存了一个object变量，调用park操作的时候，就有点类似于调用该内部类object的wait方法，只不过park操作的对象是线程私有的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这里简单的分析了一下AQS所依赖的基本的类的操作，并通过线程源码的方式描述了locksupport的park、unpark在线程层面上的影响，后面如果有时间的话，再学习一下c++的基本语法，不然在往下分析就分析不动了</p><!--http://yizhanggou.top/javazhong-de/-->]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>synchronized原理分析</title>
      <link href="/2019/05/11/synchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
      <url>/2019/05/11/synchronized%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>前面我们介绍了线程相关的知识，接下来我们看一下java给我们提供的用于解决线程并发带来问题的关键字synchronized，之所以将其单独列出而不是和java中各种常见锁一起列出，是因为synchronized相对来说是比较独立的，其底层是jvm给我们提供的原语，而java中的锁则是基于AQS框架来实现的，因此本小节针对synchronized单独做一个总结。</p><h1 id="使用及原理分析"><a href="#使用及原理分析" class="headerlink" title="使用及原理分析"></a>使用及原理分析</h1><p>在开始讲述synchronized之前，我们先用一个例子引出synchronized的使用，假定有一个共享变量，我们启动两个线程执行变量的++操作，我们知道++操作并不是一个原子操作，在线程进入临界区执行操作更新共享变量的时候，如果没有加锁的话应该是有问题的，对应的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (x &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                i ++;</span><br><span class="line">                x ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">        SyncTest syncTest = <span class="keyword">new</span> SyncTest();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            syncTest.<span class="keyword">new</span> MyThread().start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.currentThread().sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多次测试，我们会发现执行的结果不定，当我们对run操作加上synchronized再看一下执行效果就会发现，最终值是一个确定的值(不过这里的synchronized应该需要锁住一个共享变量)，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (MyThread<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">            x ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果synchronized仅仅修饰的是run方法，那么得到的最终的结果仍然是不确定的，至于原因嘛：不同的线程进入临界区执行自增操作的时候获取到的锁不是同一个锁，所以这种方式并不能够实现真正的互斥操作，这里便涉及到synchronized的使用方式了。</p><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p>synchronized有三种使用方法，每种使用方法都针对了不同的作用域，接下来我们来看一下具体的使用过程</p><h3 id="普通同步方法"><a href="#普通同步方法" class="headerlink" title="普通同步方法"></a>普通同步方法</h3><p>下面三个方法本质上是一样的，对于第一个方法，多个线程在访问的时候会去抢同一把锁，该锁由当前对象持有，也就是new出来的SyncUsed对象，因此test与test1本质上是一样的，至于test2，则是将获取锁的对象一般化：既然多个线程争夺同一个SyncUsed对象持有的锁，为什么不能另一个对象的锁呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncUsed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以多考虑一下，如果由A、B、C三个线程如果A线程调用了test方法，B线程在同一时刻调用了test1方法，C线程又在同一时刻调用了test2方法，那么这三个线程会形成阻塞么？</p><p><strong>答案是test和test1会相互阻塞，均不会和test2形成阻塞。</strong>至于原因，我们会在讲解synchronized原理的时候讲解。</p><h3 id="静态同步方法"><a href="#静态同步方法" class="headerlink" title="静态同步方法"></a>静态同步方法</h3><p>对于静态同步方法，下面三个方法本质上也是一样的。synchronized修饰的是静态的方法，既然静态的，那肯定是全局的了，因此，这里的synchronized获取的是这个类的锁，所以这里的test与test1本质上也还是一样的，而test2的话则是更一般化的静态同步方法（使用了一个静态对象：静态的必定是全局的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncUsed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SyncUsed<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>同步代码块应该是我们最常用的一种同步机制了，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"say hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相信这一种同步的方式我们也不陌生了，这个在上面普通同步方法中我们也已经见过了，这几种方式的区别仅仅是synchronized修饰的作用域的区别。</p><p>上面我们讲述了synchronized的几种使用方式，总结一下其特点就是：当一个线程试图访问被synchronized修饰的方法的时候，首先会获取一个锁，当<strong>方法执行完成或者在运行的过程中抛出异常的时候会释放锁。</strong> 接下来我们来分析一下synchronized的原理。</p><h2 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h2><p>上面我们说到当一个线程试图访问synchronized修饰的方法的时候，会首先尝试获取锁，那么这个锁在哪里呢？这一切还要从对象说起，不是object，而是我们创建出来的对象！</p><h3 id="对象在内存中的布局"><a href="#对象在内存中的布局" class="headerlink" title="对象在内存中的布局"></a>对象在内存中的布局</h3><ul><li>对象头（header）<ul><li>markword<ul><li>哈希码</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有锁</li><li>偏向线程ID</li></ul></li><li>类型指针（指向类的元数据）</li><li>如果为数组，记录数组的长度</li></ul></li><li>实例数据</li><li>对齐填充：JVM要求对象的起始地址是8的整数倍，因此对象的大小必定也是8的整数倍，对于不足的要求通过对齐填充来解决</li></ul><p>下面以一张图来展示一下：<img src="//southrivers.github.io/2019/05/11/synchronized原理分析/object-analize.png" alt>如上，红色标出的就是对象头。</p><h4 id="oop-kclass模型"><a href="#oop-kclass模型" class="headerlink" title="oop-kclass模型"></a>oop-kclass模型</h4><p>为了加深我们对java中对象的认识，我们还是有必要探讨一下oop-kclass模型，不然说起来真的有点空洞。oop全称是ordinary object pointer（普通对象指针），该指针指向的是我们创建的java对象，Kclass包含元数据和方法信息，用来描述java类，其实正式我们的java.lang.Class对象在内存中的体现（因此可以大胆的推测Kclass存在于永久代中）。这里将创建的对象和描述对象元数据的信息分开很明显的一个好处就是节省了对象的空间。oop的类型是一个oopDesc<em>（这里的</em>是c++里面指针的一种写法，并不是笔误），在程序运行的过程中每创建一个对象，都会在jvm生成一个对应类型的oop对象，而对象指向生成的实例，我们的实例就是上面描述的对象，结构也就是上面的结构。对象头的类型为instanceOopDesc或者arrayOopDesc，instanceOopDesc对象头包含了markword和kclass*，具体结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">volatile markOop  _mark;</span><br><span class="line">  union _metadata &#123;</span><br><span class="line">    Klass*      _klass;</span><br><span class="line">    narrowKlass _compressed_klass;</span><br><span class="line">  &#125; _metadata;</span><br></pre></td></tr></table></figure><p>接下来我们看一下执行一个new A()操作在jvm的native层中到底发生了什么：首先，如果该类还没有被加载过，那么jvm会尝试加载该类，并在jvm内部创建一个instanceKclass对象用于表示类的运行时元数据，该对象的类型为Kclass。接下来在对象初始化的时候（不是类！不是类！不是类！），具体点就是A::<init>的时候，jvm就会创建一个instanceoopdesc对象，并填充相关字段。稍微具备一些jvm的知识，我们就可以知道在上面创建的对象中instanceKclass存在于永久代，而instanceOopDesc存在于jvm的对内存中。</init></p><h4 id="markword"><a href="#markword" class="headerlink" title="markword"></a>markword</h4><p>上面我们了解了jvm中采用的oop-kclass模型，接下来来看以下和synchronized相关的markword，毕竟这才是当前的重点。markOop 定义在markOop.hpp中，具体代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class markOopDesc: public oopDesc &#123;</span><br><span class="line"> private:</span><br><span class="line">  // Conversion</span><br><span class="line">  uintptr_t value() const &#123; return (uintptr_t) this; &#125;</span><br><span class="line"> public:</span><br><span class="line">  // Constants</span><br><span class="line">  enum &#123; age_bits                 = 4,  //分代年龄</span><br><span class="line">         lock_bits                = 2, //锁标识</span><br><span class="line">         biased_lock_bits         = 1, //是否为偏向锁</span><br><span class="line">         max_hash_bits            = BitsPerWord - age_bits - lock_bits - biased_lock_bits,</span><br><span class="line">         hash_bits                = max_hash_bits &gt; 31 ? 31 : max_hash_bits, //对象的hashcode</span><br><span class="line">         cms_bits                 = LP64_ONLY(1) NOT_LP64(0),</span><br><span class="line">         epoch_bits               = 2 //偏向锁的时间戳</span><br><span class="line">  &#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>我们用一张图来说明这些标记位的作用(该图来源于网络)<img src="//southrivers.github.io/2019/05/11/synchronized原理分析/object-header.png" alt>当我们使用synchronized(lock)获取锁的时候，其实是在争夺lock对象头的markword中的锁标识。锁标识位的具体含义如下：</p><ul><li>锁标识 lock=00 表示轻量级锁</li><li>锁标识 lock=10 表示重量级锁</li><li>偏向锁标识 biased_lock=1表示偏向锁</li><li>偏向锁标识 biased_lock=0且锁标识=01表示无锁状态</li></ul><h3 id="锁升级（或者锁膨胀）"><a href="#锁升级（或者锁膨胀）" class="headerlink" title="锁升级（或者锁膨胀）"></a>锁升级（或者锁膨胀）</h3><p>在JDK6之前，synchronized是一个重量级锁，重量级锁的性能损耗是比较大的，因此在JDK6之后做了相关的优化，锁的状态由之前的重量级锁变为：偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁，该过程也即是锁的升级。为了保障获取锁和释放锁的效率，锁的膨胀过程是不可逆的。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>具体过程可以参考 <a href="https://www.jianshu.com/p/43bc53c64d91" target="_blank" rel="noopener">https://www.jianshu.com/p/43bc53c64d91</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是synchronized的一些用法及锁升级的过程，相较于传统的锁机制以及一些工具类，synchronized的锁机制是相对独立的，因此单独介绍一下。<del>这里升级成重量级锁后对monitor的理解上不透彻，后续查阅相关资料之后再补充，另外源码分析也缺少</del></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程状态转换</title>
      <link href="/2019/05/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/"/>
      <url>/2019/05/07/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在之前的文章中我们分析了线程的由来及并发线程带来的问题，不过并没有针对线程的状态进行过多的分析，而只是针对进程的状态做了简要的介绍。本节就来介绍一下线程的状态及之间的状态转换。线程的状态相较于进程要稍微复杂一点，我们在描述进程状态的时候从是否持有cpu的角度来划分的，线程的话，除了cpu之外还要考虑的就是锁，也就是说影响线程状态的两个因素是：<strong>cpu和锁</strong></p><h1 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h1><p>还是用一张图来说明线程的状态转换，如下：<img src="//southrivers.github.io/2019/05/07/线程状态转换/thread-state-change.png" alt>java中线程的状态类的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread which has not yet started.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    NEW,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a runnable thread.  A thread in the runnable</span></span><br><span class="line"><span class="comment">     * state is executing in the Java virtual machine but it may</span></span><br><span class="line"><span class="comment">     * be waiting for other resources from the operating system</span></span><br><span class="line"><span class="comment">     * such as processor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RUNNABLE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">     * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">     * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">     * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    BLOCKED,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread.</span></span><br><span class="line"><span class="comment">     * A thread is in the waiting state due to calling one of the</span></span><br><span class="line"><span class="comment">     * following methods:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join() Thread.join&#125; with no timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#park() LockSupport.park&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;A thread in the waiting state is waiting for another thread to</span></span><br><span class="line"><span class="comment">     * perform a particular action.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * For example, a thread that has called &lt;tt&gt;Object.wait()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * on an object is waiting for another thread to call</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;Object.notify()&lt;/tt&gt; or &lt;tt&gt;Object.notifyAll()&lt;/tt&gt; on</span></span><br><span class="line"><span class="comment">     * that object. A thread that has called &lt;tt&gt;Thread.join()&lt;/tt&gt;</span></span><br><span class="line"><span class="comment">     * is waiting for a specified thread to terminate.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a waiting thread with a specified waiting time.</span></span><br><span class="line"><span class="comment">     * A thread is in the timed waiting state due to calling one of</span></span><br><span class="line"><span class="comment">     * the following methods with a specified positive waiting time:</span></span><br><span class="line"><span class="comment">     * &lt;ul&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #sleep Thread.sleep&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> Object#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> #join(long) Thread.join&#125; with timeout&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     *   &lt;li&gt;&#123;<span class="doctag">@link</span> LockSupport#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">     * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TIMED_WAITING,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Thread state for a terminated thread.</span></span><br><span class="line"><span class="comment">     * The thread has completed execution.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合上面的图和状态的定义我们从cpu和锁的角度来总结一下：</p><p>线程刚被创建出来的时候是处于<strong>new状态</strong>，在线程调用了start方法之后，就进入了<strong>runnable（就绪</strong>）的状态，这里就绪的意思是完事具备只差cpu（当然如果有锁的话肯定也是要获取锁了），在线程获取到了cpu之后，就处于运行的状态了（此处不知道为什么没有running状态），由于线程的层面上并不会像进程那样可以通过时钟中断来切换，因此需要有一种方式来让线程自己决定什么时候让出cpu，这个时候就用到了yield，不过yield只会让出cpu，并不会让出锁（如果有的话），上面在调用了start方法之后，在线程还没有处于runnable状态的时候，如果线程进入了一个被synchronized或者锁修饰的方法块的话，如果之前有线程正在当前这个代码块运行的话，那么当前这个线程也就没有办法获取到锁了，这个时候线程其实是处于<strong>block状态</strong>的，类比于进程，线程的block状态是除了cpu之外还在等待其他的资源，从这一点来看两者是一样的。处于runnable状态的线程，在没有锁的情况下，不能使用wait的方法，可以使用join、sleep方法，在有锁的情况下可以使用的方法：sleep、join、wait、park，至于不能使用wait方法的原因，是因为wait方法并不是thread提供的方法，而是Object方法提供的该方法要求当前线程要持有锁，因此只有处于运行状态的并且持有锁的线程才可以使用这个方法。对于持有锁的线程，我们看一下调用了这几个相关的方法后分别会发生什么。sleep、join会释放cpu，但是并不会释放锁，wait、park则会释放锁也会释放cpu。</p><h1 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h1><p><em>说明：线程的中断是一个不大不小的话题，后面如果有必要的话单独整理一篇，现在就放在这里了。</em></p><p>首先，线程的不应该由其他的线程中断或停止，试想一下如果一个获取了锁的线程还没有来得及释放锁突然被终止了，这会导致后面的线程都没有办法再次获取这个锁了，因此Thread的stop、suspend等方法都被废弃了，取而代之的是interrupt方法，不过这里的interrupt并不是中断或者停止线程，而是设置一个中断标记位，让被中断的线程在适当的时候自行决定如何处理。</p><p>我们可以将interrupt想像成一个邮箱，在调用当前线程的interrupt的时候有点像是给当前的线程发送了一封信件，告诉当前线程，你运行的时间太久了，要终止了！如果当前这个线程在waiting、timed_waiting状态（也就是并非运行的状态），那么当前这个线程会立即退出当前的状态，并抛出一个interruptException，这种情况下线程需要知道如何处理这种抛出的异常，或者抛出该异常让调用者来进行处理。如果当前这个线程处于运行的状态，那么，仅仅是当前线程的中断标志位会变为true，线程的正常运行并不会受到影响。那么问题来了，这个interrupt应该如何使用呢？</p><ul><li>方式1：interrupt中断的是线程的业务逻辑，需要线程周期性的检查自己的中断状态，线程需要对interruptException进行处理或者抛出给调用者进行处理</li><li>方式2：结合volatile来处理，这个时候通过周期性的检查该变量来判断是否需要终止，在线程退出之前可以选择将中断标记位清除（清除标记位可以理解为将信箱清空，方便接受后面再次发过来的信件）</li></ul><p>具体实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sync;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方式1</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">                <span class="comment">// 阻塞代码块，用于生成interruptException</span></span><br><span class="line">                sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"thread is running in block1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread is interrupt in block"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"clean up block1"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"====================="</span>);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 方式2</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(<span class="string">"block is running in block2"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"thread is interrupt in block2"</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"clean up block2"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------block2 stopped!----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        InterruptTest interruptTest = <span class="keyword">new</span> InterruptTest();</span><br><span class="line">        interruptTest.start();</span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        System.out.println(<span class="string">"start interrupt"</span>);</span><br><span class="line"></span><br><span class="line">        interruptTest.interrupt();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">3000</span>);</span><br><span class="line">        interruptTest.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的执行结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">thread is running in block1</span><br><span class="line">start interrupt</span><br><span class="line">thread is interrupt in block</span><br><span class="line">clean up block1</span><br><span class="line">=====================</span><br><span class="line">block is running in block2</span><br><span class="line">clean up block2</span><br><span class="line">block is running in block2</span><br><span class="line">clean up block2</span><br><span class="line">----------block2 stopped!----------</span><br></pre></td></tr></table></figure><p>个人觉得还是用volatile控制的力度会更好一点，不过二者都可以</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面针对线程的状态做了简要的分析以便后续查看，后面会根据实际的情况持续更新</p><p>参考文章：<a href="https://blog.csdn.net/pange1991/article/details/53860651" target="_blank" rel="noopener">https://blog.csdn.net/pange1991/article/details/53860651</a><a href="https://www.cnblogs.com/aspirant/p/8876670.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/p/8876670.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>线程小结</title>
      <link href="/2019/05/01/java-%E7%BA%BF%E7%A8%8B/"/>
      <url>/2019/05/01/java-%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在开始进入线程之前，我们还是先准备一下基础的知识，方便我们后面描述问题。</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>操作系统的核心是一个内核，独立于用户程序，其具备访问受限内存空间、底层资源的能力。为保障系统的安全，一般要求用户的程序不能直接访问这些资源，具体的实现方式就是：操作系统将寻址空间划分成内核空间和用户空间。对于一个32位的操作系统来说，其寻址空间位4G。其中用户空间由用户程序持有，内核空间由内核所持有。这里需要强调一下之所以划分空间是为了提高操作系统的稳定性和可用性。</p><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><p>上面我们了解了用户空间和内核空间的基础知识，接下来我们通过一个例子来说明一下用户态和内核态的概念：用户进程的启动必然是首先进入用户态，假定此时用户进程发起了一个系统调用：比如读取文件，那么应用也就从用户态切换到内核态，处于内核态的进程会读取文件到内核空间，然后将数据由内核空间拷贝到用户空间，最后应用从内核态切换回用户态。上面的切换过程是使用堆栈来保存中间变量，不同的空间会有不同的堆栈（用户空间有用户空间的堆栈，内核空间有内核空间的堆栈）。上面只是通过一个例子来说明用户态和内核态，严格的定义并没有说明，因此我们概括一下：<strong>运行在用户空间的进程即处于用户态，运行在内核空间的进程即处于内核态</strong>。</p><h1 id="进程-amp-线程"><a href="#进程-amp-线程" class="headerlink" title="进程 &amp; 线程"></a>进程 &amp; 线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程是一个正在执行的程序的实例，进程和程序的概念可以通过java里面对象和类的对比。一个进程包含了pcb和用于保存各种变量的内存空间，进程一般是通过时间片来实现程序调度的，不过这种调度不方便问题的追踪，因此引入了进程模型来简化相关的问题。简化后的模型是：每一个进程都单独有一个虚拟的的cpu。具体可以参考：<a href="https://www.youtube.com/watch?v=SszLFSAV_Ck，**后面可以继续补充这一块资料" target="_blank" rel="noopener">https://www.youtube.com/watch?v=SszLFSAV_Ck，**后面可以继续补充这一块资料</a>**<del>进程的层次结构及linux的fork不解（待补充）</del></p><p>进程的状态：</p><ul><li>创建</li><li>就绪：万事俱备，只欠cpu</li><li>阻塞：除cpu之外，还在等待其他资源</li><li>运行：占据cpu，并处于执行的状态</li><li>终止 </li></ul><p>如上面进程的状态中创建和终止是比较好理解的，不太好理解的就是就绪和阻塞，两者的区别已经在上面给出了。</p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>上面我们给出了进程的一些基本概念。进程用于资源的聚集，线程才是cpu调度的基本单元（对于早期的单批道计算机可以认为是单线程的进程）。每一个线程包含了：</p><ul><li>程序计数器：用于记录线程执行到哪里了</li><li>堆栈：用于暂存一些未返回的调用过程（程序返回地址、方法内的临时变量）</li><li>寄存器：用于暂存执行过程中的临时变量，是高速缓存</li></ul><p>线程的状态和进程的状态是对应起来的，因此这里也就不再重复了。多线程技术可以提高程序并发执行的效率，但是却不一定会提高cpu的利用率，原因在于多线程增加了cpu切换的开销，如果每个线程都是cpu密集型，那么多线程会带来很大的开销，而如果多线程中包含了大量的IO操作，多线程通过线程的重叠交叉可以很好的提高进程的执行速度，同进程的模型一致，线程的模型是：每一个线程单独拥有一个cpu。这种简化的模型的好处就是可以大大的简化cpu切换所带来的复杂性。</p><p>对比进程共享磁盘、物理内存、打印机等各种基础设备，线程则是贡献进程持有的资源，因此线程也可以看作轻量级的进程。</p><p>posix线程模型：</p><ul><li>thread_create：线程的创建</li><li>thread_exit：线程的退出</li><li>thread_join：调用线程阻塞等待当前线程执行完成</li><li>thread_yield：调用线程让出cpu，之所以出现这种情况是因为线程不像进程那样存在时钟中断的机制，因此需要有一种方式来放弃cpu的权限，而yield就是这种方式</li></ul><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><h4 id="用户空间线程"><a href="#用户空间线程" class="headerlink" title="用户空间线程"></a>用户空间线程</h4><p>用户空间线程是将整个线程包放在用户空间中，内核空间对此一无所知，这样的好处是：可以在不支持线程的操作系统上实现，用户空间负责管理线程（每一个进程维护一个线程表类似于内核空间的pcb，用于记录线程的各种属性），可以定制调度线程的算法，另外，由于线程切换的时候调用的都是本地过程，因此相较于内核态也会有较高的效率</p><h4 id="内核空间线程"><a href="#内核空间线程" class="headerlink" title="内核空间线程"></a>内核空间线程</h4><p>内核空间线程是将整个线程包放在内核空间中，用户空间对此一无所知，由于在内核空间中创建和销毁线程的代价都是比较大的，因此一般是采用回收线程的方式来复用。</p><p>一种更好的实现线程的方式是将用户空间线程和内核空间线程通过多路复用结合起来，这样可以综合二者的优点。</p><h3 id="线程带来的问题"><a href="#线程带来的问题" class="headerlink" title="线程带来的问题"></a>线程带来的问题</h3><p>上面我们介绍了线程的基础知识，接下来我们看一下多线程所带来的问题，并通过这些问题一步步引出我们最关心的对象：<strong>锁</strong>。两个或者多个线程可以读写共享数据，而最终的结果则取决于执行的时许，这称作竞争条件。解决这种竞争条件的方式是通过互斥，我们把访问共享内存的程序片段称为临界区，如果能够通过互斥使得多个线程不会同时出现在临界区就可以避免这种问题。</p><h3 id="互斥的方式"><a href="#互斥的方式" class="headerlink" title="互斥的方式"></a>互斥的方式</h3><h4 id="忙等待互斥（以下的方式都有忙等待的特点）"><a href="#忙等待互斥（以下的方式都有忙等待的特点）" class="headerlink" title="忙等待互斥（以下的方式都有忙等待的特点）"></a>忙等待互斥（以下的方式都有忙等待的特点）</h4><ul><li><p>屏蔽中断：线程在cpu上执行的时候，设置cpu屏蔽中断，这样当有新的线程想要获取cpu的执行权的时候就不得不等待，这种方式仅适用于单核的cpu，而且操作的权利太大，对于操作系统本身来说比较有用，而对于用户进程并没有太大的好处。</p></li><li><p>锁变量：设置一个标志位，通过标志位来决定是否让线程进入临界区，这种方式也会由于比较和设置操作的非原子性而出现问题，具体的解决方式参见后面的TSL</p></li><li><p>严格轮换法：设置一个整形变量，只有其值和当前线程的特征值（比如线程id）相同的时候才允许线程进入，如果不一致，则当前线程一直测试并等待。不过假定a线程处于就绪状态，但是flag=b，而此时b触发了系统调用如读取磁盘，那么b线程当前其实是处于阻塞的状态，不过由于flag的作用导致a线程还是没有办法获取到cpu，因此最终就会导致阻塞的线程阻塞了就绪的线程</p></li><li><p>皮特森互斥算法：这种方法是通过锁变量+告警变量的方式来实现的不需要严格轮转法也可以互斥访问临界资源的方式。具体方式如下：<img src="//southrivers.github.io/2019/05/01/java-线程/perterson.png" alt>既然是互斥算法，那么肯定是存在互斥条件的，也即是：满足非A即B。我们就从这里入手，看一下如果有两个线程进入的话这里的变量分别会发生什么变化：<img src="//southrivers.github.io/2019/05/01/java-线程/p-exclude.png" alt>如果两者都处于临界区，则interested必然全部为true，但是turn只有前面的一个才有效，因此通过turn确保了锁的功能，这里的<code>interested[other]</code>则是为了实现阻塞的功能。如果只有interested的话，会出现的一种情况是死锁，而单纯的turn则无法保证锁的功能。</p></li><li><p>TSL指令：TSL指令全称是test and set lock（测试并加锁），该指令需要硬件设备的支持。具体一点就是将内存字读取到寄存器中，然后在内存字中写入一个新的非零值。整个操作是一个原子的，即便是运行在多核的cpu的情况下（通过内存总线锁来实现），要注意的是锁住内存总线并不等同于屏蔽中断，屏蔽中断是针对cpu的，在多核的情况下屏蔽中断并不能保证执行的原子性。<img src="//southrivers.github.io/2019/05/01/java-线程/tsl.png" alt></p></li></ul><p>以上各种实现互斥的方式都有一个特点：忙等待！也就是在获取到cpu的时候，等待的线程一直通过自旋的方式尝试获取cpu，这种自旋操作会浪费cpu资源（<strong>自旋并不是获取不到cpu，而是获取不到临界区资源的权利</strong>），一种比较好的方式是在无法获取到临界区资源的时候进入阻塞的状态，等待被唤醒。因此接下来即将引入<strong>新的实现互斥的方式：睡眠与唤醒！</strong></p><h4 id="睡眠与唤醒"><a href="#睡眠与唤醒" class="headerlink" title="睡眠与唤醒"></a>睡眠与唤醒</h4><p>首先我们通过一个例子来演示一下如何通过睡眠与唤醒来实现临界区的互斥，如下：<img src="//southrivers.github.io/2019/05/01/java-线程/p-c.png" alt>上面程序的整体思路是当队列长度为0的时候，消费者睡眠，然后发起一个信号唤醒生产者，当队列的长度满的时候，生产者睡眠，然后发起一个信号给消费者。不过这个过程存在一个缺陷：如果队列长度为0的时候，消费者发送了一个信号，不过当前生产者是上次生产任务的收尾处，也就是说已经生产了数据但是被消费者取走了，此时生产者处于就绪的状态，当信号到达的时候刚好又调度到运行的状态，那么该信号就会丢失，也即意味着生产者将会进入睡眠的状态，而此时生产者已经进入了休眠的状态，那么最终的结果就是生产者和消费者都进入了休眠的状态，整个进程就处于僵死的状态。</p><p>上面问题出现的原因是由于在唤醒的过程中出现了信号的丢失，如果信号不丢失而是最终保存在一个标记位上，那么这个问题就会得到解决，不过一个标记位仅能解决两个线程间的通信问题，如果有更多的线程进行通信的话就需要增加新的标记位。</p><p>为了解决上面的信号丢失的问题，引入了<strong>信号量</strong>：使用一个整形变量来记录唤醒的次数。信号量支持两种操作：up、down，为了保障信号量能够正常工作，需要能够以原子的方式执行上面的两种操作（不然又可能出现新的多线程更新的问题）。这里一般是<strong>使用TSL的方式来保障操作的原子性</strong>，上面我们看到TSL其实是一个忙等待的过程，不过这个过程相对来说是一个轻量级的操作，执行速度很快，因为该过程只涉及寄存器和内存字的读写操作，并不涉及其他的用户操作，代码如下：<img src="//southrivers.github.io/2019/05/01/java-线程/semp.png" alt>在上面的过程中使用到了3个信号量，其中mutex是为了实现互斥的方式进入临界区的，而剩下的信号量实现的则是计数的功能！</p><p>如果不需要计数的功能，而只需要互斥的功能，上面的过程可以简化成只需要一个信号量mutex：信号量取消计数功能退化成<strong>排他锁</strong>！下面就是排他锁的TSL实现：<img src="//southrivers.github.io/2019/05/01/java-线程/exclusive-lock.png" alt>这里我们可以看到该过程和TSL的忙等待很像，不过不同的是在获取不到锁的时候其并不是忙等待，而是调用了thread_yield的方法，该方法会让出cpu，等待下一次调度来临的时候再去竞争锁。</p><h3 id="pthread中的互斥"><a href="#pthread中的互斥" class="headerlink" title="pthread中的互斥"></a>pthread中的互斥</h3><p>pthread提供了许多可以用来线程同步的函数：1、互斥量：互斥量在允许或者阻塞对临界区资源的访问上很有用（临界区资源的访问）2、条件变量：允许线程在没有到达一定的条件而阻塞通常的使用方式是两者相互配合<img src="//southrivers.github.io/2019/05/01/java-线程/use-pattern.png" alt>结合上面的信号量可以强化我们的认识。<del><strong>最后需要强调的是条件变量不会丢失！！！！！</strong></del></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>最后我们稍微提及一下管程，管程是保证在管程之内只会出现一个线程的一种计数（也即是互斥），管程的互斥由编译器负责，进入之后由条件变量负责唤醒</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上我们通过对线程的介绍，慢慢引入线程所带来的问题，并通过解决这些多线程问题一步一步的引入了自旋锁、信号量（up、down操作）、互斥量、条件（及两个相关的操作signal、wait），后面我们会进一步的探讨java中的同步机制（synchronized）、锁（AQS）、一些并发编程的工具类（LockSupport）以及通信的原语。</p><p>线程上等待的队列维护在JVM上</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>springmvc 解析</title>
      <link href="/2019/04/12/springmvc-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
      <url>/2019/04/12/springmvc-%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>提到spring mvc，很多初学者都会和spring搞混，前几篇文章分析了和web相关的tomcat、spring等源码，现在来看一下spring mvc吧。</p><h1 id="原理解剖"><a href="#原理解剖" class="headerlink" title="原理解剖"></a>原理解剖</h1><p>正如Spring 起始于xml，我们的web应用起始于web.xml。而web.xml中最重要的配置就是listener和servlet了，在分析tomcat源码的时候，我们已经看到了listener的作用，接下来就来看一下servlet吧。</p><p><strong>spring mvc框架是依托于spring容器的</strong>。在加载完listener之后，容器将会加载load-on-startup为非负数的servlet，通常情况下就是我们的dispatcherservlet了，dispatcherservlet在初始化的过程中会建立一个自己的IOC容器上下文：servletWebApplicationContext，并会以contextLoaderListener建立的Root上下文作为自己的父级上下文（这里上下文可以理解为容器）。dispatcherservlet持有的上下文默认是xmlwebapplicationContext，servlet有自己的bean空间，同时还可以访问到父容器空间。<img src="//southrivers.github.io/2019/04/12/springmvc-源码剖析/springmvc-ioc.png" alt></p><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="DispatcherServlet"><a href="#DispatcherServlet" class="headerlink" title="DispatcherServlet"></a>DispatcherServlet</h2><p>上文我们了解到web应用启动的过程中会创建的容器及流程，接下来我们来看一下最核心的类dispatcherservlet。dispatcherservlet是spring mvc中最为核心的类，起到前置控制器的作用，负责请求的分发。其类的继承关系图如下：<img src="//southrivers.github.io/2019/04/12/springmvc-源码剖析/class.png" alt>上图可以发现dispatcherservlet本质上也是一个servlet，既然是servlet，那么肯定也是有固定的生命周期。</p><ul><li>初始化</li><li>处理请求</li><li>销毁</li></ul><p>我们分别来看一下这些阶段都做了那些事情吧</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化方法存在于HttpServletBean中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的过程是读取init-param中的参数设置到dispatcherservlet中，并配置相关的bean，完成之后调用initServletBean来创建servletwebApplicationContext，其中initServletBean方法在FrameworkServlet重写了，这些也是通用的模板方法模式。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">....</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化springmvc所需要的容器</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        <span class="comment">// 扩展方法：实现为空</span></span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A context instance was injected at construction time -&gt; use it</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance was injected at construction time -&gt; see if one</span></span><br><span class="line">        <span class="comment">// has been registered in the servlet context. If one exists, it is assumed</span></span><br><span class="line">        <span class="comment">// that the parent context (if any) has already been set and that the</span></span><br><span class="line">        <span class="comment">// user has performed any initialization such as setting the context id</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        onRefresh(wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line">                    <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tomcat在启动的过程中会通过contextloaderlistener来创建一个webapplicationContext，然后将其作为一个字段存放在servletContext中。上面initWebApplicationContext的主要过程就是获取这个webapplicationcontext，并将其设置为当前容器的父容器，接下来会调用onRefresh方法，这个方法最终会初始化我们的servlet，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一步会初始化就我们当前容器中所需要的一些java bean了，这里是子容器java bean的初始化。</p><h3 id="处理请求"><a href="#处理请求" class="headerlink" title="处理请求"></a>处理请求</h3><p>续接上文，我们已经大概清楚dispatcherservlet的初始化流程，以及初始化的时候都会初始化哪些资源了，接下来我们看一下一个请求的处理过程。我们知道servlet请求的处理起始于service方法（service方法可以认为是一个门面类，最终请求的处理肯定是落到doGet、doPost等方法中），在dispatcherservlet中该方法的实现在FrameworkServlet类中。所有的处理最终都会经过的方法FrameworkServlet的processRequest：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">    LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext();</span><br><span class="line">    LocaleContext localeContext = buildLocaleContext(request);</span><br><span class="line"></span><br><span class="line">    RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">    ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes);</span><br><span class="line"></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">    asyncManager.registerCallableInterceptor(FrameworkServlet<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">new</span> <span class="title">RequestBindingInterceptor</span>())</span>;</span><br><span class="line"></span><br><span class="line">    initContextHolders(request, localeContext, requestAttributes);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        doService(request, response);</span><br><span class="line">    &#125;......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        resetContextHolders(request, previousLocaleContext, previousAttributes);</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestAttributes.requestCompleted();</span><br><span class="line">        &#125;.....</span><br><span class="line"></span><br><span class="line">        publishRequestHandledEvent(request, response, startTime, failureCause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码是final类型的，可以看到请求的处理过程大致如下：</p><ul><li>调用initContextHolders将获取到的请求相关的参数绑定到线程上</li><li>调用doService方法处理请求</li><li>重置与线程绑定的信息，然后发布请求处理完成的事件</li></ul><p>可以看到核心代码还在doService方法中(在dispatcherServlet中实现的)，doService最终会进入doDispatch方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">HttpServletRequest processedRequest = request;</span><br><span class="line">HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">processedRequest = checkMultipart(request);</span><br><span class="line">multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler for the current request.</span></span><br><span class="line">mappedHandler = getHandler(processedRequest);</span><br><span class="line"><span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">noHandlerFound(processedRequest, response);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"><span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line"><span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line"><span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Last-Modified value for ["</span> + getRequestUri(request) + <span class="string">"] is: "</span> + lastModified);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applyDefaultViewName(processedRequest, mv);</span><br><span class="line">mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">&#125;.....</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">&#125;.....</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line"><span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line"><span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">cleanupMultipart(processedRequest);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的大致流程是：</p><ul><li><p>通过getHandler从HandleMapping找到该请求对应的Handler</p></li><li><p>通过getHandlerAdapter获取找到对应的HandlerAdapter</p></li><li><p>判断是否有拦截器，如果有执行applyPreHandle</p></li><li><p>handlerAdapter会进行处理请求并返回ModelAndView，此处就会将请求发送到对应的controller</p></li><li><p>接下来判断是否有后置拦截器，如果有则调用applyPostHandle进行增强</p></li><li><p>最后会调用processDispatchResult，这个方法又分为以下几个步骤：</p><ul><li>通过viewResolver获取响应的View（视图）</li><li>根据获取的视图进行渲染页面，具体的就是调用view的render方法进行页面的渲染</li></ul></li></ul><p>相关的流程图如下：<img src="//southrivers.github.io/2019/04/12/springmvc-源码剖析/process.png" alt></p><h3 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h3><p>销毁流程比较简单，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">"Destroying Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    <span class="comment">// Only call close() on WebApplicationContext if locally managed...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext <span class="keyword">instanceof</span> ConfigurableApplicationContext &amp;&amp; !<span class="keyword">this</span>.webApplicationContextInjected) &#123;</span><br><span class="line">        ((ConfigurableApplicationContext) <span class="keyword">this</span>.webApplicationContext).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是关闭当前容器，因此也可以知道，只有我们的容器关闭了，dispatcherservlet才会销毁</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面对spring mvc的流程进行了初步的分析，方便后面回顾，到此Spring相关的东西可以告一段落了。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>tomcat 概述</title>
      <link href="/2019/04/01/tomcat-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2019/04/01/tomcat-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<!-- # 概述工作过程中使用的最多的技术就是spring了，虽然断断续续有了解过spring相关的知识，但是对于tomcat怎么唤醒spring应用一直不是太清楚，因此决定抽时间来专门研究一下。# tomcat概述## 基本结构tomcat的结构和server.xml是对应起来的，如下为tomcat基本结构：![](tomcat-启动流程概述/tomcat-stru.png)- server:代表整个服务器，一个server包含多个service- service：代表一个web服务，包含一个或多个connector和一个container或者说engine- connector：代表一个网络连接，或者可以认为是一个文件句柄，用于接受并处理网络请求- container：container或者说engine，代表了service的请求处理器，负责分发和处理由connector转发过来的请求（其实就是封装和管理servlet：终于对应到我们的Spring mvc了）在engine的内部其实还包含了host，engine在接收到请求的时候会把http请求头对应的host映射到host容器## 请求流程分析### connector流程分析![](tomcat-启动流程概述/connector.png)connector使用protocolHandler来处理请求，其中protocolHandler包含了3个部分- endpoint：用于接收tcp的请求（acceptor用于接受请求，Handler用于处理请求、asynctimeout用于检查请求是否超时）- processor：用于将从endpoint接收到的数据转换成request- adapter：将请求适配到servlet容器进行处理这里涉及到endpoint通过TCP协议从网络上读取数据，接着是processor将数据封装成http报文--><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>使用Spring 开发已经有一段时间了，偶尔会有个疑问，我们的工程从什么时候开始执行的？然后就在网上不停的搜索相关的资料，然而网上更多的文章是讲解spring ioc的，再深入一点的就是讲解web.xml的contextLoaderListener，然后讲解也是虎头蛇尾，模棱两可，经历了阵痛之后，忽然想到我们的spring工程都是要运行在tomcat中，那么应该是在tomcat中唤醒的吧，网上一搜果然如此，因此花了点事件来看了一下Tomcat的源码，既然是java工程，那么应该是有个main函数作为启动整个应用的入口，该入口就在BootStrap类中</p><h1 id="代码走读"><a href="#代码走读" class="headerlink" title="代码走读"></a>代码走读</h1><h2 id="万物之始-main函数"><a href="#万物之始-main函数" class="headerlink" title="万物之始-main函数"></a>万物之始-main函数</h2><p>无论多么复杂的工程，总是有一个入口吧，对于java工程来说，大概就是我们的main函数了吧，嗯，进去看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (daemon == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Don't set daemon until init() has completed</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bootstrap.init();</span><br><span class="line">            &#125; </span><br><span class="line">               .....</span><br><span class="line">            daemon = bootstrap;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// When running as a service the call to stop will be on a new</span></span><br><span class="line">            <span class="comment">// thread so make sure the correct class loader is used to prevent</span></span><br><span class="line">            <span class="comment">// a range of class not found exceptions.</span></span><br><span class="line">            Thread.currentThread().setContextClassLoader(daemon.catalinaLoader);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String command = <span class="string">"start"</span>;</span><br><span class="line">            <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                command = args[args.length - <span class="number">1</span>];</span><br><span class="line">            &#125;....</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (command.equals(<span class="string">"start"</span>)) &#123;</span><br><span class="line">                daemon.setAwait(<span class="keyword">true</span>);</span><br><span class="line">                daemon.load(args);</span><br><span class="line">                daemon.start();</span><br><span class="line">            &#125; .......</span><br><span class="line">        &#125; ......</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面我们省去了大部分代码，由于我们现在只关心tomcat的启动，因此也把tomcat的其他的操作选项都去掉了。整个启动流程做了一下几件事：</p><ul><li>创建bootstrap对象，并调用init方法初始化类加载器，其中做的最重要的事情就是通过反射的方式创建了一个Catalina对象，并将其设置为catalinaDeamon，具体代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化容器中要用到的类加载器</span></span><br><span class="line">        initClassLoaders();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 既然是上下文，那么必然是整个应用公共的变量，设置公共变量的类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(catalinaLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用catalinaLoader预加载对应的类</span></span><br><span class="line">        SecurityClassLoad.securityClassLoad(catalinaLoader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load our startup class and call its process() method</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"Loading startup class"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载catalina实现类并实例化catalina对象</span></span><br><span class="line">        Class&lt;?&gt; startupClass =</span><br><span class="line">            catalinaLoader.loadClass</span><br><span class="line">            (<span class="string">"org.apache.catalina.startup.Catalina"</span>);</span><br><span class="line">        Object startupInstance = startupClass.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the shared extensions class loader</span></span><br><span class="line">        <span class="comment">// 设置Catalina父类加载器</span></span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled())</span><br><span class="line">            log.debug(<span class="string">"Setting startup class properties"</span>);</span><br><span class="line">        String methodName = <span class="string">"setParentClassLoader"</span>;</span><br><span class="line">        Class&lt;?&gt; paramTypes[] = <span class="keyword">new</span> Class[<span class="number">1</span>];</span><br><span class="line">        paramTypes[<span class="number">0</span>] = Class.forName(<span class="string">"java.lang.ClassLoader"</span>);</span><br><span class="line">        Object paramValues[] = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        paramValues[<span class="number">0</span>] = sharedLoader;</span><br><span class="line">        Method method =</span><br><span class="line">            startupInstance.getClass().getMethod(methodName, paramTypes);</span><br><span class="line">        method.invoke(startupInstance, paramValues);</span><br><span class="line"></span><br><span class="line">        catalinaDaemon = startupInstance;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码主要部分都已经注释了，最核心的就是<code>initClassLoaders()</code>构建了类加载器的父子关系用于实现不同应用不同jar包的命名空间的隔离，并通过反射实例化了Catalina对象，而该对象持有一个变量server（<strong>还没有初始化，初始化的过程是在加载解析server.xml的过程中做的</strong>）。</p><ul><li><p>bootstrap类的load方法最终会通过反射调用catalina的load方法，该方法主要是解析server.xml并创建容器，并将根结点对应的容器设置为catalina的server变量，对应的server.xml文件如下：</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='utf-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Server</span> <span class="attr">port</span>=<span class="string">"8005"</span> <span class="attr">shutdown</span>=<span class="string">"SHUTDOWN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.startup.VersionLoggerListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.AprLifecycleListener"</span> <span class="attr">SSLEngine</span>=<span class="string">"on"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Prevent memory leaks due to use of particular java/javax APIs--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.JreMemoryLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.mbeans.GlobalResourcesLifecycleListener"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Listener</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.core.ThreadLocalLeakPreventionListener"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Resource</span> <span class="attr">name</span>=<span class="string">"UserDatabase"</span> <span class="attr">auth</span>=<span class="string">"Container"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">"org.apache.catalina.UserDatabase"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">description</span>=<span class="string">"User database that can be updated and saved"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">factory</span>=<span class="string">"org.apache.catalina.users.MemoryUserDatabaseFactory"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">pathname</span>=<span class="string">"conf/tomcat-users.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">GlobalNamingResources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Service</span> <span class="attr">name</span>=<span class="string">"Catalina"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8009"</span> <span class="attr">protocol</span>=<span class="string">"AJP/1.3"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">"Catalina"</span> <span class="attr">defaultHost</span>=<span class="string">"localhost"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.LockOutRealm"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Realm</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.realm.UserDatabaseRealm"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">resourceName</span>=<span class="string">"UserDatabase"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Realm</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">"localhost"</span>  <span class="attr">appBase</span>=<span class="string">"webapps"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">"true"</span> <span class="attr">autoDeploy</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Valve</span> <span class="attr">className</span>=<span class="string">"org.apache.catalina.valves.AccessLogValve"</span> <span class="attr">directory</span>=<span class="string">"logs"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">prefix</span>=<span class="string">"localhost_access_log"</span> <span class="attr">suffix</span>=<span class="string">".txt"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">pattern</span>=<span class="string">"%h %l %u %t <span class="symbol">&amp;quot;</span>%r<span class="symbol">&amp;quot;</span> %s %b"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Host</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><pre><code>对应解析、初始化代码如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void load() &#123;</span><br><span class="line"></span><br><span class="line">。。。。。。。。。。。</span><br><span class="line">        // Create and execute our Digester</span><br><span class="line">        // 创建解析server.xml文件的解析器</span><br><span class="line">        Digester digester = createStartDigester();</span><br><span class="line"></span><br><span class="line">        。。。。。。。。。。。</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                inputSource.setByteStream(inputStream);</span><br><span class="line">                digester.push(this);</span><br><span class="line">                digester.parse(inputSource);</span><br><span class="line">            &#125; 。。。。。。。。。</span><br><span class="line">        // Start the new server</span><br><span class="line">        try &#123;</span><br><span class="line">            getServer().init();</span><br><span class="line">        &#125; 。。。。。。</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="已省略不重要的部分，上述load的过程大致可以分成："><a href="#已省略不重要的部分，上述load的过程大致可以分成：" class="headerlink" title="已省略不重要的部分，上述load的过程大致可以分成："></a>已省略不重要的部分，上述load的过程大致可以分成：</h2><pre><code>- 创建digester解析起用于解析对应的server.xml文件，并创建文件中所包含的容器- 获取catalina对应的server并执行init方法进行初始化，对应的init方法如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    @Override</span><br><span class="line">public final synchronized void init() throws LifecycleException &#123;</span><br><span class="line">    ........</span><br><span class="line">    setStateInternal(LifecycleState.INITIALIZING, null, false);</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        initInternal();</span><br><span class="line">    &#125; ........</span><br><span class="line">    setStateInternal(LifecycleState.INITIALIZED, null, false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到上述对应容器初始化的过程中首先是设置容器的状态，这个操作会使得当前容器对应的listener监听到当前容器状态的数据，进而唤醒内层容器初始化的过程，最终通过层层的递归调用到最内层容器状态的设置，然后再依次由内而外的调用相关容器的`initInternal`方法，值得一提的是`initInternal`是采用了模板的模式，具体的实现是放到了不同的容器中。上述递归调用的最内层的容器就是`StandardContext`，该容器的初始化会触发ContextConfig的方法调用，其中ContextConfig也是listener的一种实现，有兴趣的话可以查询相关类的继承关系。如下为ContextConfig接收到相关消息之后的处理方法调用：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public void lifecycleEvent(LifecycleEvent event) &#123;</span><br><span class="line">    ........</span><br><span class="line">    // Process the event that has occurred</span><br><span class="line">    if (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">        configureStart();</span><br><span class="line">    &#125; else if (event.getType().equals(Lifecycle.BEFORE_START_EVENT)) &#123;</span><br><span class="line">        beforeStart();</span><br><span class="line">    &#125; else if (event.getType().equals(Lifecycle.AFTER_START_EVENT)) &#123;</span><br><span class="line">        // Restore docBase for management tools</span><br><span class="line">        if (originalDocBase != null) &#123;</span><br><span class="line">            context.setDocBase(originalDocBase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (event.getType().equals(Lifecycle.CONFIGURE_STOP_EVENT)) &#123;</span><br><span class="line">        configureStop();</span><br><span class="line">    &#125; else if (event.getType().equals(Lifecycle.AFTER_INIT_EVENT)) &#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125; else if (event.getType().equals(Lifecycle.AFTER_DESTROY_EVENT)) &#123;</span><br><span class="line">        destroy();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面的方法我们主要关注`configureStart`方法即可，该方法比较长，最终会进入核心方法`webConfig`的调用:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">webConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * Anything and everything can override the global and host defaults.</span></span><br><span class="line"><span class="comment">        * This is implemented in two parts</span></span><br><span class="line"><span class="comment">        * - Handle as a web fragment that gets added after everything else so</span></span><br><span class="line"><span class="comment">        *   everything else takes priority</span></span><br><span class="line"><span class="comment">        * - Mark Servlets as overridable so SCI configuration can replace</span></span><br><span class="line"><span class="comment">        *   configuration from the defaults</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * The rules for annotation scanning are not as clear-cut as one might</span></span><br><span class="line"><span class="comment">        * think. Tomcat implements the following process:</span></span><br><span class="line"><span class="comment">        * - As per SRV.1.6.2, Tomcat will scan for annotations regardless of</span></span><br><span class="line"><span class="comment">        *   which Servlet spec version is declared in web.xml. The EG has</span></span><br><span class="line"><span class="comment">        *   confirmed this is the expected behaviour.</span></span><br><span class="line"><span class="comment">        * - As per http://java.net/jira/browse/SERVLET_SPEC-36, if the main</span></span><br><span class="line"><span class="comment">        *   web.xml is marked as metadata-complete, JARs are still processed</span></span><br><span class="line"><span class="comment">        *   for SCIs.</span></span><br><span class="line"><span class="comment">        * - If metadata-complete=true and an absolute ordering is specified,</span></span><br><span class="line"><span class="comment">        *   JARs excluded from the ordering are also excluded from the SCI</span></span><br><span class="line"><span class="comment">        *   processing.</span></span><br><span class="line"><span class="comment">        * - If an SCI has a @HandlesType annotation then all classes (except</span></span><br><span class="line"><span class="comment">        *   those in JARs excluded from an absolute ordering) need to be</span></span><br><span class="line"><span class="comment">        *   scanned to check if they match.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        WebXmlParser webXmlParser = <span class="keyword">new</span> WebXmlParser(context.getXmlNamespaceAware(),</span><br><span class="line">                context.getXmlValidation(), context.getXmlBlockExternal());</span><br><span class="line"></span><br><span class="line">        Set&lt;WebXml&gt; defaults = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        defaults.add(getDefaultWebXmlFragment(webXmlParser));</span><br><span class="line"></span><br><span class="line">        WebXml webXml = createWebXml();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Parse context level web.xml</span></span><br><span class="line">        InputSource contextWebXml = getContextWebXmlSource();</span><br><span class="line">        <span class="keyword">if</span> (!webXmlParser.parseWebXml(contextWebXml, webXml, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            ok = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServletContext sContext = context.getServletContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ordering is important here</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 1. Identify all the JARs packaged with the application and those</span></span><br><span class="line">        <span class="comment">// provided by the container. If any of the application JARs have a</span></span><br><span class="line">        <span class="comment">// web-fragment.xml it will be parsed at this point. web-fragment.xml</span></span><br><span class="line">        <span class="comment">// files are ignored for container provided JARs.</span></span><br><span class="line">        Map&lt;String,WebXml&gt; fragments = processJarsForWebFragments(webXml, webXmlParser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 2. Order the fragments.</span></span><br><span class="line">        Set&lt;WebXml&gt; orderedFragments = <span class="keyword">null</span>;</span><br><span class="line">        orderedFragments =</span><br><span class="line">                WebXml.orderWebFragments(webXml, fragments, sContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 3. Look for ServletContainerInitializer implementations</span></span><br><span class="line">        <span class="comment">// 核心方法：扫描所有的jar包，并收集ServletContainerInitializer相关的实现类，在收集的过程中会实现了该接口类上面@HandleTypes中指定的类相关的信息，最终形成一个Map&lt;SCI,Class&lt;handletypes&gt;&gt;的map集合，这个集合尤其重要，会在后面看到如何唤醒web应用的</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            processServletContainerInitializers();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>  (!webXml.isMetadataComplete() || typeInitializerMap.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Step 4. Process /WEB-INF/classes for annotations and</span></span><br><span class="line">            <span class="comment">// @HandlesTypes matches</span></span><br><span class="line">            Map&lt;String,JavaClassCacheEntry&gt; javaClassCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                WebResource[] webResources =</span><br><span class="line">                        context.getResources().listResources(<span class="string">"/WEB-INF/classes"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (WebResource webResource : webResources) &#123;</span><br><span class="line">                    processAnnotationsWebResource(webResource, webXml,</span><br><span class="line">                            webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 5. Process JARs for annotations for annotations and</span></span><br><span class="line">            <span class="comment">// @HandlesTypes matches - only need to process those fragments we</span></span><br><span class="line">            <span class="comment">// are going to use (remember orderedFragments includes any</span></span><br><span class="line">            <span class="comment">// container fragments)</span></span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                processAnnotations(</span><br><span class="line">                        orderedFragments, webXml.isMetadataComplete(), javaClassCache);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Cache, if used, is no longer required so clear it</span></span><br><span class="line">            javaClassCache.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!webXml.isMetadataComplete()) &#123;</span><br><span class="line">            <span class="comment">// Step 6. Merge web-fragment.xml files into the main web.xml</span></span><br><span class="line">            <span class="comment">// file.</span></span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                ok = webXml.merge(orderedFragments);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 7. Apply global defaults</span></span><br><span class="line">            <span class="comment">// Have to merge defaults before JSP conversion since defaults</span></span><br><span class="line">            <span class="comment">// provide JSP servlet definition.</span></span><br><span class="line">            webXml.merge(defaults);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 8. Convert explicitly mentioned jsps to servlets</span></span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                <span class="comment">// 收集包含的jsp相关的信息，并缓存起来，该过程不涉及对应jsp对象的创建</span></span><br><span class="line">                convertJsps(webXml);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Step 9. Apply merged web.xml to Context</span></span><br><span class="line">            <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">                configureContext(webXml);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            webXml.merge(defaults);</span><br><span class="line">            convertJsps(webXml);</span><br><span class="line">            configureContext(webXml);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (context.getLogEffectiveWebXml()) &#123;</span><br><span class="line">            log.info(<span class="string">"web.xml:\n"</span> + webXml.toXml());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Always need to look for static resources</span></span><br><span class="line">        <span class="comment">// Step 10. Look for static resources packaged in JARs</span></span><br><span class="line">        <span class="comment">// 寻找jar包中的静态资源，只是把jar保重的resource加载并保存进来</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="comment">// Spec does not define an order.</span></span><br><span class="line">            <span class="comment">// Use ordered JARs followed by remaining JARs</span></span><br><span class="line">            Set&lt;WebXml&gt; resourceJars = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (WebXml fragment : orderedFragments) &#123;</span><br><span class="line">                resourceJars.add(fragment);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (WebXml fragment : fragments.values()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!resourceJars.contains(fragment)) &#123;</span><br><span class="line">                    resourceJars.add(fragment);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            processResourceJARs(resourceJars);</span><br><span class="line">            <span class="comment">// See also StandardContext.resourcesStart() for</span></span><br><span class="line">            <span class="comment">// WEB-INF/classes/META-INF/resources configuration</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Step 11. Apply the ServletContainerInitializer config to the</span></span><br><span class="line">        <span class="comment">// context</span></span><br><span class="line">        <span class="comment">// 这一步就会将步骤3中收集到的SCI以及注解包含的类给纳管到context中</span></span><br><span class="line">        <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;ServletContainerInitializer,</span><br><span class="line">                    Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">                        initializerClassMap.entrySet()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (entry.getValue().isEmpty()) &#123;</span><br><span class="line">                    context.addServletContainerInitializer(</span><br><span class="line">                            entry.getKey(), <span class="keyword">null</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    context.addServletContainerInitializer(</span><br><span class="line">                            entry.getKey(), entry.getValue());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>该方法比较长，我们仅在关键地方做相关的注释，这里最重要的一步操作就是扫描jar包获取SCI的实现类以及类上使用@HandleType注解指定的类。</code></pre><p>上述整个过程都是在listener中进行的，执行完之后就回归到我们的主流程<code>StandardContext</code>中的<code>initInternal();</code>方法了，该方法没有什么意义，因此略过。</p><ul><li>回到上面的主要流程还差一步调用bootstrap的start方法启动容器，该方法最终会走到Catalina中的start方法，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    .........</span><br><span class="line">    <span class="comment">// Start the new server</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getServer().start();</span><br><span class="line">    &#125; c.......</span><br></pre></td></tr></table></figure><p>核心方法只有一个，就是获取对应的server并调用其start方法，该方法具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final synchronized void start() throws LifecycleException &#123;</span><br><span class="line">        .....</span><br><span class="line">        setStateInternal(LifecycleState.STARTING_PREP, null, false);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            startInternal();</span><br><span class="line">        &#125; .......</span><br></pre></td></tr></table></figure><p>最终调用了<code>startInternal()</code>方法，该方法的核心操作就是会从外到内依次调用相关容器的start方法，而start方法又会调用内层的容器的<code>startInternal()</code>方法，最终走到StandardContext中，对应<code>startInternal()</code>方法中包含了一行最重要的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Call ServletContainerInitializers</span><br><span class="line">for (Map.Entry&lt;ServletContainerInitializer, Set&lt;Class&lt;?&gt;&gt;&gt; entry :</span><br><span class="line">    initializers.entrySet()) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        entry.getKey().onStartup(entry.getValue(),</span><br><span class="line">                getServletContext());</span><br><span class="line">    &#125; catch (ServletException e) &#123;</span><br><span class="line">        log.error(sm.getString(&quot;standardContext.sciFail&quot;), e);</span><br><span class="line">        ok = false;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一步会依次获取前面容器的SCI并调用这些实现了SCI接口实现类的<code>onStartup</code>方法，该方法接收的参数是SCI接口实现类上面声明的@HandleType所标注的类。这么说会有点抽象，我们还是以一个具体的web应用的例子来演示一下，下面搭建一个<a href="https://github.com/southrivers/spring-demo" target="_blank" rel="noopener">springmvc+tomcat的web应用</a>，查看SCI在工程中的实现，可以知道其实现在spring-web下，对应代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HandlesTypes</span>(WebApplicationInitializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SpringServletContainerInitializer</span> <span class="keyword">implements</span> <span class="title">ServletContainerInitializer</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartup</span><span class="params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">                。。。。。。</span><br><span class="line"><span class="keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">initializer.onStartup(servletContext);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析该代码可以知道，SCI最终会调用WebApplicationInitializer实现类的onStartup方法，那我们看一下WebApplicationInitializer究竟有那些实现类，可以找到两个核心的类，分别是：<code>AbstractContextLoaderInitializer</code>、<code>AbstractDispatcherServletInitializer</code>，<strong>这两个类中的onStartup会分别初始化ContextLoaderListener、DispatcherServlet，其中ContextLoaderListener涉及到springmvc中容器的初始化，DispatcherServlet则涉及前段请求相关资源的初始化，最终就完成了整个web应用的初始化，并可以处理来自客户端的请求。</strong> 如下ContextLoaderListener中对应的容器的初始化操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在上面看到了this.initWebApplicationContext(event.getServletContext());这一行代码，继续跟进去发现会使用contextConfigLocation创建一个applicationContext对象，也就是初始化我们的spring容器了，这也就衔接了我们之前的spring ioc代码及流程的分析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面仅仅是代码的走读，后面如果有时间还需要好好地细读一下。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java内部类小结</title>
      <link href="/2019/03/24/java%E5%86%85%E9%83%A8%E7%B1%BB%E5%B0%8F%E7%BB%93/"/>
      <url>/2019/03/24/java%E5%86%85%E9%83%A8%E7%B1%BB%E5%B0%8F%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>工作过程中很少使用内部类，不过倒是经常在一些代码里面又看到内部类的身影，因此特意抽时间学习了一下，顺便总结一下方便日后查看。内部类分为以下几种：</p><ul><li>成员内部类<ul><li>静态成员内部类</li><li>非静态成员内部类</li></ul></li><li>匿名内部类</li><li>局部内部类</li></ul><p>现就以上内部类分别进行探讨，值得一提的是，我们在谈到这几种类的时候，需要时时刻刻在大脑中想象以下这几个类以及其对应的对象在内存中的布局，这样再理解起来就很简单了，不然总靠死记是没有办法很好的应用的。</p><h1 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h1><p>首先强调一下，既然是成员内部类，那么其特点就是成员化，也即是内部类是作为一个外部类的成员进行看待的，既然是作为成员看待的，那么可以<strong>修饰成员的修饰符就可以拿来修饰这种内部类</strong>。而对于静态和非静态的理解则将其同变量进行比较就可以知道，<strong>静态的那必然是属于类的，而非静态的则是属于对象的</strong></p><h2 id="非静态成员内部类"><a href="#非静态成员内部类" class="headerlink" title="非静态成员内部类"></a>非静态成员内部类</h2><p>我们首先来看一下非静态内部类的定义，然后演示以下其用法，并探讨一些特性。非静态内部类的形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其在内存中的布局如下：<img src="//southrivers.github.io/2019/03/24/java内部类小结/nstatic-class.png" alt>如上，由于是非静态的内部类，因此<strong>该内部类是只存在于外部对象上（并非类上）的，这种特性会导致内部类只有在外部类被实例化之后才会被加载到内存中</strong>（图中实线所示），也因此我们不能在非静态内部类定义静态变量，因为静态变量本身就是类级别的，要求类在虚拟机启动的时候就应该加载到永久带的内存中，而非静态内部类在外部类没有生成对象的时候是不存在的，所以内部类的字段和方法都不能是静态的。下面我们来演示一下具体的用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter(<span class="number">1</span>).<span class="keyword">new</span> Inner(<span class="number">2</span>);</span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        System.out.println(<span class="string">"this is outter cons, i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.x = x;</span><br><span class="line">            System.out.println(<span class="string">"this is inner cons, x = "</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到内部类可以正常的访问外部类的静态的或者非静态的变量，不过需要注意的是，对于两个不同的外部对象，由于其外部对象不同，因此每一个外部对象所持有的内部对象也正如上图中的虚线所示，我们可以通过反编译相关的字节码来验证这种猜想：上面的类编译后会生成如下文件：<img src="//southrivers.github.io/2019/03/24/java内部类小结/javacnstatic-class.png" alt>从上面的文件我们看到外部类以及对应的内部类在编译完之后会分别存放到不同的文件，我们查看一下内部类反编译后的文件，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;TestOutter.java&quot;</span><br><span class="line">class com.h3c.Outter$Inner &#123;</span><br><span class="line">  int x;</span><br><span class="line"></span><br><span class="line">  final com.h3c.Outter this$0;</span><br><span class="line"></span><br><span class="line">  public com.h3c.Outter$Inner(com.h3c.Outter, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Lcom/h3c/Outter;</span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: iload_2</span><br><span class="line">      11: putfield      #3                  // Field x:I</span><br><span class="line">      14: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      17: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      20: dup</span><br><span class="line">      21: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      24: ldc           #7                  // String this is inner cons, x =</span><br><span class="line">      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      29: iload_2</span><br><span class="line">      30: invokevirtual #9                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      33: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      36: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      39: return</span><br><span class="line"></span><br><span class="line">  public void test();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: getstatic     #12                 // Field com/h3c/Outter.i:I</span><br><span class="line">       6: invokevirtual #13                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       9: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面反编译之后的字节码中我们可以看到多了一个成员变量：<figure class="highlight plain"><figcaption><span>com.h3c.Outter this$0;```，并且在内部类的构造函数中会传入一个**外部类对象的引用**</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">，也因此我们可以确定内部类在外部类在生成对应对象的时候要求传入外部类的引用。</span><br><span class="line">使用非静态的内部类还需要注意的是序列化，由于序列化要求所有的成员都实现了序列化的接口（**除非是使用transient修饰的变量**），而从上面反编译后的字节码我们</span><br><span class="line">看到编译器给内部类自动添加了一个外部类的成员变量，因此如果我们仅仅使内部类实现了Serializable接口的化，在序列化内部对象到文件的时候将得到一个无法序列化的错误，</span><br><span class="line">这正是由于外部类没有实现序列化的接口，程序演示如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public class TestOutter &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        Outter.Inner inner = new Outter(1).new Inner(2);</span><br><span class="line">        inner.test();</span><br><span class="line">        File file = new File(&quot;test&quot;);</span><br><span class="line">        new ObjectOutputStream(new FileOutputStream(file)).writeObject(inner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Outter &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    static int i;</span><br><span class="line"></span><br><span class="line">    public Outter(int i) &#123;</span><br><span class="line">        this.i = i;</span><br><span class="line">        System.out.println(&quot;this is outter cons, i = &quot; + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test() &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    class Inner implements Serializable &#123;</span><br><span class="line">        int x;</span><br><span class="line"></span><br><span class="line">        public Inner(int x) &#123;</span><br><span class="line">            this.x = x;</span><br><span class="line">            System.out.println(&quot;this is inner cons, x = &quot; + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void test() &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对应的执行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">this is outter cons, i = 1</span><br><span class="line">this is inner cons, x = 2</span><br><span class="line">1</span><br><span class="line">Exception in thread &quot;main&quot; java.io.NotSerializableException: com.h3c.Outter</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)</span><br><span class="line">at java.io.ObjectOutputStream.defaultWriteFields(ObjectOutputStream.java:1548)</span><br><span class="line">at java.io.ObjectOutputStream.writeSerialData(ObjectOutputStream.java:1509)</span><br><span class="line">at java.io.ObjectOutputStream.writeOrdinaryObject(ObjectOutputStream.java:1432)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1178)</span><br><span class="line">at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)</span><br><span class="line">at com.h3c.TestOutter.main(TestOutter.java:11)</span><br></pre></td></tr></table></figure><p>上面我们也已经分析这种问题的原因了，那么想要解决这种问题也就很简单了，那就是将外部类也实现Serializable即可，代码不再演示，有兴趣的可以下来自己尝试。</p><h2 id="静态成员内部类"><a href="#静态成员内部类" class="headerlink" title="静态成员内部类"></a>静态成员内部类</h2><p>静态成员内部类和普通的类并没有什么区别，既然和普通类没有什么区别，那么静态成员内部类对象的创建就不需要依赖外部对象，当然这种内部类也就没有办法访问外部类的非静态变量或者方法，不过这种内部类也因此可以定义自己的静态成员或者变量。同时也因为这种内部类不再持有外部类的对象，因此序列化也就不受外部类的影响了，如下简单演示一下：代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOutter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner(<span class="number">2</span>);</span><br><span class="line">        inner.test();</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"test"</span>);</span><br><span class="line">        <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file)).writeObject(inner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">        System.out.println(<span class="string">"this is outter cons, i = "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">            x = x;</span><br><span class="line">            System.out.println(<span class="string">"this is inner cons, x = "</span> + x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译内部类结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;TestOutter.java&quot;</span><br><span class="line">class com.h3c.Outter$Inner implements java.io.Serializable &#123;</span><br><span class="line">  static int x;</span><br><span class="line"></span><br><span class="line">  public com.h3c.Outter$Inner(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: iload_1</span><br><span class="line">       5: istore_1</span><br><span class="line">       6: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       9: new           #3                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #4                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: ldc           #5                  // String this is inner cons, x =</span><br><span class="line">      18: invokevirtual #6                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      21: iload_1</span><br><span class="line">      22: invokevirtual #7                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      25: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      28: invokevirtual #9                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      31: return</span><br><span class="line"></span><br><span class="line">  public void test();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: getstatic     #10                 // Field com/h3c/Outter.i:I</span><br><span class="line">       6: invokevirtual #11                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">       9: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h1><p>在方法中定义的内部类叫做局部类，由于是在方法中定义的，因此其和方法内定义的普通变量并不会有太大的区别，所以这种内部类不能够使用private等修饰符来修饰，代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        POutter pOutter = <span class="keyword">new</span> POutter();</span><br><span class="line">        Object x = pOutter.test(<span class="number">12</span>);</span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">POutter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> px;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">PInner</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">PInner</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.x = x;</span><br><span class="line">                System.out.println(<span class="string">"pinner cons x= "</span> + x);</span><br><span class="line">                System.out.println(<span class="string">"poutter cons px= "</span> + px);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> PInner <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"hello pinner k = "</span> + k);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PInner inner = <span class="keyword">new</span> PInner(<span class="number">12</span>);</span><br><span class="line">        inner.say();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样我们编译之后可以看到会存在以下几个文件：<img src="//southrivers.github.io/2019/03/24/java内部类小结/partinner-class.png" alt>我们再次使用javap将内部类反编译成字节码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;PartTest.java&quot;</span><br><span class="line">class com.h3c.POutter$1PInner &#123;</span><br><span class="line">  int x;</span><br><span class="line"></span><br><span class="line">  final com.h3c.POutter this$0;</span><br><span class="line"></span><br><span class="line">  public com.h3c.POutter$1PInner(com.h3c.POutter, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: aload_1</span><br><span class="line">       2: putfield      #1                  // Field this$0:Lcom/h3c/POutter;</span><br><span class="line">       5: aload_0</span><br><span class="line">       6: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       9: aload_0</span><br><span class="line">      10: iload_2</span><br><span class="line">      11: putfield      #3                  // Field x:I</span><br><span class="line">      14: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      17: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      20: dup</span><br><span class="line">      21: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      24: ldc           #7                  // String pinner cons x=</span><br><span class="line">      26: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      29: iload_2</span><br><span class="line">      30: invokevirtual #9                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      33: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      36: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      39: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      42: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      45: dup</span><br><span class="line">      46: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      49: ldc           #12                 // String poutter cons px=</span><br><span class="line">      51: invokevirtual #8                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      54: aload_1</span><br><span class="line">      55: getfield      #13                 // Field com/h3c/POutter.px:I</span><br><span class="line">      58: invokevirtual #9                  // Method java/lang/StringBuilder.append:(I)Ljava/lang/StringBuilder;</span><br><span class="line">      61: invokevirtual #10                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      64: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      67: return</span><br><span class="line"></span><br><span class="line">  public com.h3c.POutter$1PInner say();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #14                 // String hello pinner k = 0</span><br><span class="line">       5: invokevirtual #11                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">       8: aload_0</span><br><span class="line">       9: areturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再次看到，对于局部内部类其成员变量新增了外部类对应的对象，因此可以知道序列化肯定是要求外部类也实现序列化，验证结果也正是如此，结果就不展示了，将上面代码贴进去执行就可以看到了。这里再次强调以下，局部内部类是和局部变量同一个级别的，因此局部变量可以执行的操作，局部内部类也可以执行，如：</p><ul><li>静态方法内部的局部类可以访问外部类的静态变量，但是不可以访问对象上的字段</li><li>非静态方法北部的局部类可以访问外部类的静态、非静态变量</li></ul><h1 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h1><p>匿名内部类简单的说就是没有名字的内部类。我们知道类的构造函数要求和类的名称相同，因此如果连类的名称都没有的话，那么肯定也就没有办法定义构造函数了，确实是这样子的，如下演示代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AclassTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Aface aface = <span class="keyword">new</span> Aface() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        aface.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Aface</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译完之后生成的类如下：<img src="//southrivers.github.io/2019/03/24/java内部类小结/a-class.png" alt>我们反编译AclassTest后，对应的字节码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;AclassTest.java&quot;</span><br><span class="line">public class com.h3c.AclassTest &#123;</span><br><span class="line">  public com.h3c.AclassTest();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class com/h3c/AclassTest$1</span><br><span class="line">       3: dup</span><br><span class="line">       4: invokespecial #3                  // Method com/h3c/AclassTest$1.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       7: astore_1</span><br><span class="line">       8: aload_1</span><br><span class="line">       9: invokevirtual #4                  // Method com/h3c/Aface.test:()V</span><br><span class="line">      12: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在main方法中初始化匿名内部类的时候调用的是抽象类的构造函数，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;AclassTest.java&quot;</span><br><span class="line">final class com.h3c.AclassTest$1 extends com.h3c.Aface &#123;</span><br><span class="line">  com.h3c.AclassTest$1();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method com/h3c/Aface.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于匿名内部类的使用场景一般是只使用一次，而且类比较小。除了不可以给匿名内部类定义构造函数外，其也不可以定义静态的字段或者方法，这大概都是由于静态字段和方法都需要一个明确的类名的原因吧。</p><h1 id="内部接口"><a href="#内部接口" class="headerlink" title="内部接口"></a>内部接口</h1><p>除了内部类之外，比较常见的还有内部接口，用法我们一并总结过一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hell</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InnerTest</span> <span class="keyword">implements</span> <span class="title">TestInterface</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InnerTest innerTest = <span class="keyword">new</span> InnerTest();</span><br><span class="line">        innerTest.hell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于接口是没有构造函数，因此也就不能被实例化，所以内部接口只有在静态的时候才是有意义的，不论接口是否声明静态或者非静态。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>关于内部类还有一些小的特性，比如，内部类不可以与外部类重名，这个是规范。另外当内部类方法和外部类有重叠的时候也会有一些需要注意的地方，下面我们就通过一个例子来进行说明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类不可以和外部类重名</span></span><br><span class="line"><span class="comment">//    public class Hello &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Hello.<span class="keyword">this</span>.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">say1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"this is inner class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is outter class"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Hello hello = <span class="keyword">new</span> Hello();</span><br><span class="line">        Inner inner = hello.<span class="keyword">new</span> Inner();</span><br><span class="line">        System.out.println(inner.say());</span><br><span class="line">        System.out.println(inner.say1());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们可以看到访问非静态内部类的方法的时候直接this就可以了，不过访问外部类的时候要加上类名，这个可以通过反编译之后来查看更详细的信息的，具体的不再过多的解释了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于内部类的总结暂时到此可以告一段落了，后续如果发现不对的或者有趣的用法会持续更新上去。参考文档：<img src="https://blog.csdn.net/hikvision_java_gyh/article/details/8964155" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring IOC流程解析</title>
      <link href="/2019/03/08/spring-IOC/"/>
      <url>/2019/03/08/spring-IOC/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><em>工作过程中断断续续的有使用过spring、spring boot框架，平时接触的最多的也是这些，但是由于平时更多的是使用到这些东西，因此对于原理没有深究，不过随着使用的深入，发现还是有必要了解一些原理性的东西，不然平时听别人吹逼的时候你只能抓瞎，就问你慌不慌？（当然也有些公司基于spring开发了自己的一套框架，因此源码的学习还真的不是吹逼就完事了的）</em></p><p>关于spring的介绍，接下来我会分成多个模块来分别总结，本小结主要是针对spring的IOC机制来讲解。IOC全称叫做inversion of control，翻译过来就叫做控制反转，我们平时说的DI（dependency injection：依赖注入）可以认为是控制IOC的具体实现，因此当别人提到spring的IOC和DI的时候，我们可以将其理解为是同一种模式，这种模式的特点是<strong>当我们构造一个对象的时候，该对象所需的依赖都由一个controller传进去，这种机制也就解释了控制反转的意义，将自身对象生成的权限由自身移交给另外一个控制器</strong>，控制反转带来的好处就是解耦合，被创建的对象本身并不需要关心自身的依赖，只需要将依赖设置成接口即可，这样就可以在装配的时候由控制器传入不同的实现，从而快速的切换业务线。</p><h1 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h1><h2 id="构建demo"><a href="#构建demo" class="headerlink" title="构建demo"></a>构建demo</h2><p>接下来我们先构建一个spring的工程，然后通过断点调试来一步步讲解IOC的流程，项目整体结构如下：<img src="//southrivers.github.io/2019/03/08/spring-IOC/project-structure.png" alt>由于本文主要是解析IOC的机制，因此所需的依赖只有spring-context，没有必要把杂七杂八的依赖都引入下来</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.18.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后我们在resource目录下新建一个application-context.xml的文件，具体内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.HelloService"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来我们构建工程所需要的类HelloService、WorldService，内容分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">syaHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + worldService.world() + <span class="string">" !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们新建一个MainService用来测试当前的工程，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 容器实例化</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"application-context.xml"</span>);</span><br><span class="line">        <span class="comment">// bean实例化</span></span><br><span class="line">        HelloService helloService = (HelloService) context.getBean(<span class="string">"hello"</span>);</span><br><span class="line">        helloService.syaHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们从控制台看到了hello !，整个过程就是这么简单（不过这个过程可是真不简单），可能我们忍不住想问一下，IOC在哪里体现出来呢？</p><p>答案就在上面的context.getBean(“hello”);这一行，这里的context可以理解为一个controller，我们想要什么对象就跟其进行申请即可。多说一句我们在看Spring相关源码的时候经常会看到各种context，也就是各种上下文，起初的时候我是经常会被绕晕，后来就慢慢发现所谓的上下文可以理解为一个<strong>持有指定范围的公共变量的容器</strong>，比如我们在上面看到的ApplicationContext就可以认为是持有整个应用的公共变量，因为持有的是整个应用的公共变量，因此这些变量在整个应用中都是可以共享的，这么说是不是就明白了。</p><p>接下来我们会针对上面的代码进行分析，整个分析过程也会分成两部分：</p><ul><li>容器的实例化</li><li>bean的实例化</li></ul><h2 id="容器的实例化"><a href="#容器的实例化" class="headerlink" title="容器的实例化"></a>容器的实例化</h2><p>在进入看具体的代码前，我们先来概要的说一下什么是容器，并从主观的角度去考虑一下，如果是我们自己来写框架的话，我们要注意什么。</p><p>说到容器我们最先想到的可能就是水杯之类的东西，那么他的主要的作用是什么呢？应该是holder住一些东西吧。嗯，我们在spring里面提到的容器大致的作用也是如此，用来存放一些资源，或者更准确的说是存放一些对象！那么为什么要存放这些对象呢？我们平时写代码，只管new一个对象，剩下的回收工作都交给JVM去操作了，这一切看起来都很合理，缓存对象带来的好处就是减少new一个对象和回收一个对象所带来的开销。</p><p>那么有没有什么不太适合这种缓存对象场景的呢？那肯定也是有的，比如说我们生成了一个包含状态的对象，那么一旦我们缓存了这个对象之后，后面再使用这个对象就会发现已经是一个脏的对象了（这里的脏表示缓存的对象已经缓存了上次调用的信息），因此，缓存一个有状态的对象显然不是一个好的选择，这也是我们在spring中通常都使用singleton的原因。相信很多人在spring的工程中使用httpclient都会记得，我们在声明这种类型的java bean的时候我们通常都会指定prototype，指定为prototype的作用就是当我们再次需要这种类型的对象的时候，会直接生成一个新的对象，并不会复用之前的对象。</p><p>言归正传，我们接下来看一下容器的创建创建过程吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 这里的configLocations是我们传进来的application-context.xml，</span></span><br><span class="line">    <span class="comment">// 因为默认会去classpath下去寻找对应的文件，所以我们不用在意是不是传了绝对路径或者相对路径，总之肯定是可以找到对应的文件的</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">        <span class="comment">// 核心方法，我们接下来的讲解也是针对这个方法的分析</span></span><br><span class="line">        refresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们会针对refresh这个方法进行分析，不过在分析之前我们还需要做足一下功课，梳理一下容器的继承关系，不然这么多东西还是啃不动。<img src="//southrivers.github.io/2019/03/08/spring-IOC/beanfactory.png" alt>一眼看去真的是眼花缭乱，本来以为就创建个容器，一下子冒出来这么多东西，也真是没谁了。不过我们也用不着害怕，我们只需要知道一些关键的东西就可以了。需要注意的是，虽然我们在项目中看到了这么复杂的继承关系，不过ApplicationContext并不应该理解为BeanFactory的实现类（虽然继承关系上来看是这么回事），而是ApplicationContext内部会持有一个beanFactory，我们所有的和beanFactory调用相关的都是会通过内部持有的beanFactory来进行调用（<strong>从这里来看ApplicationContext更像是BeanFactory的一个代理</strong>），这个beanFactory类型是DefaultListableBeanFactory，其类关系图如下：<img src="//southrivers.github.io/2019/03/08/spring-IOC/defaultlistablebf.png" alt>另外值得一说的是，不要看某一个类实现了这么多的接口就抓瞎了，接口本身是提供了方法的声明，所以其实是增加了操作某一个对象的方式。因此一个类继承的接口越多，则从侧面说明该类的功能越齐全，这也是为什么ApplicationContext内部会持有一个DefaultListableBeanFactory了，功能强大呗。</p><p>说了这么多，我们看一下refresh方法吧，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line"><span class="comment">// 准备工作：记录容器的启动时间并标记容器已经启动</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 这一步比较关键，主要是将bean的配置文件解析成一个个的beanDefinition，</span></span><br><span class="line"><span class="comment">// 并构建一个beanName-&gt;beanDefinition的map用于快速查找文件</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line"><span class="comment">// 这一步主要是设置bean类加载器，这一点可能会在多个容器之间传递实例的时候会用到（mark一下）</span></span><br><span class="line"><span class="comment">// 注册一些BeanPostProcessor，这些bean主要是应该会针对性的增强对应的bean（并不是为自身</span></span><br><span class="line"><span class="comment">// 的增强做准备），有点类似于责任链的功能了，只不过初始的时候只添加了两个beanpostprocessor，</span></span><br><span class="line"><span class="comment">// 我们自定义的beanpostprocessor并不会被加进去，至于用户自定义的beanpostprocessor</span></span><br><span class="line"><span class="comment">// 什么时候调用后面会有详细的分析，很重要 ！</span></span><br><span class="line"><span class="comment">// 最后是添加一些spring本身需要用到的工具bean</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line"><span class="comment">// 点进去查看这个方法是空的，不过从名字和注释上我们可以看的出这一个方法主要是</span></span><br><span class="line"><span class="comment">// 提供给实现了该抽象类的一个扩展beanFactory的机会，跳过</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 要理解这个方法需要知道BeanFactoryPostProcessor：如果说一个bean实现了BeanFactoryPostProcessor</span></span><br><span class="line"><span class="comment">// 那么容器初始化之后会执行bean内部的postProcessBeanFactory方法（注意并不是BeanPostProcessor），</span></span><br><span class="line"><span class="comment">// 这是在容器的层面上给我们的bean提供的一种扩展机制（平时并不是太常用到）。</span></span><br><span class="line"><span class="comment">// 由于在obtainFreshBeanFactory这一步我们就已经获取到beanFactory这个对象了，</span></span><br><span class="line"><span class="comment">// 因此bean的信息（这里说的信息是指beanDefinition）其实已经加载进去了</span></span><br><span class="line"><span class="comment">// 也就意味着我们知道那些bean实现了BeanFactoryPostProcessor这个接口了，因此接下来</span></span><br><span class="line"><span class="comment">// 就是调用实现了beanfactoryPostProcessor这个接口的bean的postProcessBeanFactory方法了</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line"><span class="comment">// 注册beanPostProcessor的实现类到容器中（前面我们已经说过了，在obtainFreshBeanFactory调用完之后</span></span><br><span class="line"><span class="comment">// 我们就已经知道了所有的beanDefinition，自然也就知道了所有的bean是不是实现了BeanPostProcessor）</span></span><br><span class="line"><span class="comment">// ，注意并不是beanFactoryPostProcessor！BeanPostProcessor是在Bean的层面上提供的一种扩展机制</span></span><br><span class="line"><span class="comment">// 里面包含了两个重要的方法：postprocessBeforeInitialization和postprocessAfterInitialization，</span></span><br><span class="line"><span class="comment">// 这两个方法分别会在bean实例化之前和实例化之后执行</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize message source for this context.</span></span><br><span class="line"><span class="comment">// 这一步是和国际化相关的，不重要</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line"><span class="comment">// 初始化ApplicationContext事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line"><span class="comment">// 这个方法也是空的，注释如上也说明的很详细了，是提供给子类实现的接口目的是</span></span><br><span class="line"><span class="comment">// 在实例化正常的bean之前实例化一些特殊的bean，这里也体现了</span></span><br><span class="line"><span class="comment">// spring处处可扩展的一种机制（虽然看起来并没有什么卵用）</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for listener beans and register them.</span></span><br><span class="line"><span class="comment">// 注册事件监听器，应该是和事件广播器有一定的关系，监听器需要实现ApplicationListener接口</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * </span></span><br><span class="line"><span class="comment">                * </span></span><br><span class="line"><span class="comment">                * 到这一步就是分水岭，接下来就会初始化正常的java bean了</span></span><br><span class="line"><span class="comment">                * </span></span><br><span class="line"><span class="comment">                * **/</span></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 重点强调一下，在这之前并不会生成bean对象，这一步是会将所有的非lazy-init的对象都给实例化。</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line"><span class="comment">// 最后广播事件，告知容器已经完成初始化的操作</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看起来也不是太复杂嘛，嗯，也就是乍一看。上面我们有说过容器创建的目的：<strong>持有资源</strong>，接下来的分析请牢记这句话，不然看着看着保证能让你跪掉。</p><p>按照上面的代码，我们先来看一下obtainFreshBeanFactory这个方法吧，毕竟这个方法执行完毕之后我们就会得到一个beanFactory，当然也就是我们的容器。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 关闭旧的容器，并创建新的容器，加载bean的定义，这一步并不会实例化bean（已经不是第一次强调了：本节只关心容器的初始化）</span></span><br><span class="line">    refreshBeanFactory();</span><br><span class="line">    <span class="comment">// 返回持有的容器（beanFactory）</span></span><br><span class="line">    ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上核心代码自然就是refreshBeanFactory了，我们点进去看一下refresBeanFactory都做了那些操作吧，不过很遗憾方法是抽象的，那肯定是在子类里面有实现吧。没错方法是在AbstractRefreshableApplicationContext，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否已经存在beanFactory了，如果已经存在了则需要销毁所有的bean并关闭beanFactory（这也解释了上面的方法为什么叫做refresh，而不是init）</span></span><br><span class="line">    <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">        destroyBeans();</span><br><span class="line">        closeBeanFactory();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化一个beanFactory，这一步其实就是返回一个</span></span><br><span class="line">        <span class="comment">// DefaultListableBeanFactory至于为什么是defaultlistablebeanfactory是</span></span><br><span class="line">        <span class="comment">// 因为实现的接口多，方便用户操作呗</span></span><br><span class="line">        DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">        beanFactory.setSerializationId(getId());</span><br><span class="line">        <span class="comment">// 设置beanFactory的两个属性：beandefinition允许覆盖和允许循环引用</span></span><br><span class="line">        customizeBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// 加载beandefinition到beanfactory中</span></span><br><span class="line">        loadBeanDefinitions(beanFactory);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面注释也是比较详细了，核心代码的话就是loadBeanDefinitions：将bean的定义转换成BeanDefinition加载到beanFactory中，最终的格式就是&lt;beanName, beanDefinition&gt;，继续跟进代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">    <span class="comment">// 实例化一个beanDefinitionReader，该对象持有一个beanFactory实例，在解析完之后会讲解析数据写入beanFactory</span></span><br><span class="line">    XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">    <span class="comment">// resource loading environment.</span></span><br><span class="line">    beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">    beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">    beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line">    <span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">    <span class="comment">// 可以定制初始化reader，略过</span></span><br><span class="line">    initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺接上文，我们进去loadBeanDefinitions方法查看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">    Resource[] configResources = getConfigResources();</span><br><span class="line">    <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configResources);</span><br><span class="line">    &#125;</span><br><span class="line">    String[] configLocations = getConfigLocations();</span><br><span class="line">    <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">        reader.loadBeanDefinitions(configLocations);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里在强调一下，我们的reader内部已经持有beanFactory对象，我们接下来只需要继续跟进loadBeanDefinitions方法即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    Resource[] var3 = resources;</span><br><span class="line">    <span class="keyword">int</span> var4 = resources.length;</span><br><span class="line">    <span class="comment">// 遍历加载给定的文件，这里就是我们指定的application-context.xml文件</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var5 = <span class="number">0</span>; var5 &lt; var4; ++var5) &#123;</span><br><span class="line">        Resource resource = var3[var5];</span><br><span class="line">        <span class="comment">// 往下跟</span></span><br><span class="line">        counter += <span class="keyword">this</span>.loadBeanDefinitions((Resource)resource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 继续往下跟</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;EncodedResource&gt; currentResources = (Set)<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">    <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentResources = <span class="keyword">new</span> HashSet(<span class="number">4</span>);</span><br><span class="line">        <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!((Set)currentResources).add(encodedResource)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">                <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 核心代码</span></span><br><span class="line">                var5 = <span class="keyword">this</span>.doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                inputStream.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var15) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), var15);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ((Set)currentResources).remove(encodedResource);</span><br><span class="line">            <span class="keyword">if</span> (((Set)currentResources).isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将给定的文件转换成一棵DOM树，方便操作</span></span><br><span class="line">        Document doc = <span class="keyword">this</span>.doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// 解析dom文件并注册到registry，前面我们就已经说过</span></span><br><span class="line">        <span class="comment">// reader在实例化的时候会持有一个BeanFactory，</span></span><br><span class="line">        <span class="comment">// 而这个beanfactory恰恰就是registry（构造函数有类型强转），通过this.getRegistry()获取到的就是beanfactory</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.registerBeanDefinitions(doc, resource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (BeanDefinitionStoreException var4) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var4;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXParseException var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"Line "</span> + var5.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, var5);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SAXException var6) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(), <span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, var6);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParserConfigurationException var7) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Parser configuration exception parsing XML from "</span> + resource, var7);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var8) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"IOException parsing XML document from "</span> + resource, var8);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(), <span class="string">"Unexpected exception parsing XML document from "</span> + resource, var9);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = <span class="keyword">this</span>.createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = <span class="keyword">this</span>.getRegistry().getBeanDefinitionCount();</span><br><span class="line">    <span class="comment">// 核心代码</span></span><br><span class="line">    documentReader.registerBeanDefinitions(doc, <span class="keyword">this</span>.createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">    <span class="keyword">this</span>.logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">    <span class="comment">// 获取对应xml文件的根节点</span></span><br><span class="line">    Element root = doc.getDocumentElement();</span><br><span class="line">    <span class="comment">// 从根节点开始解析并注册beandefinition</span></span><br><span class="line">    <span class="keyword">this</span>.doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定的节点解析并注册beanDefinition</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Any nested &lt;beans&gt; elements will cause recursion in this method. In</span></span><br><span class="line">    <span class="comment">// order to propagate and preserve &lt;beans&gt; default-* attributes correctly,</span></span><br><span class="line">    <span class="comment">// keep track of the current (parent) delegate, which may be null. Create</span></span><br><span class="line">    <span class="comment">// the new (child) delegate with a reference to the parent for fallback purposes,</span></span><br><span class="line">    <span class="comment">// then ultimately reset this.delegate back to its original (parent) reference.</span></span><br><span class="line">    <span class="comment">// this behavior emulates a stack of delegates without actually necessitating one.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 负责解析beans的代理类</span></span><br><span class="line">    BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">    <span class="comment">// 由于beans标签下面也会有beans标签，因此这里的代理类也会随着beans的内嵌而内嵌，表现出来就是用parent来构造delegate</span></span><br><span class="line">    <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">            <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                            <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 预留给子类扩展，来额外的处理xml</span></span><br><span class="line">    preProcessXml(root);</span><br><span class="line">    <span class="comment">// 解析beandefinition并注册，核心代码</span></span><br><span class="line">    parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">    <span class="comment">// 预留给子类扩展，来额外的处理xml</span></span><br><span class="line">    postProcessXml(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    <span class="comment">// 解析default namespace下的元素</span></span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 解析自定义的namespace下的元素</span></span><br><span class="line">                    delegate.parseCustomElement(ele);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中我们看到，代码最终的执行分成两块：parseDefaultElement、parseCustomElement，如果解析的节点是beans、bean、import、alias 走的就是parseDefaultElement方法，至于其他的标签，后文我们会通过spring的扩展机制来具体展示一些这种机制（主要是namespace、xsd、以及namespacehandler）。由于我们本节主要是探讨IOC的机制，因此我们关心的标签其实是bean标签的解析，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下方法有些跳跃，因为不重要的代码是在太多，到这里其实已经不是太重要了，因为这里涉及到的仅仅是DOM树的解析</span></span><br><span class="line"><span class="comment">// 这里我们看到readerContext可以猜想到该context保存的是当前这个reader的公共的资源</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心！解析bean对象</span></span><br><span class="line">    BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">    <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">            BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">                    bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Send registration event.</span></span><br><span class="line">        getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解析配置文件，将配置文件中的信息提取出来，写入beandefinition</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">    String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">        String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">        aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String beanName = id;</span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">        beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心代码，一旦该方法执行完成之后，就已经生成了对应的beandefinition对象</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                            beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">                    <span class="comment">// Register an alias for the plain bean class name, if still possible,</span></span><br><span class="line">                    <span class="comment">// if the generator returned the class name plus a suffix.</span></span><br><span class="line">                    <span class="comment">// This is expected for Spring 1.2/2.0 backwards compatibility.</span></span><br><span class="line">                    String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">                    <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                            beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                            !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                        aliases.add(beanClassName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                    logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                            <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                error(ex.getMessage(), ele);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这一步结束之后，我们就已经获取到了beandefinitionHolder对象了，不过请注意，这里有两个循环，第一个是遍历资源路径加载资源，本例中就是我们的application-context.xml文件，另外一个循环是在某一个文件加载之后解析标签的过程中循环遍历的。</p><p>在完成beandefinitionholder初始化之后，我们就可以注册该beandefinition，并将该事件发送出去，我们接下来看一下beandefinition的注册究竟是一个什么样的过程吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">    Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Validation of bean definition failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BeanDefinition oldBeanDefinition;</span><br><span class="line"></span><br><span class="line">    oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription(), beanName,</span><br><span class="line">                    <span class="string">"Cannot register bean definition ["</span> + beanDefinition + <span class="string">"] for bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"': There is already ["</span> + oldBeanDefinition + <span class="string">"] bound."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">            <span class="comment">// e.g. was ROLE_APPLICATION, now overriding with ROLE_SUPPORT or ROLE_INFRASTRUCTURE</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isWarnEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.warn(<span class="string">"Overriding user-defined bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a framework-generated bean definition: replacing ["</span> +</span><br><span class="line">                        oldBeanDefinition + <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.info(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with a different definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">                <span class="keyword">this</span>.logger.debug(<span class="string">"Overriding bean definition for bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' with an equivalent definition: replacing ["</span> + oldBeanDefinition +</span><br><span class="line">                        <span class="string">"] with ["</span> + beanDefinition + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">            <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">                List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">                updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">                updatedDefinitions.add(beanName);</span><br><span class="line">                <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">                    Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">                    updatedSingletons.remove(beanName);</span><br><span class="line">                    <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Still in startup registration phase</span></span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">        resetBeanDefinition(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体看下来，主要的流程也就是向beandefinitionmap中添加对应的beanName和beanDefinition，暂时可以先告一段落。到此我们已经分析了容器的初始化的流程及中间的操作。总结起来如下步骤：</p><ul><li>创建容器</li><li>加载文件并创建dom解析器</li><li>根据标签的namespace选择不同的解析流程</li><li>将解析之后的beandefinition注册到容器中</li></ul><h2 id="bean的实例化"><a href="#bean的实例化" class="headerlink" title="bean的实例化"></a>bean的实例化</h2><p>在上文中我们将spring的初始化分为两个部分，本小结我们就来看一下bean的实例化是一个什么样的过程，方法入口为finishBeanFactoryInitialization（其实在这之前我们实现了beanfactorypostprocessor接口的类的postprocessbeanfactory不是已经调用过了么？既然方法都已经调用过了，那对应的对象是不是在这之前也已经生成了呢？是的，在invokeBeanFactoryPostProcessors方法的时候就已经生成了对应的对象了，实例化的方法也和正常的实例化没什么区别），这一步是会将所有的非lazy-init的singleton都给实例化，所谓的lazy-init是在使用到的时候才回去实例化的一种机制，注意上面容器初始化是将xml文件映射为beandefinition，而此处的初始化则是生成bean中指定类的具体的对象！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Initialize conversion service for this context.</span></span><br><span class="line">    <span class="comment">// conversion_service_bean工程上用到的不是太多，略过</span></span><br><span class="line">    <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        beanFactory.setConversionService(</span><br><span class="line">                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">    <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">    <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">    <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">        beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">    <span class="comment">// 获取切面相关的java bean，略过</span></span><br><span class="line">    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">        getBean(weaverAwareName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow for caching all bean definition metadata, not expecting further changes.</span></span><br><span class="line">    beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">    <span class="comment">// 初始化所有的非lazy-init的单例</span></span><br><span class="line">    beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接上文实例化非lazy-init的单例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line">    <span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">    List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line">    <span class="comment">// 初始化所有单例对象</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这一步涉及到bean的继承，可以暂时略过</span></span><br><span class="line">        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">        <span class="comment">// 满足初始化的条件：非抽象、单例、非lazy-init</span></span><br><span class="line">        <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">            <span class="comment">// 针对factorybean特有的处理方法，判断其是否迫切需要初始化，如果是则立即获取对应的bean</span></span><br><span class="line">            <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">                <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">                    isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, getAccessControlContext());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">                    getBean(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 核心方法</span></span><br><span class="line">                getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line">    <span class="comment">// 到这里应完成所有对象的初始化，接下来会对SmartInitializingSingleton这种类型的bean执行回调函数</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">        Object singletonInstance = getSingleton(beanName);</span><br><span class="line">        <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">            <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如上我们继续跟进getBean这一块代码：</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这一步是针对factorybean所做的特殊处理</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly check singleton cache for manually registered singletons.</span></span><br><span class="line">    <span class="comment">// 这一步检测早期引用是否已经创建该单例（其实是是否存在循环引用导致bean的创建），</span></span><br><span class="line">    <span class="comment">// 首先会从singleObject中获取对应的bean，如果获取不到</span></span><br><span class="line">    <span class="comment">// 接着会从earlySingletonObjects中获取对应的bean，最后会从singletonFactories获取</span></span><br><span class="line">    <span class="comment">// 创建bean的factorybean</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning eagerly cached instance of singleton bean '"</span> + beanName +</span><br><span class="line">                        <span class="string">"' that is not fully initialized yet - a consequence of a circular reference"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是普通bean的话，返回的是sharedInstance，如果是factorybean的话反回的是getObject方法返回的对象</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we're already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We're assumably within a circular reference.</span></span><br><span class="line">        <span class="comment">// protype类型的javabean不允许循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 正常情况下，创建java bean都是会走到这一步</span></span><br><span class="line"><span class="comment">        * **/</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取beanDefinition</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">// 获取当前bean依赖的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 注册依赖关系</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 首先初始化依赖的bean</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">"'"</span> + beanName + <span class="string">"' depends on missing bean '"</span> + dep + <span class="string">"'"</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常的创建bean的流程，上面已经完成了当前bean所依赖的bean的创建了，接下来就是创建当前的bean了</span></span><br><span class="line">            <span class="comment">// 由于是初始化，条件限制很明显了，只会走到第一步创建javabean</span></span><br><span class="line">            <span class="comment">// Create bean instance.</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                <span class="comment">// 创建单例</span></span><br><span class="line">                sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                            <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                            <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                            <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                            destroySingleton(beanName);</span><br><span class="line">                            <span class="keyword">throw</span> ex;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 如果sharedInstance是factorybean，返回getObject方法返回的对象，否则返回sharedInstance</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// 创建prototype实例</span></span><br><span class="line">                <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他作用域的bean实例：request等</span></span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                            beforePrototypeCreation(beanName);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">finally</span> &#123;</span><br><span class="line">                                afterPrototypeCreation(beanName);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                            <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if required type matches the type of the actual bean instance.</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面创建java bean都有用到的方法就是createBean，我们继续跟进一下</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">    <span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">    <span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">    <span class="comment">// 加载beandefinition中指定的class</span></span><br><span class="line">    Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">    <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">        mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Prepare method overrides.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 准备bean中要求重写的方法，是提供给bean的一种扩展机制</span></span><br><span class="line">        mbdToUse.prepareMethodOverrides();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">                beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        <span class="comment">// TODO 让InstantiationAwareBeanPostProcessor有机会返回代理，</span></span><br><span class="line">        <span class="comment">//  这一步也很重要，注意并不是要求bean实现BeanPostProcessor！</span></span><br><span class="line">        <span class="comment">// 如果是切面的话，到此就截止了</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 核心方法</span></span><br><span class="line">    Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们继续上面的核心方法跟进：</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建bean实例，到了这一步我们就完成了bean实例的创建</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">            isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">                    <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 填充bean</span></span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 回调函数，好像是包括InitializingBean、beanpostprocessor，这里用到的beanpostprocessor和前面</span></span><br><span class="line">            <span class="comment">// 可能会产生的增强是一致的，同样都是获取beanpostprocessor，只不过前面存在类型的判断</span></span><br><span class="line">            exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                            <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                            <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                            <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来会分别看一下容器实例化的三个步骤：</p><h3 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h3><p>千淘万漉虽辛苦，终于看到曙光了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">    Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 采用工厂方法实例化对象，这里我们看到factorymethod是beandefinition的一个属性，没错，</span></span><br><span class="line">    <span class="comment">// factorymethod在bean的标签上确实是作为一个属性而存在</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">        <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Shortcut when re-creating the same bean...</span></span><br><span class="line">    <span class="comment">// 这一部分可以暂时跳过，其涉及到的是prototype类型的java bean的创建过之后再次创建的短路操作（快速决定构造函数）</span></span><br><span class="line">    <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">                resolved = <span class="keyword">true</span>;</span><br><span class="line">                autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">            <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Need to determine the constructor...</span></span><br><span class="line">    <span class="comment">// 对于没有进入短路操作的java bean的构建，此处就是获取其构造函数</span></span><br><span class="line">    Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">    <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">            mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">        <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">        <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No special handling: simply use no-arg constructor.</span></span><br><span class="line">    <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单起见我们就挑一个无参构造函数来看</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance;</span><br><span class="line">        <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 核心方法</span></span><br><span class="line">            beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">        &#125;</span><br><span class="line">        BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">        initBeanWrapper(bw);</span><br><span class="line">        <span class="keyword">return</span> bw;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续跟进核心方法我们会看到</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don't override the class with CGLIB if no overrides.</span></span><br><span class="line">    <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 如果不存在方法覆写就进入到这个分支，方法覆写相关的属性分别是lookup-method、replace-method</span></span><br><span class="line">        Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">        <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">            constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">            <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">                <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                                <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        constructorToUse =clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用指定的构造函数初始化java bean</span></span><br><span class="line">        <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Must generate CGLIB subclass.</span></span><br><span class="line">        <span class="comment">// 对于存在方法覆写的bean是通过cglib字节码增强的方式生成的，</span></span><br><span class="line">        <span class="comment">// 注意这里和切面并没有什么关系，切面在进入初始化之前就已经短路出去了</span></span><br><span class="line">        <span class="comment">// 这里只不过是使用cglib做的字节码增强（虽然切面也是使用cglib做的字节码增强）</span></span><br><span class="line">        <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们所需要的bean已经完成创建，只不过这个bean还空空如也，还需要填充相关的属性，当然最重要的是我们在代码里面使用Autowired的方式装配的一些属性了。</p><h3 id="属性填充"><a href="#属性填充" class="headerlink" title="属性填充"></a>属性填充</h3><p>填充属性代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 正常的流程来说这里我们获取到的bw肯定不是null，bw就是我们上一步生成的bean的持有者</span></span><br><span class="line">    <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                    mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give any InstantiationAwareBeanPostProcessors the opportunity to modify the</span></span><br><span class="line">    <span class="comment">// state of the bean before properties are set. This can be used, for example,</span></span><br><span class="line">    <span class="comment">// to support styles of field injection.</span></span><br><span class="line">    <span class="comment">// InstantiationAwareBeanPostProcessors类提供了在bean的实例化完成后、属性填充前的扩展机制</span></span><br><span class="line">    <span class="comment">// 这也是一种BeanPostProcessor，只不过比较特殊，后面回调函数还会分析BeanPostProcessor</span></span><br><span class="line">    <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">                    continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">    <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">        PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">        <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">            <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">                    InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">                    pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">                    <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">            checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置bean属性值</span></span><br><span class="line">    applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                invokeAwareMethods(beanName, bean);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, getAccessControlContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Aware接口回调</span></span><br><span class="line">        invokeAwareMethods(beanName, bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Object wrappedBean = bean;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// beanPostProcessor的postprocessBeforeinitialization方法回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// init方法回调</span></span><br><span class="line">        invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        <span class="comment">// beanpostprocessor的postprocessafterinitialization方法回调</span></span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析到此可以截止一个段落了，或许对我们来说依然是非常凌乱了，那我们还是总结一下上面创建javabean的思路吧：在容器的初始化阶段我们获取的信息是beandefinitionMap，存放beanname和beandefinition的一个map，有了这个信息我们就知道了我们要创建哪些bean了，接下来只要遍历这个map的key创建对应的bean就可以了，首先会根据是否是factorybean及eargeinit来决定是否需要马上创建，总之如果需要创建的话，最终都会走到同一个地方，接下来会判断是否由于循环引用导致创建该单例的对象提前创建了，如果对象提前创建了那直接返回就完事了，如果没有创建就会走到正常的创建流程，在正常创建之前还可以通过instinationawarebeanpostprocessor的切面操作来短路掉创建对象的过程，最后正常的创建流程也比较简单，就是反射生成对象、填充属性、执行回调函数，这里回调函数的顺序是aware、postprocessorbeforeinitinalition、init-method、postprocessorafterinitinalition（执行的是当前这个bean的回调函数！！）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于IOC的总结到此为止，后面会整理个小例子演示一下spring的扩展机制</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SPI机制</title>
      <link href="/2019/01/26/SPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/01/26/SPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>SPI全称叫做 service provider interface，是Jdk提供的供第三方的用来扩展已有服务的一种方案，通过这种机制我们将接口和实现分开，并可以在外部灵活的装配实现，这样说可能有点拗口，简单点说就是<strong>在面向接口编程的过程中提供了注入具体实现</strong>的策略。其核心类是ServiceLoader，该类会去默认指定的路径下加载对应的实现，并通过反射的方式来生成实现类的对象（多说一句，既然是通过反射的方式来生成对应的实现类的对象，那么可定是要求实现类提供一个默认的构造器，接下来可以验证以下）</p><h1 id="代码及流程演示"><a href="#代码及流程演示" class="headerlink" title="代码及流程演示"></a>代码及流程演示</h1><h2 id="定义接口及实现"><a href="#定义接口及实现" class="headerlink" title="定义接口及实现"></a>定义接口及实现</h2><p>接口如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接下来定义两个实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i'm a teacher !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"i'm a student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现发现"><a href="#实现发现" class="headerlink" title="实现发现"></a>实现发现</h2><p>对于服务的发现我们需要在classpath下新建一个目录，路径为：<code>META-INF/services</code>，并在该路径下新建一个接口的全限定名文件，然后将该接口对应的实现类的全限定名写入，如下：</p><p><img src="//southrivers.github.io/2019/01/26/SPI机制/qxd.png" alt></p><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>接下来我们就可以通过测试来验证SPI机制了，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ServiceLoader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SPITest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Person&gt; peoples = ServiceLoader.load(Person<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Person p : peoples) &#123;</span><br><span class="line">            p.say();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面我们说过serviceLoader在完成类的加载之后，会通过反射的方式来生成实现类对应的对象，因此需要一个默认的构造器，我们可以验证一下，如下给Student类提供一个含参的构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    、、、、</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们再测试一下就会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.util.ServiceConfigurationError: com.h3c.Person: Provider com.h3c.Student could not be instantiated</span><br><span class="line">at java.util.ServiceLoader.fail(ServiceLoader.java:232)</span><br><span class="line">at java.util.ServiceLoader.access$100(ServiceLoader.java:185)</span><br><span class="line">at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:384)</span><br><span class="line">at java.util.ServiceLoader$LazyIterator.next(ServiceLoader.java:404)</span><br><span class="line">at java.util.ServiceLoader$1.next(ServiceLoader.java:480)</span><br><span class="line">at com.h3c.SPITest.main(SPITest.java:10)</span><br><span class="line">Caused by: java.lang.InstantiationException: com.h3c.Student</span><br><span class="line">at java.lang.Class.newInstance(Class.java:427)</span><br><span class="line">at java.util.ServiceLoader$LazyIterator.nextService(ServiceLoader.java:380)</span><br><span class="line">... 3 more</span><br><span class="line">Caused by: java.lang.NoSuchMethodException: com.h3c.Student.&lt;init&gt;()</span><br><span class="line">at java.lang.Class.getConstructor0(Class.java:3082)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:412)</span><br><span class="line">... 4 more</span><br></pre></td></tr></table></figure><p>因此这也验证了我们上面的猜想是正确的。</p><h1 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h1><p>我们在调用 ServiceLoader.load()方法的时候，会构建出一个新的serviceLoader对象，而该对象内部封装了一个内部类LazyIterator，通过类的名称我们可以知道这个类为一个迭代器，而且应该具备lazy的机制，也就是在我们生成serviceloader对象的时候，并不会为我们提供的实现类生成对象，而只有在遍历的时候才会初始化，核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasNextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (nextName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (configs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fullName = PREFIX + service.getName();</span><br><span class="line">                    <span class="keyword">if</span> (loader == <span class="keyword">null</span>)</span><br><span class="line">                        configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        configs = loader.getResources(fullName);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">                    fail(service, <span class="string">"Error locating configuration files"</span>, x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> ((pending == <span class="keyword">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pending = parse(service, configs.nextElement());</span><br><span class="line">            &#125;</span><br><span class="line">            nextName = pending.next();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            String cn = nextName;</span><br><span class="line">            nextName = <span class="keyword">null</span>;</span><br><span class="line">            Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                S p = service.cast(c.newInstance());</span><br><span class="line">                providers.put(cn, p);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                fail(service,</span><br><span class="line">                     <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>,</span><br><span class="line">                     x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>这里PREFIX就是我们存放接口全路径的文件夹的地址，通过这段代码我们可以知道，在遍历的时候我们会访问指定路径下的文件，并通过反射的方式生成对象，然后将类和对应的对象缓存起来。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>数据库驱动的加载，class.forName(“com.mysql.jdbc.Driver”)，待完善</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>使用serviceLoader可以将服务的装配与调用分离，实现业务的解偶，不过多线程的情况下是线程不安全的。参考链接：<a href="https://www.cnkirito.moe/spi/" target="_blank" rel="noopener">https://www.cnkirito.moe/spi/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>原码、补码、反码那些事</title>
      <link href="/2018/09/23/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
      <url>/2018/09/23/%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%E3%80%81%E5%8F%8D%E7%A0%81%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<!--https://blog.csdn.net/meism5/article/details/89883976-->]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
