<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://southrivers.github.io/warn.html">
<![endif]-->
<meta charset="utf-8">
<meta http-equiv="X-DNS-Prefetch-Control" content="on">
<link rel="dns-prefetch" href="http://southrivers.github.io">
<link rel="dns-prefetch" href="//www.google-analytics.com">
<link rel="prefetch" href="http://southrivers.github.io">
<link rel="prefetch" href="//www.google-analytics.com">


<link rel="prerender" href="http://southrivers.github.io">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://southrivers.github.io">
<meta name="author" content="John Doe">
<link rel="stylesheet" href="/css/JSimple.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>apache druid 源码走读 - 离亭燕</title>

<meta name="keywords" content>

<meta name="description " content>

    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [ ['$','$'], ["\\(","\\)"] ],
                processEscapes: true
            }
        });
    </script>


    

    

</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="夏">夏</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>首页</span></a>
        <a href="/archives" title="归档"><i class="fa fa-archives"></i><span>归档</span></a>

        <!-- custom single page of menus -->
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-sns-qr" href="javascript:"><i class="fa fa-telegram"></i></a>
</div>

<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">血刀老祖</h1>
        <h3 class="cover-siteTitle">码个蛋</h3>
        <p class="cover-siteDesc">东门黄犬</p>
        <div class="cover-sns">
            

        </div>
    </div>
</div>

            <div class="page-title">
    <ul>
        <li><a href="/">最近</a></li>
        

        
        <li class="page-search">
    <form id="search" class="search-form">
        <input type="text" readonly="readonly" id="local-search-input-tip" placeholder="读物检索~">
        <button type="button" disabled="disabled" class="search-form-submit"><i class="fa fa-search"></i></button>
    </form>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="http://southrivers.github.io" target="_blank">
                    <img width="48" src="/images/favicon.png" alt="avatar">
                </a>
                <p><span class="label">author</span>
                    <a href="http://southrivers.github.io" target="_blank">原站</a>
                    <span title="last_edited&nbsp;2019-10-19">2019-10-19</span>
                </p>
                <p>码个蛋️️</p>
            </div>
            <h2 class="post-title">apache druid 源码走读</h2>

        </div>
        <div class="post-content markdown-body">
            <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>监控也做了一段时间了，短短续续接触过一系列的存储与计算相关的组件，机缘巧合接触到了druid（并不是阿里的数据库连接池工具），
这是一款用于OLAP的存储组件，鉴于其高效的查询效率，在初步了解、使用以及弄清楚整体的架构之后，也对其源码产生了较大的兴趣，
由于官网上对其使用、介绍也是比较全面的，因此在此略讲这些东西，看后面有时间再补齐。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>下图是druid数据流图</p>
<p><img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/structure1.png" alt></p>
<p>对于上图简要的介绍一下：</p>
<ul>
<li>router是用来分发请求的</li>
<li>broker是用来将查询结果合并的，通常建议可以和router合并在一起</li>
<li>middlemanager和historical是用来存放未发布的和已经发布的数据的</li>
<li>overlaod是用来保障高可用的</li>
<li>coordinator是用来管理segment（数据）的，包括了数据的发布、均衡等操作</li>
</ul>
<p>官方推荐的部署架构如下图所示：</p>
<p><img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/bushu1.png" alt></p>
<h1 id="源码走读"><a href="#源码走读" class="headerlink" title="源码走读"></a>源码走读</h1><p>在深入了解每一个模块之前，我们有必要对整个工程的启动、运行流程有一定的了解，不然就是老虎吃天，无从下口。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>万物皆有入口，哈哈哈！那么druid的入口在哪里呢？查看启动的脚本就会发现，入口就在Main类的main方法，多么自然，在程序中万物的运行始于
main函数。从代码开始看起吧！为了方便理解，我是将代码分成多段进行讲解了，具体的的步骤：</p>
<h3 id="构建builder对象"><a href="#构建builder对象" class="headerlink" title="构建builder对象"></a>构建builder对象</h3><p>构建builder对象，该对象是管理我们在工程中使用到的命令行的工具箱，我们可以将其想像成一个箱子。通俗点来讲，
我假设大家都是用过git工具的，这个builder对象就有点类似于<code>git</code>命令，<code>git</code>包含<code>git remote 、git add</code>等工具，
因此也可以将<code>git</code>看作一个箱子，这个箱子里面包含了各种各样的工具可以让我们使用，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Cli.CliBuilder&lt;Runnable&gt; builder = Cli.builder(<span class="string">"druid"</span>);</span><br><span class="line">    builder.withDescription(<span class="string">"Druid command-line runner."</span>)</span><br><span class="line">           .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">withCommands</span>(<span class="title">Help</span>.<span class="title">class</span>, <span class="title">Version</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="添加分组"><a href="#添加分组" class="headerlink" title="添加分组"></a>添加分组</h3><p>给我们的builder对象添加各种命令，在直接添加命令之前，这里先对其做了分组的工作，还是以git为例，
<code>git remote</code>的<code>remote</code>其实就是一个分组的作用，其下面包含的有<code>git remote add、git remote update</code>
等命令，正如我们在上面的代码中看到的那样，druid也对命令做了多个分组： <code>server、tools、index、internal</code>，
也就是说我们要使用调用server下的某一个process的时候，需要加上server组名才可以调通。那么server能调用的命令
包含那些呢？要知道分组下的命令可以直接到对应的类上面看其<code>@Command</code>注解即可，我们还是以middleManager为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Command</span>(</span><br><span class="line">    name = <span class="string">"middleManager"</span>,</span><br><span class="line">    description = <span class="string">"Runs a Middle Manager, this is a \"task\" node used as part of the remote indexing service, see https://druid.apache.org/docs/latest/design/middlemanager.html for a description"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CliMiddleManager</span> <span class="keyword">extends</span> <span class="title">ServerRunnable</span></span></span><br></pre></td></tr></table></figure>

<p>这也就是说，当我们想要运行middleManager的时候，向main函数传递的参数应该是 <code>main server middleManager</code>，类比其他的process
我们也就很好理解了，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Class&lt;? extends Runnable&gt;&gt; serverCommands = Arrays.asList(</span><br><span class="line">    CliCoordinator<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliHistorical</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliBroker</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliOverlord</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliIndexer</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliMiddleManager</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CliRouter</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line"><span class="comment">// group可以认为是命令行的前缀</span></span><br><span class="line">builder.withGroup(<span class="string">"server"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Run one of the Druid server types."</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">serverCommands</span>)</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Class&lt;? extends Runnable&gt;&gt; toolCommands = Arrays.asList(</span><br><span class="line">    DruidJsonValidator<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">PullDependencies</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">CreateTables</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">DumpSegment</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ResetCluster</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ValidateSegments</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">    <span class="title">ExportMetadata</span>.<span class="title">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line">builder.withGroup(<span class="string">"tools"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Various tools for working with Druid"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">toolCommands</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.withGroup(<span class="string">"index"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Run indexing for druid"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">CliHadoopIndexer</span>.<span class="title">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">builder.withGroup(<span class="string">"internal"</span>)</span><br><span class="line">       .withDescription(<span class="string">"Processes that Druid runs \"internally\", you should rarely use these directly"</span>)</span><br><span class="line">       .withDefaultCommand(Help<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">       .<span class="title">withCommands</span>(<span class="title">CliPeon</span>.<span class="title">class</span>, <span class="title">CliInternalHadoopIndexer</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h3 id="构建工厂"><a href="#构建工厂" class="headerlink" title="构建工厂"></a>构建工厂</h3><p>构建一个Injector，这里使用到了guice这款谷歌开源的IOC框架，相信用过spring的人都知道或者了解IOC的机制了，这里就不对IOC讨论了。
简单的类比一下guice中的概念和spring中的概念，injector可以类比为spring中的ApplicationContext，在spring中我们可以使用context来获取
某一个对象，那么injector也必然是可以用来获取某一个对象了！是的。injector的主要作用就是存放各种java bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Injector injector = GuiceInjectors.makeStartupInjector();</span><br></pre></td></tr></table></figure>

<h3 id="获取扩展配置信息"><a href="#获取扩展配置信息" class="headerlink" title="获取扩展配置信息"></a>获取扩展配置信息</h3><p>获取ExtensionsConfig对象，这里是druid给我们提供的扩展机制，在main函数中，该类主要适用于命令行工具的扩展，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ExtensionsConfig config = injector.getInstance(ExtensionsConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">// 加载CliCommandCreator对应的实现类，默认情况下应该是没有的，这里加载也是采用了SPI的机制</span></span><br><span class="line"><span class="keyword">final</span> Collection&lt;CliCommandCreator&gt; extensionCommands = Initialization.getFromExtensions(</span><br><span class="line">    config,</span><br><span class="line">    CliCommandCreator<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">)</span>;</span><br><span class="line"><span class="keyword">for</span> (CliCommandCreator creator : extensionCommands) &#123;</span><br><span class="line">  creator.addCommands(builder);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Cli&lt;Runnable&gt; cli = builder.build();</span><br></pre></td></tr></table></figure>

<p>我们进CliCommandCreator看一下会发现是一个接口，并且没有任何实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CliCommandCreator</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCommands</span><span class="params">(Cli.CliBuilder builder)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那为什么还要循环遍历这个集合呢？看的一脸懵逼吧，这里是java里面给我们提供的SPI机制来扩展命令行的，不过默认并没有任何实现，因此该段代码可以略过。</p>
<h3 id="解析命令并执行process"><a href="#解析命令并执行process" class="headerlink" title="解析命令并执行process"></a>解析命令并执行process</h3><p>解析命令并运行相关的process，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Runnable command = cli.parse(args);</span><br><span class="line"><span class="keyword">if</span> (!(command <span class="keyword">instanceof</span> Help)) &#123; <span class="comment">// Hack to work around Help not liking being injected</span></span><br><span class="line"><span class="comment">// 这里会将command对应的对象进行注入进来</span></span><br><span class="line">injector.injectMembers(command);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里最终是会调用对应的组件，如middlemanager的run方法的</span></span><br><span class="line">command.run();</span><br></pre></td></tr></table></figure>

<p>到此位置我们将main函数的主要流程分析清楚了，接下来我们就从server组里的middlemanager这个command来看一下吧。
在main方法的最后，我们看到了<code>command.run()</code>这个方法的调用，那么这个方法最终会在哪里触发执行呢？这就和我们在
使用命令行的时候server后面跟的参数有关系了。还是以middlemanager为例来分析吧（其他的都一样）。</p>
<h2 id="执行process"><a href="#执行process" class="headerlink" title="执行process"></a>执行process</h2><p>在讲解代码流程之前，我们先看一下该process对应的类图：
<img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/middlemanager-structure1.png" alt>
可以看到<code>command.run()</code>方法最终应该是会触发serverRunnable处的run方法的执行，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 构建本实例所需要的工厂对象，用于后面生成对象</span></span><br><span class="line"><span class="keyword">final</span> Injector injector = makeInjector();</span><br><span class="line"><span class="keyword">final</span> Lifecycle lifecycle = initLifecycle(injector);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  lifecycle.join();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码可以分为3步：</p>
<ul>
<li>构建当前process需要的injetor对象，可能有的人会比较疑惑，前面构建了一个injector，这里又构建了一个，
那么这两个injector有没有必要合并成一个，这样两个injector中的java bean共享一个上下文，这里
完全没必要担心，跟进代码你会发现，这里生成的injector就是使用上面生成的baseInjector来生成的，
这也就是说，上文中构建的injector缺少特定的process所需要的java bean，这里就是在原来的injector
基础之上又装配了当前这个process所需要的java bean。</li>
<li>初始化injector的生命周期，这里的作用是实例化injector中非lazy类型的java bean，启动整个工程（可以认为是一个核心了）</li>
<li>等待程序运行结束</li>
</ul>
<p>接下来我们还是继续分析<code>makeInjector()</code>具体执行了什么操作吧，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Injector <span class="title">makeInjector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Initialization.makeInjectorWithModules(baseInjector, getModules());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上面的方法就是给baseInjector注入process所需要的功能java bean。这里的baseInjector是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Injector injector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.baseInjector = injector;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到这里的baseInjector是使用guice的注解装配进来的injector，也就是我们最早定义的injector。
点进去<code>getModules()</code>可以发现这是一个接口，嗯，没错这里是使用到了模板模式！真正的实现放到了对应的process中去了。
进入makeInjectorWithModules方法可以看到使用了<code>Guice.createInjector(Modules.override(oldmodules).with(newmodules))</code>
这种方式来获取新的injector。在将特定process的java bean装配到injector之后，接下来就是要执行程序的初始化了，也就是该创建的
对象创建，该开启的端口开启就完事了，我们来看一下具体的代码吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">initLifecycle</span><span class="params">(Injector injector)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取lifecycle实例，该实例会初始化工程所必须的对象</span></span><br><span class="line">      <span class="keyword">final</span> Lifecycle lifecycle = injector.getInstance(Lifecycle<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      <span class="keyword">final</span> StartupLoggingConfig startupLoggingConfig = injector.getInstance(StartupLoggingConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">      Long directSizeBytes = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        directSizeBytes = JvmUtils.getRuntimeInfo().getDirectMemorySizeBytes();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (UnsupportedOperationException ignore) &#123;</span><br><span class="line">        <span class="comment">// querying direct memory is not supported</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      log.info(</span><br><span class="line">          <span class="string">"Starting up with processors[%,d], memory[%,d], maxMemory[%,d]%s. Properties follow."</span>,</span><br><span class="line">          JvmUtils.getRuntimeInfo().getAvailableProcessors(),</span><br><span class="line">          JvmUtils.getRuntimeInfo().getTotalHeapSizeBytes(),</span><br><span class="line">          JvmUtils.getRuntimeInfo().getMaxHeapSizeBytes(),</span><br><span class="line">          directSizeBytes != <span class="keyword">null</span> ? StringUtils.format(<span class="string">", directMemory[%,d]"</span>, directSizeBytes) : <span class="string">""</span></span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (startupLoggingConfig.isLogProperties()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; maskProperties = Sets.newHashSet(startupLoggingConfig.getMaskProperties());</span><br><span class="line">        <span class="keyword">final</span> Properties props = injector.getInstance(Properties<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String propertyName : Ordering.natural().sortedCopy(props.stringPropertyNames())) &#123;</span><br><span class="line">          String property = props.getProperty(propertyName);</span><br><span class="line">          <span class="keyword">for</span> (String masked : maskProperties) &#123;</span><br><span class="line">            <span class="keyword">if</span> (propertyName.contains(masked)) &#123;</span><br><span class="line">              property = <span class="string">"&lt;masked&gt;"</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          log.info(<span class="string">"* %s: %s"</span>, propertyName, property);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        lifecycle.start();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(t, <span class="string">"Error when starting up.  Failing."</span>);</span><br><span class="line">        System.exit(<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> lifecycle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码比较长，不过总的来说只有两行有效代码：
<code>final Lifecycle lifecycle = injector.getInstance(Lifecycle.class)</code>和<code>lifecycle.start()</code>
这两行代码分别是从injector中获取lifecycle对象，调用lifecycle对象的start方法，
这里我们点进去LifeCycle的类，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  ........</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    startStopLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!state.get().equals(State.NOT_STARTED)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ISE(<span class="string">"Already started"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!state.compareAndSet(State.NOT_STARTED, State.RUNNING)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ISE(<span class="string">"stop() is called concurrently with start()"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Map.Entry&lt;Stage, ? extends List&lt;Handler&gt;&gt; e : handlers.entrySet()) &#123;</span><br><span class="line">        currStage = e.getKey();</span><br><span class="line">        log.info(<span class="string">"Starting lifecycle [%s] stage [%s]"</span>, name, currStage.name());</span><br><span class="line">        <span class="keyword">for</span> (Handler handler : e.getValue()) &#123;</span><br><span class="line">          handler.start();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      log.info(<span class="string">"Successfully started lifecycle [%s]"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      startStopLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>如果你是看到了上面的代码，那么恭喜你，你找错方向了！仔细看上面，我们是调用了<code>injector.getInstance(Lifecycle.class)</code>
来获取lifecycle对象，也就你要从工厂中获取该对象，很明显上面的这个类并没有使用guice提供的
注解来将其装配到injector中，因此这里并不是我们想要的代码。那么真正的实现在哪里呢？在LifeCycleModule
类中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @provides注解是用来生成java bean的一种方式，这里也就是生成整个工程所需要的lifecycle对象</span></span><br><span class="line"><span class="meta">@Provides</span> <span class="meta">@LazySingleton</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">(<span class="keyword">final</span> Injector injector)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">final</span> Key&lt;Set&lt;KeyHolder&gt;&gt; keyHolderKey = Key.get(<span class="keyword">new</span> TypeLiteral&lt;Set&lt;KeyHolder&gt;&gt;()&#123;&#125;, Names.named(<span class="string">"lifecycle"</span>));</span><br><span class="line"><span class="keyword">final</span> Set&lt;KeyHolder&gt; eagerClasses = injector.getInstance(keyHolderKey);</span><br><span class="line"></span><br><span class="line">Lifecycle lifecycle = <span class="keyword">new</span> Lifecycle(<span class="string">"module"</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="comment">// 这里是所有的组件最终的入口，可以看到调用了lifecycle的start方法之后该实例化的对象都实例化了</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (KeyHolder&lt;?&gt; holder : eagerClasses) &#123;</span><br><span class="line">      <span class="comment">// 初始化工厂中的对象</span></span><br><span class="line">      injector.getInstance(holder.getKey()); <span class="comment">// Pull the key so as to "eagerly" load up the class.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里是继续装配lifecycle对象</span></span><br><span class="line">initScope.setLifecycle(lifecycle);</span><br><span class="line">normalScope.setLifecycle(lifecycle);</span><br><span class="line">serverScope.setLifecycle(lifecycle);</span><br><span class="line">annoucementsScope.setLifecycle(lifecycle);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> lifecycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面才是lifecycle.start方法执行的操作，这一步我们看到是有一个for循环的操作，该操作就是实例化我们当前process需要的
对象了，最终会调用join方法等待当前的process退出。这里首先是使用<code>Key.get(new TypeLiteral&lt;Set&lt;KeyHolder&gt;&gt;(){}, Names.named(&quot;lifecycle&quot;))</code>
来获取一系列的Key值，这些Key值是<code>Set&lt;KeyHolder&gt;</code>类型的，并且被<code>@Names(&quot;lifecycle&quot;)</code>注解了的，guice中的Key值是什么概念呢？可以认为是spring中的
beanName，在spring中我们是可以通过beanName的方式来直接从容器中获取bean的，因此这里也是为了下面获取bean的而做的准备。不过我们可能会很好奇，这些个
被<code>@Names(&quot;lifecycle&quot;)</code>标注的过程是在哪里呢？这个就要返回到上面<code>makeInjector</code>方法了，在创建injector的时候，我们有提到过<code>getModules</code>方法，不过
是一笔略过的，现在就看一下这些个依赖是如何在启动的过程中被加进来的吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> List&lt;? extends Module&gt; getModules()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// Server.class和SelfDiscoveryResource.class注册到了生命周期的管理，会在项目启动的时候就实例化对应的对象</span></span><br><span class="line"><span class="keyword">return</span> ImmutableList.of(</span><br><span class="line">    <span class="keyword">new</span> Module()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(Binder binder)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">        .......</span><br><span class="line">        LifecycleModule.register(binder, Server<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">        .......</span><br><span class="line">        LifecycleModule.registerKey(binder, Key.get(SelfDiscoveryResource<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到对于CliMiddleManager这个process来说，在装配自定义的Module的时候，是注册了两个类的，我们来看一下这个注册的过程是什么样子的吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerKey</span><span class="params">(Binder binder, Key&lt;?&gt; key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">getEagerBinder(binder).addBinding().toInstance(<span class="keyword">new</span> KeyHolder&lt;Object&gt;(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Multibinder&lt;KeyHolder&gt; <span class="title">getEagerBinder</span><span class="params">(Binder binder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">return Multibinder.newSetBinder(binder, KeyHolder.class, Names.named("lifecycle"));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是注册过程中调用的方法链了，这里还是来解释一下：<code>Multibinder.newSetBinder(binder, KeyHolder.class, Names.named(&quot;lifecycle&quot;))
.addBinding().toInstance(new KeyHolder&lt;Object&gt;(key))</code>，整个方法的调用的话就如同上面这个样子，这里的含义是会将多个类都
存放到Set<keyholder>中来，每调用一次注册的方法，就会生成一个<code>new KeyHolder&lt;Object&gt;(key)</code>来持有我们希望在process初始化的过程中实例化的对象。</keyholder></p>
<p>我们现在再回到上文看一下就不难发现<code>Set&lt;KeyHolder&gt; eagerClasses = injector.getInstance(keyHolderKey)</code>获取到的就是上面我们注册类进来的时候
生成的集合，不过这个集合现在持有的并不是实例化之后的对象，而是<code>Set&lt;KeyHolder&gt;</code>，这里的<code>KeyHolder</code>是会持有一个Class的，我们通过遍历这个集合类就
可以完成当前process在启动之处就需要实例化的类了。</p>
<p>在<code>geModules</code>方法中我们看到，当前的process注册的类中有一个Server类，这个类必然会在lifecycle的start方法中被实例化，不过实例化的类在哪里呢？在JettyServerModule这个类中
提供了具体的实现，我们来看一下实例化一个Server对象的时候究竟发生了什么吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Provides</span></span><br><span class="line"><span class="meta">@LazySingleton</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Server <span class="title">getServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">    @Self <span class="keyword">final</span> DruidNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ServerConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> TLSServerConfig TLSServerConfig</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> makeAndInitializeServer(</span><br><span class="line">      injector,</span><br><span class="line">      lifecycle,</span><br><span class="line">      node,</span><br><span class="line">      config,</span><br><span class="line">      TLSServerConfig,</span><br><span class="line">      injector.getExistingBinding(Key.get(SslContextFactory<span class="class">.<span class="keyword">class</span>)),</span></span><br><span class="line"><span class="class">      <span class="title">injector</span>.<span class="title">getInstance</span>(<span class="title">TLSCertificateChecker</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">  )</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们看到Server的创建依赖其他的五个对象，这些类在前面的module中都是已经被注入到injector中了，因此当我们获取Server对象的时候，这些
对象也就会通过深度遍历的方式给依次注入进来，这里我们也不做过多的讨论了，就看一下创建Server的过程吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Server <span class="title">makeAndInitializeServer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">    Lifecycle lifecycle,</span></span></span><br><span class="line"><span class="function"><span class="params">    DruidNode node,</span></span></span><br><span class="line"><span class="function"><span class="params">    ServerConfig config,</span></span></span><br><span class="line"><span class="function"><span class="params">    TLSServerConfig tlsServerConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">    Binding&lt;SslContextFactory&gt; sslContextFactoryBinding,</span></span></span><br><span class="line"><span class="function"><span class="params">    TLSCertificateChecker certificateChecker</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// adjusting to make config.getNumThreads() mean, "number of threads</span></span><br><span class="line">  <span class="comment">// that concurrently handle the requests".</span></span><br><span class="line">  <span class="keyword">int</span> numServerThreads = config.getNumThreads() + getMaxJettyAcceptorsSelectorsNum(node);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> QueuedThreadPool threadPool;</span><br><span class="line">  <span class="keyword">if</span> (config.getQueueSize() == Integer.MAX_VALUE) &#123;</span><br><span class="line">    threadPool = <span class="keyword">new</span> QueuedThreadPool();</span><br><span class="line">    threadPool.setMinThreads(numServerThreads);</span><br><span class="line">    threadPool.setMaxThreads(numServerThreads);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    threadPool = <span class="keyword">new</span> QueuedThreadPool(</span><br><span class="line">        numServerThreads,</span><br><span class="line">        numServerThreads,</span><br><span class="line">        <span class="number">60000</span>, <span class="comment">// same default is used in other case when threadPool = new QueuedThreadPool()</span></span><br><span class="line">        <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(config.getQueueSize())</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadPool.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Server server = <span class="keyword">new</span> Server(threadPool);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Without this bean set, the default ScheduledExecutorScheduler runs as non-daemon, causing lifecycle hooks to fail</span></span><br><span class="line">  <span class="comment">// to fire on main exit. Related bug: https://github.com/apache/druid/pull/1627</span></span><br><span class="line">  server.addBean(<span class="keyword">new</span> ScheduledExecutorScheduler(<span class="string">"JettyScheduler"</span>, <span class="keyword">true</span>), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> List&lt;ServerConnector&gt; serverConnectors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.isEnablePlaintextPort()) &#123;</span><br><span class="line">    log.info(<span class="string">"Creating http connector with port [%d]"</span>, node.getPlaintextPort());</span><br><span class="line">    HttpConfiguration httpConfiguration = <span class="keyword">new</span> HttpConfiguration();</span><br><span class="line">    <span class="keyword">if</span> (config.isEnableForwardedRequestCustomizer()) &#123;</span><br><span class="line">      httpConfiguration.addCustomizer(<span class="keyword">new</span> ForwardedRequestCustomizer());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpConfiguration.setRequestHeaderSize(config.getMaxRequestHeaderSize());</span><br><span class="line">    <span class="keyword">final</span> ServerConnector connector = <span class="keyword">new</span> ServerConnector(server, <span class="keyword">new</span> HttpConnectionFactory(httpConfiguration));</span><br><span class="line">    <span class="keyword">if</span> (node.isBindOnHost()) &#123;</span><br><span class="line">      connector.setHost(node.getHost());</span><br><span class="line">    &#125;</span><br><span class="line">    connector.setPort(node.getPlaintextPort());</span><br><span class="line">    serverConnectors.add(connector);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> ServerConnector[] connectors = <span class="keyword">new</span> ServerConnector[serverConnectors.size()];</span><br><span class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (ServerConnector connector : serverConnectors) &#123;</span><br><span class="line">    connectors[index++] = connector;</span><br><span class="line">    connector.setIdleTimeout(Ints.checkedCast(config.getMaxIdleTime().toStandardDuration().getMillis()));</span><br><span class="line">    <span class="comment">// workaround suggested in -</span></span><br><span class="line">    <span class="comment">// https://bugs.eclipse.org/bugs/show_bug.cgi?id=435322#c66 for jetty half open connection issues during failovers</span></span><br><span class="line">    connector.setAcceptorPriorityDelta(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    List&lt;ConnectionFactory&gt; monitoredConnFactories = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ConnectionFactory cf : connector.getConnectionFactories()) &#123;</span><br><span class="line">      <span class="comment">// we only want to monitor the first connection factory, since it will pass the connection to subsequent</span></span><br><span class="line">      <span class="comment">// connection factories (in this case HTTP/1.1 after the connection is unencrypted for SSL)</span></span><br><span class="line">      <span class="keyword">if</span> (cf.getProtocol().equals(connector.getDefaultProtocol())) &#123;</span><br><span class="line">        monitoredConnFactories.add(<span class="keyword">new</span> JettyMonitoringConnectionFactory(cf, ACTIVE_CONNECTIONS));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        monitoredConnFactories.add(cf);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    connector.setConnectionFactories(monitoredConnFactories);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  server.setConnectors(connectors);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> gracefulStop = config.getGracefulShutdownTimeout().toStandardDuration().getMillis();</span><br><span class="line">  <span class="keyword">if</span> (gracefulStop &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    server.setStopTimeout(gracefulStop);</span><br><span class="line">  &#125;</span><br><span class="line">  server.addLifeCycleListener(<span class="keyword">new</span> LifeCycle.Listener()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStarting</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle starting [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStarted</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifeycle started [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleFailure</span><span class="params">(LifeCycle event, Throwable cause)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.error(cause, <span class="string">"Jetty lifecycle event failed [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStopping</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle stopping [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifeCycleStopped</span><span class="params">(LifeCycle event)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      log.debug(<span class="string">"Jetty lifecycle stopped [%s]"</span>, event.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize server</span></span><br><span class="line">  JettyServerInitializer initializer = injector.getInstance(JettyServerInitializer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    initializer.initialize(server, injector);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RE(e, <span class="string">"server initialization exception"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  lifecycle.addHandler(</span><br><span class="line">      <span class="keyword">new</span> Lifecycle.Handler()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          log.debug(<span class="string">"Starting Jetty Server..."</span>);</span><br><span class="line">          server.start();</span><br><span class="line">          <span class="keyword">if</span> (node.isEnableTlsPort()) &#123;</span><br><span class="line">            <span class="comment">// Perform validation</span></span><br><span class="line">            Preconditions.checkNotNull(sslContextFactory);</span><br><span class="line">            <span class="keyword">final</span> SSLEngine sslEngine = sslContextFactory.newSSLEngine();</span><br><span class="line">            <span class="keyword">if</span> (sslEngine.getEnabledCipherSuites() == <span class="keyword">null</span> || sslEngine.getEnabledCipherSuites().length == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ISE(</span><br><span class="line">                  <span class="string">"No supported cipher suites found, supported suites [%s], configured suites include list: [%s] exclude list: [%s]"</span>,</span><br><span class="line">                  Arrays.toString(sslEngine.getSupportedCipherSuites()),</span><br><span class="line">                  tlsServerConfig.getIncludeCipherSuites(),</span><br><span class="line">                  tlsServerConfig.getExcludeCipherSuites()</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sslEngine.getEnabledProtocols() == <span class="keyword">null</span> || sslEngine.getEnabledProtocols().length == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> ISE(</span><br><span class="line">                  <span class="string">"No supported protocols found, supported protocols [%s], configured protocols include list: [%s] exclude list: [%s]"</span>,</span><br><span class="line">                  Arrays.toString(sslEngine.getSupportedProtocols()),</span><br><span class="line">                  tlsServerConfig.getIncludeProtocols(),</span><br><span class="line">                  tlsServerConfig.getExcludeProtocols()</span><br><span class="line">              );</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> unannounceDelay = config.getUnannouncePropagationDelay().toStandardDuration().getMillis();</span><br><span class="line">            <span class="keyword">if</span> (unannounceDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">              log.info(<span class="string">"Sleeping %s ms for unannouncement to propagate."</span>, unannounceDelay);</span><br><span class="line">              Thread.sleep(unannounceDelay);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              log.debug(<span class="string">"Skipping unannounce wait."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">"Stopping Jetty Server..."</span>);</span><br><span class="line">            server.stop();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RE(e, <span class="string">"Interrupted waiting for jetty shutdown."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(e, <span class="string">"Unable to stop Jetty server."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      Lifecycle.Stage.SERVER</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> server;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码比较长，不过总结下来也就分以下三个步骤：</p>
<ul>
<li>创建web server：包含了配置server处理请求所需的线程池，server处理请求的逻辑connector，server在整个生命周期中需要的一些个listener（这个在tomcat中是比较常见的）
，以及会在<code>initializer.initialize(server, injector);</code>方法中初始化server拦截的请求、需要的filter等。</li>
<li>添加handler到lifecycle的handlers中去，这一步的作用是一个hook的作用，也就是说把server的start方法挂到了lifecycle的start方法中了，这样当我们调用lifecycle的start方法
启动整个应用之后，自然而然我们的server也就启动了，我们在添加的handler中也可以看到<code>server.start();</code>方法的调用</li>
<li>返回server实例</li>
</ul>
<p>到此为止，我们看到了lifecycle的start方法，带动了server的创建，其中server的创建又配置了handler，这些个handler的一次调用是在哪里呢？是在parent的lifecycle中，如下：</p>
<p><em>说明一下，在整个process启动的过程中并不是只添加了一个server的handler，还有CuratorFramework，也就是负责和zookeeper保持通信的客户端
，如果想要知道全部的handler，可以直接搜<code>lifecycle.addHandler</code>就可以了</em></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  startStopLock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Stage, ? extends List&lt;Handler&gt;&gt; e : handlers.entrySet()) &#123;</span><br><span class="line">      currStage = e.getKey();</span><br><span class="line">      log.info(<span class="string">"Starting lifecycle [%s] stage [%s]"</span>, name, currStage.name());</span><br><span class="line">      <span class="keyword">for</span> (Handler handler : e.getValue()) &#123;</span><br><span class="line">        handler.start();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"Successfully started lifecycle [%s]"</span>, name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    startStopLock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析到这里我们就看到了完整的process的启动，带动了web server的启动。不过我们好像并没有看到这个web server可以处理的请求是怎么样给加进来的（
虽然我们在上面看到了配置web server拦截所有的请求，不过这只是默认的servlet而已，并不是我们在应用中自定义的resource）。添加自定义resource
是在<code>JettyServerModule#configureServlets</code>方法中加进来的，我们具体看一下这个过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureServlets</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Binder binder = binder();</span><br><span class="line">  .....</span><br><span class="line">  binder.bind(GuiceContainer<span class="class">.<span class="keyword">class</span>).<span class="title">to</span>(<span class="title">DruidGuiceContainer</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  binder.bind(DruidGuiceContainer<span class="class">.<span class="keyword">class</span>).<span class="title">in</span>(<span class="title">Scopes</span>.<span class="title">SINGLETON</span>)</span>;</span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  serve(<span class="string">"/*"</span>).with(DruidGuiceContainer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  Jerseys.addResource(binder, StatusResource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">  binder.bind(StatusResource<span class="class">.<span class="keyword">class</span>).<span class="title">in</span>(<span class="title">LazySingleton</span>.<span class="title">class</span>)</span>;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里我么看到<code>serve(&quot;/*&quot;).with(DruidGuiceContainer.class)</code>这么一行代码，查看<code>DruidGuiceContainer</code>的类图:
<img src="//southrivers.github.io/2019/10/19/apache-druid-源码走读/servlet.png" alt>
可以发现该类本身就是一个servlet，不过这里还是先想一下<code>DruidGuiceContainer</code>对象从何而来？如果你认为是通过无参的构造函数
反射获得的话，那么很明显又跑题了，要知道我们整个应用都是基于guice来完成的，因此，理所当然的，我们的<code>DruidGuiceContainer</code>
也必然是通过容器获取到的，证明就在上面两行代码，现在我们进到这个类里面来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidGuiceContainer</span> <span class="keyword">extends</span> <span class="title">GuiceContainer</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Class&lt;?&gt;&gt; resources;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Inject</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DruidGuiceContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Injector injector,</span></span></span><br><span class="line"><span class="function"><span class="params">      @JSR311Resource Set&lt;Class&lt;?&gt;&gt; resources</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(injector);</span><br><span class="line">    <span class="keyword">this</span>.resources = resources;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ResourceConfig <span class="title">getDefaultResourceConfig</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Map&lt;String, Object&gt; props, WebConfig webConfig</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultResourceConfig(resources);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上，可以看到构造函数上用<code>@Inject</code>来标注了，说明是采用构造器注入的方式来创建该对象的，构造器包含了两个参数，很明显第一个参数
就是我们在main函数中生成的injector，这个injector在整个工程中传来传去，目的就是构造一个统一的上下文。<strong>而第二个参数就比较关键了，
也是扩展web工程的关键，其所代表的含义是，<code>DruidGuiceContainer</code>需要一组使用了<code>@JSR311Resource</code>标注的类的集合来创建，这
也标志着我们可以将某些类以<code>@JSR311Resource</code>的方式注入到injector中，这些被注解标注了的并且注入到injector里面的类最终将会
作为<code>DruidGuiceContainer</code>这个servlet的初始化参数，servlet在拦截到请求之后会根据请求的参数路由到对应的<code>resources</code>进行处理。</strong></p>
<p>接下来我们就来随便找一个例子来看一下这些个resource是怎么样装配到servlet上来的吧，我们在process的代码中基本上是随处可见这样的代码：
<code>Jerseys.addResource(binder, ShuffleResource.class);</code>，我们继续跟下去：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addResource</span><span class="params">(Binder binder, Class&lt;?&gt; resourceClazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LOG.debug(<span class="string">"Adding Jersey resource: "</span> + resourceClazz.getName());</span><br><span class="line">Multibinder.newSetBinder(binder, <span class="keyword">new</span> TypeLiteral&lt;Class&lt;?&gt;&gt;() &#123;&#125;, JSR311Resource<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">           .<span class="title">addBinding</span>()</span></span><br><span class="line"><span class="class">           .<span class="title">toInstance</span>(<span class="title">resourceClazz</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，可以看到这里是将我们指定的resourceClazz通过Multibinder注入到了injector中，而且在注入的过程中添加了<code>JSR311Resource.class</code>
的注解，那么根据上面的分析可以知道，这个resourceClazz将会作为一个resource，最终通过servlet的路由匹配到响应的请求。</p>
<p>至此，关于整个process启动的过程中web相关的模块我们已经基本理清了。接下来我们就来通过process所支持的功能来具体的分析一下process的具体
实现吧。</p>
<h2 id="overlord源码走读"><a href="#overlord源码走读" class="headerlink" title="overlord源码走读"></a>overlord源码走读</h2><p>overlord控制着摄入任务的分配工作，这个分配工作是在提交摄入规则的时候触发的。</p>
<p>Overlord的故事从什么地方说起呢？前面我们看到了MiddleManager模块的web工程启动的过程，这一块的逻辑是通用的，因此就不再赘述了，不过可以看到
Lifecycle在工程中的作用，那就是一个钩子，在Overlord中也有类似的模块，在程序启动的时候会触发执行，不过在Overlord的modules中是使用注解来hook的，下面是
SupervisorManager中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LifecycleStart</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 从数据库中加载对应的数据完成supervisor的启动</span></span><br><span class="line">  Preconditions.checkState(!started, <span class="string">"SupervisorManager already started"</span>);</span><br><span class="line">  log.info(<span class="string">"Loading stored supervisors from database"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">    Map&lt;String, SupervisorSpec&gt; supervisors = metadataSupervisorManager.getLatest();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, SupervisorSpec&gt; supervisor : supervisors.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">final</span> SupervisorSpec spec = supervisor.getValue();</span><br><span class="line">      <span class="keyword">if</span> (!(spec <span class="keyword">instanceof</span> NoopSupervisorSpec)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          createAndStartSupervisorInternal(spec, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">          log.error(ex, <span class="string">"Failed to start supervisor: [%s]"</span>, spec.getId());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码逻辑分成两块：</p>
<ul>
<li>获取数据库中存放的摄入规则</li>
<li>根据获取到的摄入规则创建supervisor</li>
</ul>
<p>这里我们还是按照之前的策略来纵深穿插看一下这一块的逻辑吧,获取摄入规则是使用<code>metadataSupervisorManager</code>这个对象获取的，
这个对象是在构造函数中通过guice装配进来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inject</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SupervisorManager</span><span class="params">(MetadataSupervisorManager metadataSupervisorManager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.metadataSupervisorManager = metadataSupervisorManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多插一句，这里<code>MetadataSupervisorManager</code>注入到injector的方式并不是通过前面看到的bind注入进来的，而是通过SPI的机制注入进来的，
具体的代码可以跟进一下在Initialization#makeInjectorWithModules方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ExtensionsConfig config = baseInjector.getInstance(ExtensionsConfig<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (DruidModule <span class="keyword">module</span> : Initialization.getFromExtensions(config, DruidModule<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">  extensionModules.addModule(<span class="keyword">module</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路已经提供了，这一块的逻辑如果有时间的话后面会补齐，不过也已经很简单明了了。</p>
<p>我们继续看一下<code>metadataSupervisorManager.getLatest()</code>执行了什么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">handle.createQuery(</span><br><span class="line">    StringUtils.format(</span><br><span class="line">        <span class="string">"SELECT r.spec_id, r.payload "</span></span><br><span class="line">        + <span class="string">"FROM %1$s r "</span></span><br><span class="line">        + <span class="string">"INNER JOIN(SELECT spec_id, max(id) as id FROM %1$s GROUP BY spec_id) latest "</span></span><br><span class="line">        + <span class="string">"ON r.id = latest.id"</span>,</span><br><span class="line">        getSupervisorsTable()</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如上所示，分析这条sql语句可以看的出来，这里是将最新的摄入规则给取出来了，这里的摄入规则就是我们提交任务之前的json体。
接下来就是supervisor的创建了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">createAndStartSupervisorInternal</span><span class="params">(SupervisorSpec spec, <span class="keyword">boolean</span> persistSpec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String id = spec.getId();</span><br><span class="line">  <span class="keyword">if</span> (supervisors.containsKey(id)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (persistSpec) &#123;</span><br><span class="line">    <span class="comment">// 保存摄入规则的元数据</span></span><br><span class="line">    metadataSupervisorManager.insert(id, spec);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Supervisor supervisor;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 创建supervisor对象</span></span><br><span class="line">    supervisor = spec.createSupervisor();</span><br><span class="line">    supervisor.start();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// Supervisor creation or start failed write tombstone only when trying to start a new supervisor</span></span><br><span class="line">    <span class="keyword">if</span> (persistSpec) &#123;</span><br><span class="line">      metadataSupervisorManager.insert(id, <span class="keyword">new</span> NoopSupervisorSpec(<span class="keyword">null</span>, spec.getDataSources()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  supervisors.put(id, Pair.of(supervisor, spec));</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面也分成了几个过程：</p>
<ul>
<li>获取该摄入规则的id（<code>摄入规则的id是用datasource来区分的</code>）</li>
<li>根据是否需要持久化摄入规则来确定将这些摄入规则持久化（很明显我们刚刚从数据库中取出来，肯定是不需要持久化的）</li>
<li>创建并启动<code>Supervisor</code>，这里会根据摄入规则数据源类型的不同来创建不同类型的supervisor，并将supervisor相关的信息保存在内存中</li>
</ul>
<p>我们接下来看一下<code>start</code>方法的调用过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stateChangeLock) &#123;</span><br><span class="line">      Preconditions.checkState(!lifecycleStarted, <span class="string">"already started"</span>);</span><br><span class="line">      Preconditions.checkState(!exec.isShutdown(), <span class="string">"already stopped"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Try normal initialization first, if that fails then schedule periodic initialization retries</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        tryInit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">          log.warn(</span><br><span class="line">              <span class="string">"First initialization attempt failed for SeekableStreamSupervisor[%s], starting retries..."</span>,</span><br><span class="line">              dataSource</span><br><span class="line">          );</span><br><span class="line"></span><br><span class="line">          exec.submit(</span><br><span class="line">              () -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  RetryUtils.retry(</span><br><span class="line">                      () -&gt; &#123;</span><br><span class="line">                        tryInit();</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                      &#125;,</span><br><span class="line">                      (throwable) -&gt; !started,</span><br><span class="line">                      <span class="number">0</span>,</span><br><span class="line">                      MAX_INITIALIZATION_RETRIES,</span><br><span class="line">                      <span class="keyword">null</span>,</span><br><span class="line">                      <span class="keyword">null</span></span><br><span class="line">                  );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">                  log.makeAlert(</span><br><span class="line">                      <span class="string">"Failed to initialize after %s retries, aborting. Please resubmit the supervisor spec to restart this supervisor [%s]"</span>,</span><br><span class="line">                      MAX_INITIALIZATION_RETRIES,</span><br><span class="line">                      supervisorId</span><br><span class="line">                  ).emit();</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e2);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      lifecycleStarted = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>上面这一坨代码其实就做了一件事，那就是调用<code>tryInit()</code>方法，只不过在调用抛出异常的时候增加了失败重试的机制。我们来看一下<code>tryInit()</code>
做了什么操作吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tryInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (stateChangeLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (started) &#123;</span><br><span class="line">      log.warn(<span class="string">"Supervisor was already started, skipping init"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stopped) &#123;</span><br><span class="line">      log.warn(<span class="string">"Supervisor was already stopped, skipping init."</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      recordSupplier = setupRecordSupplier();</span><br><span class="line"></span><br><span class="line">      exec.submit(</span><br><span class="line">          () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">long</span> pollTimeout = Math.max(ioConfig.getPeriod().getMillis(), MAX_RUN_FREQUENCY_MILLIS);</span><br><span class="line">              <span class="keyword">while</span> (!Thread.currentThread().isInterrupted() &amp;&amp; !stopped) &#123;</span><br><span class="line">                <span class="keyword">final</span> Notice notice = notices.poll(pollTimeout, TimeUnit.MILLISECONDS);</span><br><span class="line">                <span class="keyword">if</span> (notice == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 这一步才是真正的触发任务执行的调用</span></span><br><span class="line">                    notice.handle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                  stateManager.recordThrowableEvent(e);</span><br><span class="line">                  log.makeAlert(e, <span class="string">"SeekableStreamSupervisor[%s] failed to handle notice"</span>, dataSource)</span><br><span class="line">                     .addData(<span class="string">"noticeClass"</span>, notice.getClass().getSimpleName())</span><br><span class="line">                     .emit();</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              stateManager.recordThrowableEvent(e);</span><br><span class="line">              log.info(<span class="string">"SeekableStreamSupervisor[%s] interrupted, exiting"</span>, dataSource);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line">      firstRunTime = DateTimes.nowUtc().plus(ioConfig.getStartDelay());</span><br><span class="line">      scheduledExec.scheduleAtFixedRate(</span><br><span class="line">          buildRunTask(),</span><br><span class="line">          ioConfig.getStartDelay().getMillis(),</span><br><span class="line">          Math.max(ioConfig.getPeriod().getMillis(), MAX_RUN_FREQUENCY_MILLIS),</span><br><span class="line">          TimeUnit.MILLISECONDS</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      scheduleReporting(reportingExec);</span><br><span class="line"></span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      .........</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的过程依次是：</p>
<ul>
<li>检查supervisor状态的合法性</li>
<li>配置消费数据的客户端的属性（对于kafka类型的摄入规则来说，这一步就是创建consumer，我们接下来会具体分析一下）</li>
<li>构建运行的任务并提交运行，接着使用摄入规则中定义的周期周期性的定时调度来构建运行的任务</li>
</ul>
<p>这里我们看到有创建<code>recordSupplier = setupRecordSupplier();</code>，不过这也是一个模板方法，真正的实现我们就挑一个kafka的吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> RecordSupplier&lt;Integer, Long&gt; <span class="title">setupRecordSupplier</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> KafkaRecordSupplier(spec.getIoConfig().getConsumerProperties(), sortingMapper);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaRecordSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Map&lt;String, Object&gt; consumerProperties,</span></span></span><br><span class="line"><span class="function"><span class="params">    ObjectMapper sortingMapper</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(getKafkaConsumer(sortingMapper, consumerProperties));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">KafkaRecordSupplier</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    KafkaConsumer&lt;<span class="keyword">byte</span>[], <span class="keyword">byte</span>[]&gt; consumer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.consumer = consumer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，recordSupplier里面是封装了一个kafkaConsumer，到此为止，我们也就不再过多的深究了。</p>
<p>接下来我们看一下构建的任务吧，具体入口就是上面的notice.handle()，跟进下来代码最终会走到下面这里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">buildRunTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> () -&gt; notices.add(<span class="keyword">new</span> RunNotice());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runInternal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    possiblyRegisterListener();</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.CONNECTING_TO_STREAM);</span><br><span class="line">    <span class="comment">// TODO 这里猜测应该就是低版本的kafka连接不上存在问题的原因</span></span><br><span class="line">    <span class="keyword">if</span> (!updatePartitionDataFromStream() &amp;&amp; !stateManager.isAtLeastOneSuccessfulRun()) &#123;</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// if we can't connect to the stream and this is the first run, stop and wait to retry the connection</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.DISCOVERING_INITIAL_TASKS);</span><br><span class="line">    discoverTasks();</span><br><span class="line"></span><br><span class="line">    updateTaskStatus();</span><br><span class="line"></span><br><span class="line">    checkTaskDuration();</span><br><span class="line"></span><br><span class="line">  checkPendingCompletionTasks();</span><br><span class="line"></span><br><span class="line">  checkCurrentTaskState();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// if supervisor is not suspended, ensure required tasks are running</span></span><br><span class="line">  <span class="comment">// if suspended, ensure tasks have been requested to gracefully stop</span></span><br><span class="line">  <span class="keyword">if</span> (!spec.isSuspended()) &#123;</span><br><span class="line">    log.info(<span class="string">"[%s] supervisor is running."</span>, dataSource);</span><br><span class="line"></span><br><span class="line">    stateManager.maybeSetState(SeekableStreamSupervisorStateManager.SeekableStreamState.CREATING_TASKS);</span><br><span class="line">    createNewTasks();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    log.info(<span class="string">"[%s] supervisor is suspended."</span>, dataSource);</span><br><span class="line">      gracefulShutdownInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是根据摄入规则运行任务的整个过程，这里我们没有提到的是通过http的方式提交任务的过程，不过这个也不是太难，具体可以查看
http接口的方式找到入口，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@POST</span></span><br><span class="line"><span class="meta">@Consumes</span>(MediaType.APPLICATION_JSON)</span><br><span class="line"><span class="meta">@Produces</span>(MediaType.APPLICATION_JSON)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">specPost</span><span class="params">(<span class="keyword">final</span> SupervisorSpec spec, @Context <span class="keyword">final</span> HttpServletRequest req)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asLeaderWithSupervisorManager(</span><br><span class="line">      manager -&gt; &#123;</span><br><span class="line">        .....</span><br><span class="line">        <span class="comment">// 这一步会创建或者更新supervisor</span></span><br><span class="line">        manager.createOrUpdateAndStartSupervisor(spec);</span><br><span class="line">        <span class="keyword">return</span> Response.ok(ImmutableMap.of(<span class="string">"id"</span>, spec.getId())).build();</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就不过多的赘述http的请求流程了，总而言之一句话，通过http的方式创建任务最终也会走到上面的代码逻辑中。在上面的runInternal方法
中我们可以看到有一行createNewTasks的代码，创建任务最终就是进入到这个方法中。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createNewTasks</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="comment">// 由于是新创建的任务，因此这里的任务数量必定是0</span></span><br><span class="line">  <span class="comment">// iterate through all the current task groups and make sure each one has the desired number of replica tasks</span></span><br><span class="line">  <span class="keyword">boolean</span> createdTask = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (Entry&lt;Integer, TaskGroup&gt; entry : activelyReadingTaskGroups.entrySet()) &#123;</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">if</span> (ioConfig.getReplicas() &gt; taskGroup.tasks.size()) &#123;</span><br><span class="line">      ......</span><br><span class="line">      createTasksForGroup(groupId, ioConfig.getReplicas() - taskGroup.tasks.size());</span><br><span class="line">      createdTask = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (createdTask &amp;&amp; firstRunTime.isBeforeNow()) &#123;</span><br><span class="line">    <span class="comment">// Schedule a run event after a short delay to update our internal data structures with the new tasks that were</span></span><br><span class="line">    <span class="comment">// just created. This is mainly for the benefit of the status API in situations where the run period is lengthy.</span></span><br><span class="line">    scheduledExec.schedule(buildRunTask(), <span class="number">5000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们省略了不必要的代码，可以看到创建任务走到createTasksForGroup这个方法中了，点开这个方法代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTasksForGroup</span><span class="params">(<span class="keyword">int</span> groupId, <span class="keyword">int</span> replicas)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> JsonProcessingException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  TaskGroup group = activelyReadingTaskGroups.get(groupId);</span><br><span class="line">  Map&lt;PartitionIdType, SequenceOffsetType&gt; startPartitions = group.startingSequences;</span><br><span class="line">  Map&lt;PartitionIdType, SequenceOffsetType&gt; endPartitions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (PartitionIdType partition : startPartitions.keySet()) &#123;</span><br><span class="line">    endPartitions.put(partition, getEndOfPartitionMarker());</span><br><span class="line">  &#125;</span><br><span class="line">  Set&lt;PartitionIdType&gt; exclusiveStartSequenceNumberPartitions = activelyReadingTaskGroups</span><br><span class="line">      .get(groupId)</span><br><span class="line">      .exclusiveStartSequenceNumberPartitions;</span><br><span class="line"></span><br><span class="line">  DateTime minimumMessageTime = group.minimumMessageTime.orNull();</span><br><span class="line">  DateTime maximumMessageTime = group.maximumMessageTime.orNull();</span><br><span class="line"></span><br><span class="line">  SeekableStreamIndexTaskIOConfig newIoConfig = createTaskIoConfig(</span><br><span class="line">      groupId,</span><br><span class="line">      startPartitions,</span><br><span class="line">      endPartitions,</span><br><span class="line">      group.baseSequenceName,</span><br><span class="line">      minimumMessageTime,</span><br><span class="line">      maximumMessageTime,</span><br><span class="line">      exclusiveStartSequenceNumberPartitions,</span><br><span class="line">      ioConfig</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  List&lt;SeekableStreamIndexTask&lt;PartitionIdType, SequenceOffsetType&gt;&gt; taskList = createIndexTasks(</span><br><span class="line">      replicas,</span><br><span class="line">      group.baseSequenceName,</span><br><span class="line">      sortingMapper,</span><br><span class="line">      group.checkpointSequences,</span><br><span class="line">      newIoConfig,</span><br><span class="line">      taskTuningConfig,</span><br><span class="line">      rowIngestionMetersFactory</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (SeekableStreamIndexTask indexTask : taskList) &#123;</span><br><span class="line">    Optional&lt;TaskQueue&gt; taskQueue = taskMaster.getTaskQueue();</span><br><span class="line">    <span class="keyword">if</span> (taskQueue.isPresent()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 添加task的时候如果有异常则说明添加失败，添加成功之后，会通过定期调度来执行znode节点的创建</span></span><br><span class="line">        taskQueue.get().add(indexTask);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (EntryExistsException e) &#123;</span><br><span class="line">        stateManager.recordThrowableEvent(e);</span><br><span class="line">        log.error(<span class="string">"Tried to add task [%s] but it already exists"</span>, indexTask.getId());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.error(<span class="string">"Failed to get task queue because I'm not the leader!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中可以看到首先是摄入任务的一些正常配置，<strong>接下来会获取到taskMaster的taskQueue</strong>，这里就是新建任务的核心内容了，
也是整个业务的关键，其主要思想就是通过taskQueue实现任务的生产和消费，这个也算是一种很常用的模式了，生产的话就是将新建的任务
存放到队列中，消费的话就是将任务从队列中取出来，并跟新到zookeeper节点下面，催生peon进程了，上面我们看到了生产任务的过程，
消费任务的话要从taskMatser看起了，不过taskMaster也仅仅是任务的入口，并不是真正消费任务的地方，其中的核心代码就是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.leadershipListener = <span class="keyword">new</span> DruidLeaderSelector.Listener()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">becomeLeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    giant.lock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// I AM THE MASTER OF THE UNIVERSE.</span></span><br><span class="line">    log.info(<span class="string">"By the power of Grayskull, I have the power!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      taskLockbox.syncFromStorage();</span><br><span class="line">      taskRunner = runnerFactory.build();</span><br><span class="line">      taskQueue = <span class="keyword">new</span> TaskQueue(</span><br><span class="line">          taskLockConfig,</span><br><span class="line">          taskQueueConfig,</span><br><span class="line">          taskStorage,</span><br><span class="line">          taskRunner,</span><br><span class="line">          taskActionClientFactory,</span><br><span class="line">          taskLockbox,</span><br><span class="line">          emitter</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Sensible order to start stuff:</span></span><br><span class="line">      <span class="keyword">final</span> Lifecycle leaderLifecycle = <span class="keyword">new</span> Lifecycle(<span class="string">"task-master"</span>);</span><br><span class="line">      <span class="keyword">if</span> (leaderLifecycleRef.getAndSet(leaderLifecycle) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        log.makeAlert(<span class="string">"TaskMaster set a new Lifecycle without the old one being cleared!  Race condition"</span>)</span><br><span class="line">           .emit();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.addManagedInstance(taskRunner);</span><br><span class="line">      leaderLifecycle.addManagedInstance(taskQueue);</span><br><span class="line">      leaderLifecycle.addManagedInstance(supervisorManager);</span><br><span class="line">      leaderLifecycle.addManagedInstance(overlordHelperManager);</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.addHandler(</span><br><span class="line">          <span class="keyword">new</span> Lifecycle.Handler()</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">              initialized = <span class="keyword">true</span>;</span><br><span class="line">              serviceAnnouncer.announce(node);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">              serviceAnnouncer.unannounce(node);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      );</span><br><span class="line"></span><br><span class="line">      leaderLifecycle.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      giant.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopBeingLeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    giant.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      initialized = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">final</span> Lifecycle leaderLifecycle = leaderLifecycleRef.getAndSet(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (leaderLifecycle != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leaderLifecycle.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">      giant.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们可以看到taskMaster首先是使用了zookeeper进行选主操作，一旦选出来之后，就会执行一些初始化的操作，这些初始化的
操作是<code>leaderLifecycle.addManagedInstance</code>完成的，上文也有解释<code>leaderLifecycle</code>像是一个钩子，会自动的初始化一些操作，
这里我们可以跟进一下TaskQueue的start方法，具体如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@LifecycleStart</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">giant.lock();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  Preconditions.checkState(!active, <span class="string">"queue must be stopped"</span>);</span><br><span class="line">  active = <span class="keyword">true</span>;</span><br><span class="line">  syncFromStorage();</span><br><span class="line">  managerExec.submit(</span><br><span class="line">      <span class="keyword">new</span> Runnable()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              manage();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ......</span><br><span class="line">  );</span><br><span class="line">  ScheduledExecutors.scheduleAtFixedRate(</span><br><span class="line">      storageSyncExec,</span><br><span class="line">      config.getStorageSyncRate(),</span><br><span class="line">      <span class="keyword">new</span> Callable&lt;ScheduledExecutors.Signal&gt;()</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> ScheduledExecutors.<span class="function">Signal <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            syncFromStorage();</span><br><span class="line">          &#125;</span><br><span class="line">          ......</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  );</span><br><span class="line">  managementMayBeNecessary.signalAll();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  giant.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中我们看到主要是两块的业务逻辑<code>manage()、syncFromStorage()</code>，当前我们是跟进任务的创建，因此下面的代码可以暂时搁置。
我们看一下manage执行了什么操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">manage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">log.info(<span class="string">"Beginning management in %s."</span>, config.getStartDelay());</span><br><span class="line">Thread.sleep(config.getStartDelay().getMillis());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ignore return value- we'll get the IDs and futures from getKnownTasks later.</span></span><br><span class="line">taskRunner.restore();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (active) &#123;</span><br><span class="line">  giant.lock();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// Task futures available from the taskRunner</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, ListenableFuture&lt;TaskStatus&gt;&gt; runnerTaskFutures = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> TaskRunnerWorkItem workItem : taskRunner.getKnownTasks()) &#123;</span><br><span class="line">      runnerTaskFutures.put(workItem.getTaskId(), workItem.getResult());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Attain futures for all active tasks (assuming they are ready to run).</span></span><br><span class="line">    <span class="comment">// Copy tasks list, as notifyStatus may modify it.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> Task task : ImmutableList.copyOf(tasks)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!taskFutures.containsKey(task.getId())) &#123;</span><br><span class="line">        <span class="keyword">final</span> ListenableFuture&lt;TaskStatus&gt; runnerTaskFuture;</span><br><span class="line">        <span class="keyword">if</span> (runnerTaskFutures.containsKey(task.getId())) &#123;</span><br><span class="line">          runnerTaskFuture = runnerTaskFutures.get(task.getId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Task should be running, so run it.</span></span><br><span class="line">          <span class="keyword">final</span> <span class="keyword">boolean</span> taskIsReady;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            taskIsReady = task.isReady(taskActionClientFactory.create(task));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(e, <span class="string">"Exception thrown during isReady for task: %s"</span>, task.getId());</span><br><span class="line">            notifyStatus(task, TaskStatus.failure(task.getId()), <span class="string">"failed because of exception[%s]"</span>, e.getClass());</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (taskIsReady) &#123;</span><br><span class="line">            log.info(<span class="string">"Asking taskRunner to run: %s"</span>, task.getId());</span><br><span class="line">            runnerTaskFuture = taskRunner.run(task);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        taskFutures.put(task.getId(), attachCallbacks(task, runnerTaskFuture));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTaskPending(task)) &#123;</span><br><span class="line">        <span class="comment">// if the taskFutures contain this task and this task is pending, also let the taskRunner</span></span><br><span class="line">        <span class="comment">// to run it to guarantee it will be assigned to run</span></span><br><span class="line">        <span class="comment">// see https://github.com/apache/druid/pull/6991</span></span><br><span class="line">        taskRunner.run(task);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Kill tasks that shouldn't be running</span></span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; tasksToKill = Sets.difference(</span><br><span class="line">        runnerTaskFutures.keySet(),</span><br><span class="line">        ImmutableSet.copyOf(</span><br><span class="line">            Lists.transform(</span><br><span class="line">                tasks,</span><br><span class="line">                <span class="keyword">new</span> Function&lt;Task, Object&gt;()</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Task task)</span></span></span><br><span class="line"><span class="function">                  </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> task.getId();</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (!tasksToKill.isEmpty()) &#123;</span><br><span class="line">      log.info(<span class="string">"Asking taskRunner to clean up %,d tasks."</span>, tasksToKill.size());</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> String taskId : tasksToKill) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          taskRunner.shutdown(</span><br><span class="line">              taskId,</span><br><span class="line">              <span class="string">"task is not in runnerTaskFutures[%s]"</span>,</span><br><span class="line">              runnerTaskFutures.keySet()</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(e, <span class="string">"TaskRunner failed to clean up task: %s"</span>, taskId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// awaitNanos because management may become necessary without this condition signalling,</span></span><br><span class="line">    <span class="comment">// due to e.g. tasks becoming ready when other folks mess with the TaskLockbox.</span></span><br><span class="line">    managementMayBeNecessary.awaitNanos(MANAGEMENT_WAIT_TIMEOUT_NANOS);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span> &#123;</span><br><span class="line">    giant.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码是一个死循环，主要的操作就是<code>taskRunner.run(task);</code>这一行代码，这里的taskRunner是一个接口，我们可以
任选一个实现累来看一下任务创建的过程是怎么样的，这里我选了<code>RemoteTaskRunner</code>，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListenableFuture&lt;TaskStatus&gt; <span class="title">run</span><span class="params">(<span class="keyword">final</span> Task task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> RemoteTaskRunnerWorkItem completeTask, runningTask, pendingTask;</span><br><span class="line">  <span class="keyword">if</span> ((pendingTask = pendingTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    log.info(<span class="string">"Assigned a task[%s] that is already pending!"</span>, task.getId());</span><br><span class="line">    runPendingTasks();</span><br><span class="line">    <span class="keyword">return</span> pendingTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((runningTask = runningTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ZkWorker zkWorker = findWorkerRunningTask(task.getId());</span><br><span class="line">    <span class="keyword">if</span> (zkWorker == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.warn(<span class="string">"Told to run task[%s], but no worker has started running it yet."</span>, task.getId());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      log.info(<span class="string">"Task[%s] already running on %s."</span>, task.getId(), zkWorker.getWorker().getHost());</span><br><span class="line">      TaskAnnouncement announcement = zkWorker.getRunningTasks().get(task.getId());</span><br><span class="line">      <span class="keyword">if</span> (announcement.getTaskStatus().isComplete()) &#123;</span><br><span class="line">        taskComplete(runningTask, zkWorker, announcement.getTaskStatus());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> runningTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((completeTask = completeTasks.get(task.getId())) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> completeTask.getResult();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> addPendingTask(task).getResult();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面有一行代码<code>runPendingTasks</code>，跟进该代码可以发现有一行代码<code>tryAssignTask(task, taskRunnerWorkItem)</code>，该过程是一个阻塞的过程，
核心代码也只有一行：<code>announceTask</code>，该方法的目的就是在zookeeper上发布一个任务，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">announceTask</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> Task task,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> ZkWorker theZkWorker,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">final</span> RemoteTaskRunnerWorkItem taskRunnerWorkItem</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">final</span> String worker = theZkWorker.getWorker().getHost();</span><br><span class="line">  <span class="keyword">synchronized</span> (statusLock) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!zkWorkers.containsKey(worker) || lazyWorkers.containsKey(worker)) &#123;</span><br><span class="line">      <span class="comment">// the worker might have been killed or marked as lazy</span></span><br><span class="line">      log.info(<span class="string">"Not assigning task to already removed worker[%s]"</span>, worker);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"Coordinator asking Worker[%s] to add task[%s]"</span>, worker, task.getId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建znode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CuratorUtils.createIfNotExists(</span><br><span class="line">        cf,</span><br><span class="line">        JOINER.join(indexerZkConfig.getTasksPath(), worker, task.getId()),</span><br><span class="line">        CreateMode.EPHEMERAL,</span><br><span class="line">        jsonMapper.writeValueAsBytes(task),</span><br><span class="line">        config.getMaxZnodeBytes()</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    RemoteTaskRunnerWorkItem workItem = pendingTasks.remove(task.getId());</span><br><span class="line">    <span class="keyword">if</span> (workItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.makeAlert(<span class="string">"WTF?! Got a null work item from pending tasks?! How can this be?!"</span>)</span><br><span class="line">         .addData(<span class="string">"taskId"</span>, task.getId())</span><br><span class="line">         .emit();</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RemoteTaskRunnerWorkItem newWorkItem = workItem.withWorker(theZkWorker.getWorker(), <span class="keyword">null</span>);</span><br><span class="line">    runningTasks.put(task.getId(), newWorkItem);</span><br><span class="line">    log.info(<span class="string">"Task %s switched from pending to running (on [%s])"</span>, task.getId(), newWorkItem.getWorker().getHost());</span><br><span class="line">    TaskRunnerUtils.notifyStatusChanged(listeners, task.getId(), TaskStatus.running(task.getId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Syncing state with Zookeeper - don't assign new tasks until the task we just assigned is actually running</span></span><br><span class="line">    <span class="comment">// on a worker - this avoids overflowing a worker with tasks</span></span><br><span class="line">    Stopwatch timeoutStopwatch = Stopwatch.createStarted();</span><br><span class="line">    <span class="keyword">while</span> (!isWorkerRunningTask(theZkWorker, task.getId())) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">long</span> waitMs = config.getTaskAssignmentTimeout().toStandardDuration().getMillis();</span><br><span class="line">      statusLock.wait(waitMs);</span><br><span class="line">      <span class="keyword">long</span> elapsed = timeoutStopwatch.elapsed(TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">if</span> (elapsed &gt;= waitMs) &#123;</span><br><span class="line">        log.makeAlert(</span><br><span class="line">            <span class="string">"Task assignment timed out on worker [%s], never ran task [%s]! Timeout: (%s &gt;= %s)!"</span>,</span><br><span class="line">            worker,</span><br><span class="line">            task.getId(),</span><br><span class="line">            elapsed,</span><br><span class="line">            config.getTaskAssignmentTimeout()</span><br><span class="line">        ).emit();</span><br><span class="line">        taskComplete(taskRunnerWorkItem, theZkWorker, TaskStatus.failure(task.getId()));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，提交摄入任务并在zookeeper上面发布任务的正流程就结束了，不过这个时候任务并没有被peon进程领取并执行，另外还包含一些细节，如
taskMaster故障之后重新选举任务的重建过程是怎么样的。这些就留着以后有时间再来分析了吧。</p>
<h2 id="broker源码走读"><a href="#broker源码走读" class="headerlink" title="broker源码走读"></a>broker源码走读</h2><p>上面的过程中我们简单的看了一下提交摄入任务的整体流程，也看到了任务是如何在zookeeper上进行发布的，也就是数据的摄入是如何执行的，
另外一个核心的问题就是数据的查询是什么流程了，这个我们可以采用同样的方式，从http接口的方式来分析具体的实现，具体入口如下：</p>
<h2 id="MiddleManager源码走读"><a href="#MiddleManager源码走读" class="headerlink" title="MiddleManager源码走读"></a>MiddleManager源码走读</h2><p>在真正走读代码之前我们还是先回顾一下MiddleManager的功能，并通过功能作为入口一点一点的深入代码的解析。首先从官网上我们知道middleManager
是用来摄入数据的，数据的摄入又分为以下几个步骤：</p>
<ul>
<li>对于一个append类型的任务来说，会调用Overload上的allocate接口来生成segment的唯一标识，对于一个覆盖写的任务来说这是通过锁定一个时间区间并
创建一个新的版本号来实现的</li>
<li>如果是一个realtime类型的摄入任务的话，segment马上就可以查到了，但是当前的segment并未发布</li>
<li>当完成了当前segment数据的摄入之后，将会把segment发不到深度存储中，并且记录当前segment的元数据，如果是realtime类型的task，那么还会
等待Historical进程来加载数据，否则的话segment会马上存在与historical进程所在的节点上</li>
</ul>
<p>知道了MiddleManager的功能之后，我们就可以通过跟踪代码来看一下具体的流程了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>时间关系，关于druid启动的流程我们的分析就到此为止了，后面会专门针对具体的process来查看具体的功能代码。</p>
<p><a href="https://www.jianshu.com/p/c04db5d3ed90" target="_blank" rel="noopener">Druid中用到的一些技术</a></p>
<h1 id="问题记录："><a href="#问题记录：" class="headerlink" title="问题记录："></a>问题记录：</h1><p>1、生产环境中realtime的内存设置为1G，结果发现对于两个字段的groupby操作经常会将实时摄入的节点打卦，
后面经过每秒上报数据评估以及SQL查询的条件估算实际，对应时间区间的内存大小
为3G，因此调整之后解决了查询数据量将节点打卦的情况，但是依然留存一个问题，就是查询效率，因为
在定制sql的时候，采用了两个字段的groupBy的操作，结果发现，相较于一个字段的group by，
两个字段进行groupby明显要慢很多。后面查阅资料发现，单个字段的groupBY会被优化成topn查询，因此，我
们的业务将需要进行两个字段的groupby采用transform的方式在摄入的时候将其拼接成一个字段，这样针对这一个字段进行
groupBY，效率明显提升上去了，大致从原来的20s提升为2s。</p>
<p>另外在实际操作的过程中，由于我们数据摄入是从kafka中获取到的，而kafka中消息是一个宽消息，对应为null或者为空
字符串的字段在数据摄入的时候会被转换成0（转换的过程中会抛出大量的process error，但是结果并不会受到影响），
由于查询需要，我这边需要把非0的数据过滤出来，因此在sql查询的时候是通过！=0的方式来过滤的，结果很奇怪，查询结果中
竟然包含了为0 的选项，因此我又试了一下&gt;0的选项，结果发现这次筛选出来的数据完全满足要求了，最后我又筛选了=0的选项，
从整体的条数来判断，=0的数据量也是对的上的，因此，对于&gt;0的选项还不清楚为什么这种查询条件会把=0的数据给查询出来。
有待跟进</p>

            
                

            
        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">tags：
            
        </div>
        
    </article>
    
        <p style="text-align: center">本文代表个人观点，内容仅供参考</p>
    
    
    

</div>
<script src="/js/busuanzi.pure.mini.js"></script>


        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner" style="text-align: center">

    </div>
</footer>
<script src="/js/SimpleCore.js"></script>

</div>
<!-- search pop -->
<div class="popup search-popup local-search-popup">
    <div class="local-search-header clearfix">
        <span class="search-icon">
            <i class="fa fa-search"></i>
        </span>
        <span class="popup-btn-close">
            <i class="fa fa-times-circle"></i>
        </span>
        <div class="local-search-input-wrapper">
            <input id="local-search-input" spellcheck="false" type="text" autocomplete="off" placeholder="请输入查询关键词">
        </div>
    </div>
    <div id="local-search-result"></div>
</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        var jsi_config = {
            buildingTime: '01/20/2018',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            snsQRCode: '/images/sns-qrcode.png',
            donateImg: '/images/donate-qr.png',
            localSearch: { dbPath: '' },
            readMode: 'day'
        };
        
            jsi_config.localSearch = {
                dbPath: '/search.xml',
                trigger: 'auto',
                topN: '1',
                unescape: 'false'
            }
        
        SimpleCore.init(jsi_config);
        
    });
</script>
</body>
</html>
